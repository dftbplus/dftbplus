#!/usr/bin/env python3
#------------------------------------------------------------------------------#
#  DFTB+: general package for performing fast atomistic simulations            #
#  Copyright (C) 2006 - 2025  DFTB+ developers group                           #
#                                                                              #
#  See the LICENSE file for terms of usage and distribution.                   #
#------------------------------------------------------------------------------#

"""Small utility to compare numerical results of calculations

The tagged data is assumed to be represented in the form as provided by the taggedout module of the
DFTB project. See the appropriate source code for the details. For the format of the config file see
the provided commented sample config file.
"""

from abc import ABC, abstractmethod
from argparse import ArgumentParser, Namespace
from dataclasses import dataclass, field
from enum import StrEnum, IntEnum
import re
import sys
import tomllib
from typing import Any

import numpy as np

from tagreader import InvalidEntry, TaggedCollection, TaggedDataParser, TaggedEntry

VERSION = 0.3
DESCRIPTION = "Compares two tagged output files according the tolerances in config file(s)."


class ExitCode(IntEnum):
    """Possible exit codes."""
    SUCCESS = 0
    FAILURE = 1


class TestStatus(StrEnum):
    """Possible test status values."""
    OK = "ok"
    SKIPPED = "skipped"
    FAILED = "FAILED"
    ERROR = "ERROR"
    UNKNOWN = "??????"


# Name of the default config file
DEFAULT_CONFIG = "tagdiff.toml"


class DiffError(Exception):
    """Raised, if building difference fails for some reason."""


class DiffChecker(ABC):
    """Base class for methods which can check tagged data entries for differences.

    Args:
      args: Dictionary containing all options for the checker.

    Attributes:
      NAME (class attribute): Name of the checking method.
      ARGS (class attribute): Dictionary of possible arguments with default values for the given
      DiffChecker. If the stored value is None, the argument is treated as required.

    """

    NAME = "unspecified"
    ARGS: dict[str, Any] = {}

    def __init__(self, args: dict[str, Any]):
        """Initializes a DiffChecker.

        Args:
            args: Dictionary with arguments specified for the DiffChecker.
        """
        extra_args = set(args.keys()) - set(self.ARGS.keys())
        if extra_args:
            raise ValueError(
                f"Invalid argument(s) specified for diff. method {self.NAME}: "
                f"{', '.join(extra_args)}"
            )
        self._args = {**self.ARGS, **args}
        missing_required_args = [key for key, value in self._args.items() if value is None]
        if missing_required_args:
            raise ValueError(
                f"Required argument(s) not specified for diff. method {self.NAME}: "
                f"{', '.join(missing_required_args)}"
            )

    @abstractmethod
    def compare(self, expected: TaggedEntry, obtained: TaggedEntry) -> tuple[bool, dict]:
        """Compares expected data with obtained data.

        Args:
            expected: Tagged data entry with expected data.
            obtained: Tagged data entry with obtained data.

        Returns:
            Tuple of bool with comparison status (True: passed, False: failed) and a dictionary
            with details of the comparison.
        """
        raise NotImplementedError

    @property
    def args(self) -> dict:
        return self._args


class AllClose(DiffChecker):
    """Checks whether all elements of two arrays are numerically close to each other"""

    NAME = "all_close"
    ARGS = {"atol": 1e-10, "rtol": 1e-10}

    def compare(self, expected: TaggedEntry, obtained: TaggedEntry) -> tuple[bool, dict]:
        aa = expected.value_array
        bb = obtained.value_array
        rtol = self._args["rtol"]
        atol = self._args["atol"]
        absdiff = np.abs(aa - bb)
        passed = np.all(absdiff <= np.maximum(rtol * np.maximum(np.abs(aa), np.abs(bb)), atol))
        details = {
            "maxdiff": np.max(absdiff),
        }
        return bool(passed), details


# List of all diff checker classes which should be enabled
DIFF_CHECKER_CLASSES = [AllClose]

# Map names to checker class
DIFF_CHECKER_CLASSES_BY_NAME = {cls.NAME: cls for cls in DIFF_CHECKER_CLASSES}


@dataclass
class DiffRule:
    """Represents a difference checking rule from the config file.

    Args:
        pattern: String representation of the pattern tagged data is matched against.
        diffmethod: Name of the diffchecker method to use.
        diffargs: Dictionary with the arguments to be used to initialize the diffchecker instance.
        keep: Whether the matching tagged entries should be kept after processing (so that other
            diff checkers with matching regular expressions can process it) or discarded.

    Attributes:
        regex: Compiled regex to select tagged data entries this checker should be applied on.
        diffchecker: The initialized DiffChecker instance.
    """

    pattern: str
    diffmethod: str
    diffargs: dict[str, Any]
    keep: bool = False
    regex: re.Pattern = field(init=False, repr=False)
    diffchecker: DiffChecker = field(init=False, repr=False)

    def __post_init__(self):
        try:
            self.regex = re.compile(self.pattern)
        except re.error:
            raise InvalidEntry(msg=f"Invalid regular expression pattern: {self.pattern}")
        try:
            self.diffchecker = DIFF_CHECKER_CLASSES_BY_NAME[self.diffmethod](self.diffargs)
        except IndexError:
            raise InvalidEntry(msg=f"Invalid diff. method: {self.diffmethod}")
        except ValueError as err:
            raise InvalidEntry(msg="Could not initalize diff. method {diffmethod}: {err}") from err


def load_diff_rules(fname: str) -> list[DiffRule]:
    """Reads a config file and creates corresponding DiffRule items.

    Args:
        fname: Name of the file to process.
    """
    with open(fname, "rb") as fp:
        config = tomllib.load(fp)
    rules = config["rule"]
    diffrules = []
    for rule in rules:
        pattern = rule["pattern"]
        diffmethod = rule["diffmethod"]
        diffargs = rule["diffargs"]
        keep = rule.get("keep", False)
        diffrule = DiffRule(pattern, diffmethod, diffargs, keep)
        diffrules.append(diffrule)
    return diffrules


def parse_arguments() -> Namespace:
    """Parses script's arguments"""

    parser = ArgumentParser(description=DESCRIPTION)
    parser.add_argument("--version", action="version", version=f"%(prog)s {VERSION}")
    parser.add_argument(
        "-c",
        "--config",
        dest="configfile",
        action="append",
        help="config file to use (multiple config files can be "
        "specified by using this option multiple times)",
    )
    parser.add_argument(
        "-v", "--verbose", dest="verbose", action="store_true", default=False, help="verbose mode"
    )
    parser.add_argument("expected", help="tagged data file with expected results")
    parser.add_argument("obtained", help="tagged data file with obtained results")
    return parser.parse_args()


def print_entry_log(log: dict[str, Any]):
    print()
    lstr = f"{log['name']} : {log['checker']}"
    rstr = f"[{log['status']}]"
    npadding = max(1, 80 - len(lstr) - len(rstr))
    print(f"{lstr}{'':>{npadding}}{rstr}")
    if msg := log.get("msg"):
        print(f"> {msg}")
    for key, value in log["details"].items():
        print(f"- {key}: {value}")


def main() -> int:

    #
    # Read config files
    #
    args = parse_arguments()
    configfiles = args.configfile or [DEFAULT_CONFIG]
    diffrules: list[DiffRule] = []
    for configfile in configfiles:
        if args.verbose:
            print(f"# Reading config file '{configfile}'")
        try:
            diffrules.extend(load_diff_rules(configfile))
        except Exception as err:
            print("Could not read config file '{configfile}': {err}")
            return ExitCode.FAILURE

    #
    # Parse tagged files
    #
    if args.verbose:
        print("# Reading tagged file with expected results '{args.expected}'")
    with open(args.expected, "r") as fp:
        expected = TaggedCollection(TaggedDataParser(fp).entries)
    if args.verbose:
        print("# Reading tagged file with obtained results {args.obtained}")
    with open(args.obtained, "r") as fp:
        obtained = TaggedCollection(TaggedDataParser(fp).entries)

    #
    # Check entries on difference
    #
    for diffrule in diffrules:
        if args.verbose:
            print(f"# Applying rule: {diffrule.pattern}")

        expected_entries = expected.get_matching_entries(diffrule.regex)
        for expentry in expected_entries:
            name = expentry.name
            entrylog = {
                "checker": diffrule.diffchecker.NAME,
                "name": name,
                "status": TestStatus.UNKNOWN,
                "details": {}
            }
            obtentry = obtained.get_entry(name)

            if not diffrule.keep:
                expected.del_entry(name)
                obtained.del_entry(name)

            if obtentry is None:
                entrylog["status"] = TestStatus.SKIPPED
                entrylog["msg"] = f"Not present in obtained data"

            elif not obtentry.is_comparable(expentry):
                entrylog["status"] = TestStatus.FAILED
                entrylog["msg"] = f"Mismatching data"

            else:
                try:
                    passed, details = diffrule.diffchecker.compare(expentry, obtentry)
                except Exception as err:
                    entrylog["msg"] = f"Error occured when building difference ({err})"
                else:
                    entrylog["status"] = TestStatus.OK if passed else TestStatus.FAILED
                    entrylog["details"] = details
            print_entry_log(entrylog)

    return ExitCode.SUCCESS


if __name__ == "__main__":
    sys.exit(main())
