!--------------------------------------------------------------------------------------------------!
!  DFTB+: general package for performing fast atomistic simulations                                !
!  Copyright (C) 2006 - 2025  DFTB+ developers group                                               !
!                                                                                                  !
!  See the LICENSE file for terms of usage and distribution.                                       !
!--------------------------------------------------------------------------------------------------!

#:include "fortuno_serial.fypp"
#:include 'common.fypp'

!> Some simple regressions tests checking whether all dftbp_wavegrid molorb implementations 
!! (direct STO/LUT, CPU/GPU) return the same results.
!! Reference values generated by direct STO evaluation on CPU and checked against original, serial waveplot implementation.
module test_wavegrid_simple
  use fortuno_serial, only : is_close, serial_case_base, suite => serial_suite_item, test_item,&
      & test_list
  use dftbp_wavegrid, only : getAtomicDensities, getTotalChrg, getValue, TMolecularOrbital
  use test_wavegrid_initmolorb, only : initMolorbH2O, initMolorbHchain
  use dftbp_common_accuracy, only : dp
  use dftbp_math_simplealgebra, only : determinant33
  $:FORTUNO_SERIAL_IMPORTS()
  implicit none

  private
  public :: tests
  
  !> Bundle index and expected value in real output array
  type :: TSpotCheckReal
    integer :: idx(4)
    real(dp) :: expected
  end type TSpotCheckReal

  !> Bundle index and expected value in complex output array
  type :: TSpotCheckComplex
    integer :: idx(4)
    complex(dp) :: expected
  end type TSpotCheckComplex

  
  !> Launch config for molorb tests
  type :: TLaunchConfig
    logical :: useRadialLut = .false.
    logical :: useGPU = .false. 
  end type

  !> All 3 combinations of CPU LUT/Direct abd GPU LUT.
  #:set configCount = 3 if WITH_CUDA else 2
  type(TLaunchConfig), parameter :: launchConfigs(${configCount}$) = [ &
    #:if WITH_CUDA
      TLaunchConfig(.true.,  .true.), & ! LUT GPU
    #:endif
      TLaunchConfig(.false., .false.), & ! Direct CPU
      TLaunchConfig(.true.,  .false.) & ! LUT CPU
  ]


  type, extends(serial_case_base), abstract :: TConfiguredTest
    type(TLaunchConfig) :: config
  end type TConfiguredTest

  !! Subclasses for each test case
  type, extends(TConfiguredTest) :: TConfiguredTest_real_totChrg
  contains
    procedure :: run => TConfiguredTest_real_totChrg_run
  end type TConfiguredTest_real_totChrg

  type, extends(TConfiguredTest) :: TConfiguredTest_real_atomDens
  contains
    procedure :: run => TConfiguredTest_real_atomDens_run
  end type TConfiguredTest_real_atomDens

  type, extends(TConfiguredTest) :: TConfiguredTest_real_allStates
  contains
    procedure :: run => TConfiguredTest_real_allStates_run
  end type TConfiguredTest_real_allStates

  type, extends(TConfiguredTest) :: TConfiguredTest_complex_totChrg
  contains
    procedure :: run => TConfiguredTest_complex_totChrg_run
  end type TConfiguredTest_complex_totChrg

  type, extends(TConfiguredTest) :: TConfiguredTest_complex_allStates
  contains
    procedure :: run => TConfiguredTest_complex_allStates_run
  end type TConfiguredTest_complex_allStates




  !> Allow 0.1% relative error (LUT interpolation etc.)
  real(dp), parameter :: rtol = 1.0e-3_dp
  !> Real Eigenvectors for H2O molecule
  real(dp), parameter :: eigVecsReal(6,4) = reshape([ &
       0.93075335285360816_dp,       5.4749851762277632E-003_dp,   6.5189438567696949E-019_dp,  0.0000000000000000_dp,       &
      -0.11131233240146322_dp,      -0.11131233240146322_dp,      -0.27821574567737223_dp,     -0.73551457100773243_dp,      &
      -7.8726661848432967E-018_dp,   0.0000000000000000_dp,      -0.33117590117481399_dp,      -0.33117590117481405_dp,      &
       2.7154435594648282E-018_dp,  -9.9931138111063277E-018_dp,  0.73160204739108692_dp,       1.1102230246251565E-016_dp,  &
       0.39813631802212995_dp,      -0.39813631802212995_dp,      3.7150709608707145E-033_dp,  -8.1237292785459783E-033_dp,  &
       9.7504438592516575E-017_dp,   1.0000000000000000_dp,      -6.6858833593547624E-017_dp,   6.6858833593547636E-017_dp], &
       & [6,4])
  !> Atomic density occupations for H2O per Orb(distributed evenly over same angMom)
  real(dp), parameter :: occupationAtomDens(6,1) = reshape([2.0_dp, 4.0_dp / 3.0_dp, 4.0_dp / 3.0_dp, 4.0_dp / 3.0_dp, 1.0_dp,&
  1.0_dp], [6,1])
  !> Occupation per state as computed by DFTB+
  real(dp), parameter :: occupationVecH2O(4) = [2.0_dp, 2.0_dp, 2.0_dp, 2.0_dp]

  !> Complex eigenvectors for H chain
  complex(dp), parameter :: eigVecsComplex(1,4) = reshape([ &
       (0.62981679983963734_dp, 0.0_dp), (0.68885855972586518_dp, 0.0_dp), &
       (0.81991408755170758_dp, 0.0_dp), (1.0501565770378785_dp, 0.0_dp) &
       ], [1,4])
  !> Occupation per state as computed by DFTB+
  real(dp), parameter :: occupationVecHchain(4) = [0.25_dp, 0.25_dp, 0.25_dp, 0.25_dp]
  !> k-points for H chain
  real(dp), parameter :: kPointsHchain(3,8) = reshape([ &
       0.0_dp, 0.0_dp, 0.19634954084936207_dp, 0.0_dp, 0.0_dp, 0.58904862254808621_dp, 0.0_dp, 0.0_dp, &
       0.98174770424681035_dp, 0.0_dp, 0.0_dp, 1.3744467859455345_dp, 0.0_dp, 0.0_dp, 1.7671458676442586_dp, &
       0.0_dp, 0.0_dp, 2.1598449493429825_dp, 0.0_dp, 0.0_dp, 2.5525440310417071_dp, 0.0_dp, 0.0_dp, &
       2.9452431127404308_dp], [3,8])
  integer, parameter :: kIndexesHchain(4) = [1, 2, 3, 4]


contains
  ! ### Real (H2O) Test cases ###

  !> Real (H2O) : Total charge calculation
  subroutine TConfiguredTest_real_totChrg_run(this)
    class(TConfiguredTest_real_totChrg), intent(in) :: this
    type(TMolecularOrbital) :: molorb
    real(dp), allocatable :: valueOnGrid(:,:,:,:)
    real(dp) :: gridVol, actual, expected
    integer :: i, idx(4)
    type(TSpotCheckReal) :: spotChecks(6) = [ &
        TSpotCheckReal([50, 31, 50, 1], 1.009617874235818_dp), & ! O at (0,-1.89,0)
        TSpotCheckReal([1, 1, 1, 1], 0.0_dp), & ! Grid bounds
        TSpotCheckReal([100, 100, 100, 1], 0.0_dp), & ! Grid bounds
        TSpotCheckReal([51, 51, 51, 1], 0.6092945991929660E-01_dp), & ! Grid Center
        TSpotCheckReal([50, 40, 51, 1], 0.5131651070097035_dp), & ! Symmetry: molecule in YZ plane
        TSpotCheckReal([52, 40, 51, 1], 0.5131651070097035_dp) & ! Symmetric: molecule in YZ plane
    ]

    call initMolorbH2O(molorb, this%config%useRadialLut)
    gridVol = abs(determinant33(molorb%system%gridVecs))

    ! Main calculation
    allocate(valueOnGrid(100,100,100,1))
    call getTotalChrg(molorb, eigVecsReal, valueOnGrid, occupationVecH2O, this%config%useGPU)

    ! CheckReal sum over grid
    expected = 8.0040445629655839_dp
    actual = sum(valueOnGrid) * gridVol
    @:CHECK(is_close(actual, expected, rtol=rtol))

    ! Spot check values
    do i = 1, size(spotChecks)
      idx = spotChecks(i)%idx
      expected = spotChecks(i)%expected
      actual = valueOnGrid(idx(1), idx(2), idx(3), idx(4))
      @:CHECK(is_close(actual, expected, rtol=rtol))
    end do
  end subroutine TConfiguredTest_real_totChrg_run

  !> Real (H2O) : Atomic densities calculation
  subroutine TConfiguredTest_real_atomDens_run(this)
    class(TConfiguredTest_real_atomDens), intent(in) :: this
    type(TMolecularOrbital) :: molorb
    real(dp), allocatable :: valueOnGrid(:,:,:,:)
    real(dp) :: gridVol, actual, expected
    integer :: i, idx(4)
    type(TSpotCheckReal) :: spotChecks(6) = [ &
        TSpotCheckReal([ 50,  31,  50, 1], 1.238914874283217_dp), & ! O at (0,-1.89,0)
        TSpotCheckReal([  1,   1,   1, 1], 0.0_dp), & ! Grid bounds
        TSpotCheckReal([100, 100, 100, 1], 0.0_dp), & ! Grid bounds
        TSpotCheckReal([ 51,  51,  51, 1], 0.5835226183394406E-01_dp), & ! Grid Center
        TSpotCheckReal([ 50,  40,  51, 1], 0.6846187059267557_dp), & ! Symmetry: molecule in YZ plane
        TSpotCheckReal([ 52,  40,  51, 1], 0.6846187059267551_dp)  & ! Symmetric: molecule in YZ plane
    ]

    call initMolorbH2O(molorb, this%config%useRadialLut)
    gridVol = abs(determinant33(molorb%system%gridVecs))

    ! Main calculation
    allocate(valueOnGrid(100,100,100,1))
    call getAtomicDensities(molorb, occupationAtomDens, valueOnGrid, this%config%useGPU)

    ! CheckReal sum over grid
    expected = 8.004352_dp
    actual = sum(valueOnGrid) * gridVol
    @:CHECK(is_close(actual, expected, rtol=rtol))

    ! Spot check values
    do i = 1, size(spotChecks)
      idx = spotChecks(i)%idx
      expected = spotChecks(i)%expected
      actual = valueOnGrid(idx(1), idx(2), idx(3), idx(4))
      @:CHECK(is_close(actual, expected, rtol=rtol))
    end do
  end subroutine TConfiguredTest_real_atomDens_run

  !> Real (H2O) : All states calculation
  subroutine TConfiguredTest_real_allStates_run(this)
    class(TConfiguredTest_real_allStates), intent(in) :: this
    type(TMolecularOrbital) :: molorb
    real(dp), allocatable :: valueOnGrid(:,:,:,:)
    real(dp) :: gridVol, actual, expected
    integer :: i, idx(4)
    ! 2 randomly chosen points per state.
    ! [random.randrange(1,101) for _ in "123"] 
    type(TSpotCheckReal) :: spotChecks(8) = [ &
        TSpotCheckReal([31, 82, 52, 1], -0.4237591897694508E-03_dp), & 
        TSpotCheckReal([93, 19, 63, 1], -0.8172698875983751E-04_dp), & 
        TSpotCheckReal([80, 82, 83, 2], -0.1274610827226662E-03_dp), & 
        TSpotCheckReal([32, 28, 73, 2], -0.2681614272853517E-03_dp), & 
        TSpotCheckReal([68, 17, 95, 3],  0.1151590378991745E-03),    & 
        TSpotCheckReal([39, 88, 09, 3], -0.9397073043782955E-04_dp), & 
        TSpotCheckReal([09, 78, 23, 4],  0.4296017603685945E-20_dp), & 
        TSpotCheckReal([47, 59, 06, 4], -0.9990029155728657E-06_dp)  & 
    ]

    call initMolorbH2O(molorb, this%config%useRadialLut)
    gridVol = abs(determinant33(molorb%system%gridVecs))
    
    ! Main calculation
    allocate(valueOnGrid(100,100,100,4))
    call getValue(molorb, eigVecsReal, valueOnGrid, this%config%useGPU)

    ! CheckReal sum over grid
    expected = -11.36846731051559_dp
    actual = sum(valueOnGrid) * gridVol
    @:CHECK(is_close(actual, expected, rtol=rtol))

    ! Spot check values
    do i = 1, size(spotChecks)
      idx = spotChecks(i)%idx
      expected = spotChecks(i)%expected
      actual = valueOnGrid(idx(1), idx(2), idx(3), idx(4))
      @:CHECK(is_close(actual, expected, rtol=rtol))
    end do
  end subroutine TConfiguredTest_real_allStates_run


  ! ### Complex (H-chain) Test cases ###
  !> Complex (H-chain) : Total charge calculation
  subroutine TConfiguredTest_complex_totChrg_run(this)
    class(TConfiguredTest_complex_totChrg), intent(in) :: this
    type(TMolecularOrbital) :: molorb
    real(dp), allocatable :: valueOnGrid(:,:,:,:)
    real(dp) :: gridVol, actual, expected
    integer :: i, idx(4)
    ! Randomly chosen points.
    ! [random.randrange(1,101) for _ in "123"] 
    type(TSpotCheckReal) :: spotChecks(6) = [ &
        TSpotCheckReal([31, 82, 52, 1], 0.1854186607568482E-04_dp), & 
        TSpotCheckReal([93, 19, 63, 1], 0.4554475419034117E-08_dp), & 
        TSpotCheckReal([80, 82, 83, 1], 0.1400485004792566E-05_dp), & 
        TSpotCheckReal([32, 28, 73, 1], 0.2821278119060284E-03_dp), & 
        TSpotCheckReal([68, 17, 95, 1], 0.1144197239608134E-04_dp), & 
        TSpotCheckReal([39, 88, 09, 1], 0.7705316328219835E-05_dp) & 
    ]

    call initMolorbHchain(molorb, this%config%useRadialLut)
    gridVol = abs(determinant33(molorb%system%gridVecs))

    ! Main calculation
    allocate(valueOnGrid(100,100,100,1))
    call getTotalChrg(molorb, eigVecsComplex, kPointsHchain, kIndexesHchain, valueOnGrid, occupationVecHchain, this%config%useGPU)

    ! CheckReal sum over grid
    expected = 6.637263751554149_dp
    actual = sum(valueOnGrid) * gridVol
    @:CHECK(is_close(actual, expected, rtol=rtol))

    ! Spot check values
    do i = 1, size(spotChecks)
      idx = spotChecks(i)%idx
      expected = spotChecks(i)%expected
      actual = valueOnGrid(idx(1), idx(2), idx(3), idx(4))
      @:CHECK(is_close(actual, expected, rtol=rtol))
    end do
  end subroutine TConfiguredTest_complex_totChrg_run


  !> Complex (H-chain) : All states calculation
  subroutine TConfiguredTest_complex_allStates_run(this)
    class(TConfiguredTest_complex_allStates), intent(in) :: this
    type(TMolecularOrbital) :: molorb
    complex(dp), allocatable :: valueOnGrid(:,:,:,:)
    real(dp) :: gridVol
    complex(dp) :: actual, expected
    integer :: i, idx(4)
    ! 2 randomly chosen points per state.
    ! [random.randrange(1,101) for _ in "123"] 
    type(TSpotCheckComplex) :: spotChecks(8) = [ &
        TSpotCheckComplex([31, 82, 52, 1], (0.4618562431412820E-02_dp, 0.5805855442516971E-04_dp)), &
        TSpotCheckComplex([93, 19, 63, 1], (0.8330079947653005E-04_dp, 0.8753533677015034E-05_dp)), &
        TSpotCheckComplex([80, 82, 83, 2], (0.1222651639518469E-02_dp, 0.8048672887188940E-04_dp)), &
        TSpotCheckComplex([32, 28, 73, 2], (0.1690763857502260E-01_dp, 0.4646391064170055E-02_dp)), &
        TSpotCheckComplex([68, 17, 95, 3], (0.2091620118572572E-02_dp, 0.2596145058129883E-02_dp)), &
        TSpotCheckComplex([39, 88, 09, 3], (0.2671119431633243E-02_dp, 0.5944536018057613E-03_dp)), &
        TSpotCheckComplex([09, 78, 23, 4], (0.8227151295698438E-04_dp, 0.1991128564447004E-04_dp)), &
        TSpotCheckComplex([47, 59, 06, 4], (0.2967129806717818_dp,     0.8175874030009455E-02_dp))  &
    ]

    call initMolorbHchain(molorb, this%config%useRadialLut)
    gridVol = abs(determinant33(molorb%system%gridVecs))

    ! Main calculation
    allocate(valueOnGrid(100,100,100,4))
    call getValue(molorb, eigVecsComplex, kPointsHchain, kIndexesHchain, valueOnGrid, this%config%useGPU)

    ! CheckReal sum over grid
    expected = (113.9831688331955_dp, 45.30115350686194_dp)
    actual = sum(valueOnGrid) * gridVol
    @:CHECK(is_close(real(actual), real(expected), rtol=rtol))
    @:CHECK(is_close(aimag(actual), aimag(expected), rtol=rtol))

    ! Spot check values
    do i = 1, size(spotChecks)
      idx = spotChecks(i)%idx
      expected = spotChecks(i)%expected
      actual = valueOnGrid(idx(1), idx(2), idx(3), idx(4))

      @:CHECK(is_close(real(actual), real(expected), rtol=rtol))
      @:CHECK(is_close(aimag(actual), aimag(expected), rtol=rtol))
    end do
  end subroutine TConfiguredTest_complex_allStates_run



  !> Factory function to create correctly named test cases 
  function makeTest(prefix, launchConfig) result(testObj)
    character(*), intent(in) :: prefix
    type(TLaunchConfig), intent(in) :: launchConfig
    type(test_item) :: testObj

    character(:), allocatable :: name

    name = trim(prefix)
    if (launchConfig%useRadialLut) then
      name = trim(name) // "_LUT"
    else
      name = trim(name) // "_Direct"
    end if
    if (launchConfig%useGPU) then
      name = trim(name) // "_GPU"
    else
      name = trim(name) // "_CPU"
    end if

    select case (trim(prefix))
    case ("real_totChrg")
      testObj = test_item(TConfiguredTest_real_totChrg(name=name, config=launchConfig))
    case ("real_atomDens")
      testObj = test_item(TConfiguredTest_real_atomDens(name=name, config=launchConfig))
    case ("real_allStates")
      testObj = test_item(TConfiguredTest_real_allStates(name=name, config=launchConfig))
    case ("complex_totChrg")
      testObj = test_item(TConfiguredTest_complex_totChrg(name=name, config=launchConfig))
    case ("complex_allStates")
      testObj = test_item(TConfiguredTest_complex_allStates(name=name, config=launchConfig))
    case default
      print *, "Unknown test case prefix: ", trim(prefix)
      @:ASSERT(.false.)
    end select


  end function makeTest


  !> Register test cases with Fortuno
  function tests()
    type(test_list) :: tests

    integer :: i

    tests = test_list([&
        suite("RealTotChrg", test_list([&
            (makeTest("real_totChrg", launchConfigs(i)), i = 1, size(launchConfigs)) &
        ])),&
        suite("RealAtomDens", test_list([&
            (makeTest("real_atomDens", launchConfigs(i)), i = 1, size(launchConfigs)) &
        ])),&
        suite("RealAllStates", test_list([&
            (makeTest("real_allStates", launchConfigs(i)), i = 1, size(launchConfigs)) &
        ])),&
        suite("ComplexTotChrg", test_list([&
            (makeTest("complex_totChrg", launchConfigs(i)), i = 1, size(launchConfigs)) &
        ])),&
        suite("ComplexAllStates", test_list([&
            (makeTest("complex_allStates", launchConfigs(i)), i = 1, size(launchConfigs)) &
        ]))&
    ])

    $:STOP_ON_MISSING_TEST_ITEMS()

  end function tests



end module test_wavegrid_simple
