""" Calculate reference values using scipy to check the Fortran spharmonics implementation """
import random
import numpy as np
from pathlib import Path
import scipy


MAX_L = 4
POINTS_PER_LM = 10
TARGET_FILE = Path("refharmonics.f90")

# Vary the magnitude of x,y,z to ensure normalization works
RADIAL_RANGE = (0.001, 1000.0)
RANDOM_SEED = 42
# Limited by Fortrans max line length.
# Either break lines or consider exponential notation
DECIMAL_PLACES = 18

random.seed(RANDOM_SEED)

try:
    from scipy.special import sph_harm_y
except ImportError:
    # Older scipy versions
    from scipy.special import sph_harm

    def sph_harm_y(l, m, colat, lon):
        return sph_harm(m, l, lon, colat)


def real_sph_harm(l, m, theta, phi):
    """theta is colatitude from 0 to pi, phi is longitude from 0 to 2pi"""
    if m > 0:
        return np.sqrt(2) * (-1) ** m * np.real(sph_harm_y(l, m, theta, phi))
    elif m < 0:
        return np.sqrt(2) * (-1) ** m * np.imag(sph_harm_y(l, abs(m), theta, phi))
    else:  # m == 0
        return sph_harm_y(l, 0, theta, phi).real


def print_point(l, m, theta, phi):
    ylm = real_sph_harm(l, m, theta, phi)
    radial = random.uniform(*RADIAL_RANGE)
    x = np.sin(theta) * np.cos(phi) * radial
    y = np.sin(theta) * np.sin(phi) * radial
    z = np.cos(theta) * radial
    p = DECIMAL_PLACES
    line = f"    spotCheck({l}, {m}, {x:.{p}f}_dp, {y:.{p}f}_dp, {z:.{p}f}_dp, {ylm:.{p}f}_dp), &\n"
    return line


def main():
    content = []
    modulename = "test_wavegrid_spharmonics_ref"
    content.append(
        f"""! This file was auto-generated by {__file__}
! Do not edit manually.
! Reference values calculated using scipy version {scipy.__version__}
! Run {__file__} to regenerate.
! Configuration: MAX_L={MAX_L}, POINTS_PER_LM={POINTS_PER_LM}, DECIMAL_PLACES={DECIMAL_PLACES},
!                RADIAL_RANGE={RADIAL_RANGE}, RANDOM_SEED={RANDOM_SEED}

module {modulename}
  use dftbp_common_accuracy, only : dp
  implicit none

  type :: spotCheck
    integer :: l, m
    real(dp) :: x, y, z
    real(dp) :: expected
  end type spotCheck
    
  ! Least significant digit in the below reference values
  real(dp), parameter :: atol = 1.0e-{DECIMAL_PLACES}_dp

  """
    )

    for l in range(MAX_L + 1):
        numChecks = (2 * l + 1) * POINTS_PER_LM
        content.append(f"  ! l = {l} \n")
        content.append(
            f"  type(spotCheck), parameter :: spotChecks_l{l}({numChecks}) = [ &\n"
        )
        for m in range(-l, l + 1):
            content.append(f"    ! m = {m} \n")
            for _ in range(POINTS_PER_LM):
                theta = np.arccos(random.uniform(-1, 1))
                phi = random.uniform(0, 2 * np.pi)
                line = print_point(l, m, theta, phi)
                content.append(line)
        # remove trailing comma from last entry
        content[-1] = content[-1].replace(", &\n", " &\n")
        content.append("  ]\n\n")
    content.append(f"end module {modulename}\n")

    with open(TARGET_FILE, "w") as f:
        f.writelines(content)
    maxlinelen = len(max("".join(content).splitlines(), key=len))
    print(f"Wrote {TARGET_FILE}. Max line length: {maxlinelen}")
    


if __name__ == "__main__":
    main()
