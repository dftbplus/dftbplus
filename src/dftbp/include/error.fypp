#!-------------------------------------------------------------------------------------------------!
#!  DFTB+: general package for performing fast atomistic simulations                               !
#!  Copyright (C) 2006 - 2022  DFTB+ developers group                                              !
#!                                                                                                 !
#!  See the LICENSE file for terms of usage and distribution.                                      !
#!-------------------------------------------------------------------------------------------------!
#!
#:mute
#:if not defined("_ERROR_FYPP_")
#:set _ERROR_FYPP_

#:include 'common.fypp'


#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#! Error string handling wrappers for returns from routines (with integer as error flag)
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


#! Macro to return an error flag if return variable available or throw
#! an error and shut down otherwise
#:def ERROR_HANDLING(errVar, errNumber, msg)
  block
    use dftbp_common_accuracy, only : lc
    use dftbp_io_message
    !> Error handling string
    character(lc) :: stringTmp

    write(stringTmp,"(A)")${msg}$
    if (present(${errVar}$)) then
      ${errVar}$ = ${errNumber}$
      call warning(stringTmp)
      return
    else
      call error(stringTmp)
    end if
  end block
#:enddef ERROR_HANDLING


#! Macro to return an error flag if return variable available or throw
#! an error and shut down otherwise
#:def FORMATTED_ERROR_HANDLING(errVar, errNumber, formating, *variables)
  block
    use dftbp_common_accuracy, only : lc
    use dftbp_io_message
    !> Error handling string
    character(lc) :: stringTmp

    write(stringTmp,${formating}$) ${ ",".join(variables) }$
    if (present(${errVar}$)) then
      ${errVar}$ = ${errNumber}$
      call warning(stringTmp)
      return
    else
      call error(stringTmp)
    end if
  end block
#:enddef FORMATTED_ERROR_HANDLING


#! Propagation of error handling, for now it just returns when in error
#:def HANDLE_ERROR(errVar)
  if (present(${errVar}$)) then
    if (${errVar}$ /= 0) then
      return
    end if
  end if
#:enddef


#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#! Exception like error handling
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


#! Raises (creates and propagates) an exception
#:def RAISE_EXCEPTION(exc, code, message)
  block
    use dftbp_common_exception, only : TException_create
    call TException_create(${exc}$, ${code}$, ${message}$)
    #:block DEBUG_CODE
      call ${exc}$%addPropagationInfo("${_FILE_}$", ${_LINE_}$)
    #:endblock
    return
  end block
#:enddef


#! Raises (creates and propagates) an exception with a formatted error message
#:def RAISE_FORMATTED_EXCEPTION(exc, code, format, *messageVars)
  block
    character(1000) :: message
    write(message, ${format}$) ${",".join(messageVars)}$
    @:RAISE_EXCEPTION(${exc}$, ${code}$, trim(message))
  end block
#:enddef


#! Propagates an exception upwards
#:def PROPAGATE_EXCEPTION(exc)
  if (allocated(${exc}$)) then
    #:block DEBUG_CODE
      call ${exc}$%addPropagationInfo("${_FILE_}$", ${_LINE_}$)
    #:endblock
    return
  end if
#:enddef


#! Deactivates exception, executes error handling code and deallocates error
#:def CATCH_EXCEPTION(exc, excHandler)
  if (allocated(${exc}$)) then
    @:DEACTIVATE_EXCEPTION(${exc}$)
    block
      $:excHandler
    end block
    deallocate(${exc}$)
  end if
#:enddef


#! Deactivates exception
#:def DEACTIVATE_EXCEPTION(exc)
  if (allocated(${exc}$)) call ${exc}$%deactivate()
#:enddef


#:endif
#:endmute
