!--------------------------------------------------------------------------------------------------!
!  DFTB+: general package for performing fast atomistic simulations                                !
!  Copyright (C) 2006 - 2023  DFTB+ developers group                                               !
!                                                                                                  !
!  See the LICENSE file for terms of usage and distribution.                                       !
!--------------------------------------------------------------------------------------------------!

#:include 'common.fypp'
#:include 'error.fypp'

!> The main routines for DFTB+
module dftbp_dftbplus_main
  use dftbp_common_accuracy, only : dp, elecTolMax, tolSameDist
  use dftbp_common_constants, only : pi
  use dftbp_common_environment, only : TEnvironment, globalTimers
  use dftbp_common_file, only : TFileDescr, openFile, closeFile
  use dftbp_common_globalenv, only : stdOut, withMpi
  use dftbp_common_hamiltoniantypes, only : hamiltonianTypes
  use dftbp_common_status, only : TStatus
  use dftbp_derivs_numderivs2, only : TNumderivs, next, getHessianMatrix, dipoleAdd, polAdd
  use dftbp_derivs_perturb, only : TResponse
  use dftbp_dftb_blockpothelper, only : appendBlockReduced
  use dftbp_dftb_boundarycond, only : TBoundaryConditions
  use dftbp_dftb_densitymatrix, only : TDensityMatrix, transformDualSpaceToBvKRealSpace
  use dftbp_dftb_determinants, only : TDftbDeterminants, TDftbDeterminants_init, determinants
  use dftbp_dftb_dftbplusu, only : TDftbU
  use dftbp_dftb_dispersions, only : TDispersionIface
  use dftbp_dftb_energytypes, only : TEnergies
  use dftbp_dftb_etemp, only : electronFill, Efilling
  use dftbp_dftb_extfields, only : addUpExternalField
  use dftbp_dftb_forces, only : derivative_shift
  use dftbp_dftb_getenergies, only : calcEnergies, calcDispersionEnergy, sumEnergies
  use dftbp_dftb_halogenx, only : THalogenX
  use dftbp_dftb_hamiltonian, only : resetInternalPotentials, addChargePotentials,&
      & getSccHamiltonian, mergeExternalPotentials, resetExternalPotentials,&
      & addBlockChargePotentials, constrainSccHamiltonian
  use dftbp_dftb_hybridxc, only : THybridXcFunc, hybridXcAlgo
  use dftbp_dftb_nonscc, only : TNonSccDiff, buildS, buildH0
  use dftbp_dftb_onsitecorrection, only : Onsblock_expand, onsBlock_reduce, addOnsShift
  use dftbp_dftb_orbitalequiv, only : OrbitalEquiv_expand, orbitalEquiv_reduce
  use dftbp_dftb_periodic, only : TNeighbourList, TSymNeighbourList, updateNeighbourListAndSpecies,&
      & cart2frac, frac2cart, getNrOfNeighboursForAll, getCellTranslations
  use dftbp_dftb_pmlocalisation, only : TPipekMezey
  use dftbp_dftb_populations, only : getChargePerShell, denseSubtractDensityOfAtomsReal,&
      & denseSubtractDensityOfAtomsCmplxPeriodic, denseSubtractDensityOfAtomsCmplxPeriodicGlobal,&
      & denseSubtractDensityOfAtomsNospinRealNonperiodicReks,&
      & denseSubtractDensityOfAtomsSpinRealNonperiodicReks, mulliken, denseMullikenReal,&
      & denseBlockMulliken, skewMulliken, getOnsitePopulation, getAtomicMultipolePopulation
  use dftbp_dftb_potentials, only : TPotentials
  use dftbp_dftb_repulsive_repulsive, only : TRepulsive
  use dftbp_dftb_scc, only : TScc
  use dftbp_dftb_shift, only : addShift, addAtomicMultipoleShift
  use dftbp_dftb_slakocont, only : TSlakoCont
  use dftbp_dftb_sparse2dense, only : unpackHPauli, unpackHS, packHS, packHS, unpackHelicalHS,&
      & packerho, packHSPauli, packHelicalHS, packHSPauliImag, iPackHS, unpackSPauli,&
      & getSparseDescriptor
  use dftbp_dftb_spin, only : ud2qm, qm2ud
  use dftbp_dftb_spinorbit, only : addOnsiteSpinOrbitHam, getOnsiteSpinOrbitEnergy
  use dftbp_dftb_stress, only : getkineticstress, getBlockStress, getBlockiStress, getNonSCCStress
  use dftbp_dftb_thirdorder, only : TThirdOrder
  use dftbp_dftbplus_apicallback, only : TAPICallback
  use dftbp_dftbplus_eigenvects, only : diagDenseMtx
  use dftbp_dftbplus_elstattypes, only : elstatTypes
  use dftbp_dftbplus_forcetypes, only : forceTypes
  use dftbp_dftbplus_initprogram, only : TDftbPlusMain, TCutoffs, TNegfInt
  use dftbp_dftbplus_inputdata, only : TNEGFInfo
  use dftbp_dftbplus_mainio, only : writeRealEigvecs, writeCplxEigVecs, readEigenVecs,&
      & printMaxForce, printMaxLatticeForce, printReksSccHeader, printSccHeader, printMdInfo,&
      & writeMdOut2, writeDetailedOut5, writeMdOut1, openOutputFile, printReksSccInfo,&
      & writeReksDetailedOut1, writebandout, writehsandstop, printSccInfo, printBlankLine,&
      & writeCharges, writeDetailedOut1, writeDetailedOut2, writeDetailedOut3,&
      & writeEigenVectors, writeProjectedEigenvectors, writeCurrentGeometry, writeDetailedOut4,&
      & writeEsp, printGeostepInfo, writeDetailedOut2dets, printEnergies, printVolume,&
      & printPressureAndFreeEnergy, writeDetailedOut6, writeDetailedOut7,&
      & writeFinalDriverstatus, writeHessianout, writeBornChargesOut, writeBornDerivs,&
      & writeAutotestTag, writeResultsTag, writeDetailedXml, writeCosmoFile, printForceNorm,&
      & printLatticeForceNorm, writeDerivBandOut, writeDetailedOut8, writeDetailedOut9,&
      & writeDetailedOut10, printElecConstrHeader, printElecConstrInfo
  use dftbp_dftbplus_outputfiles, only : autotestTag, bandOut, fCharges, fShifts, fStopScc, mdOut,&
      & userOut, fStopDriver, hessianOut, bornChargesOut, bornDerivativesOut, resultsTag,&
      & derivEBandOut
  use dftbp_dftbplus_qdepextpotproxy, only : TQDepExtPotProxy
  use dftbp_dftbplus_transportio, only : readShifts, writeShifts, writeContactShifts
  use dftbp_elecsolvers_elecsolvers, only : TElectronicSolver
  use dftbp_elecsolvers_elecsolvertypes, only : electronicSolverTypes
  use dftbp_extlibs_plumed, only : TPlumedCalc, TPlumedCalc_final
  use dftbp_extlibs_tblite, only : TTBLite
  use dftbp_geoopt_geoopt, only : TGeoOpt, next, reset
  use dftbp_io_message, only : error, warning
  use dftbp_io_taggedoutput, only : TTaggedWriter
  use dftbp_math_angmomentum, only : getLOnsite, getLDual
  use dftbp_math_blasroutines, only : hemm, symm
  use dftbp_math_lapackroutines, only : hermatinv, matinv, symmatinv
  use dftbp_math_matrixops, only : adjointLowerTriangle
  use dftbp_math_simplealgebra, only : determinant33, derivDeterminant33
  use dftbp_md_mdcommon, only : TMdCommon, evalKE, evalKT
  use dftbp_md_mdintegrator, only : TMdIntegrator, next, rescale
  use dftbp_md_tempprofile, only : TTempProfile
  use dftbp_md_xlbomd, only : TXLBOMD
  use dftbp_mixer_mixer, only : TMixerReal, TMixerCmplx, TMixerReal_reset, TMixerCmplx_reset,&
      & TMixerReal_mix, TMixerCmplx_mix, TMixerReal_getInverseJacobian
  use dftbp_reks_reks, only : TReksCalc, guessneweigvecs, optimizeFONs, calcweights, activeorbswap,&
      & getfilling, calcsareksenergy, printsareksenergy, qm2udl, printreksmicrostates, qmexpandl,&
      & ud2qml, constructmicrostates, checkgammapoint, getfockanddiag, printrekssainfo,&
      & getstateinteraction, getreksenproperties, getreksgradients, getreksgradproperties,&
      & getReksStress
  use dftbp_solvation_cm5, only : TChargeModel5
  use dftbp_solvation_fieldscaling, only : TScaleExtEField
  use dftbp_solvation_solvation, only : TSolvation
  use dftbp_timedep_linresp, only : TLinResp, linResp_calcExcitations, LinResp_addGradients
  use dftbp_timedep_linrespgrad, only : conicalIntersectionOptimizer
  use dftbp_timedep_pprpa, only : ppRpaEnergies
  use dftbp_timedep_timeprop, only : runDynamics
  use dftbp_type_commontypes, only : TOrbitals, TParallelKS
  use dftbp_type_densedescr, only : TDenseDescr
  use dftbp_type_integral, only : TIntegral
  use dftbp_type_multipole, only : TMultipole
#:if WITH_SCALAPACK
  use dftbp_dftb_densitymatrix, only : makeDensityMtxRealBlacs, makeDensityMtxCplxBlacs
  use dftbp_dftb_hybridxc, only : getFullFromDistributed, scatterFullToDistributed
  use dftbp_dftb_populations, only : denseMullikenRealBlacs,&
      & denseSubtractDensityOfAtomsRealNonperiodicBlacs,&
      & denseSubtractDensityOfAtomsRealPeriodicBlacs
  use dftbp_dftb_sparse2dense, only : packRhoRealBlacs, packRhoCplxBlacs, packRhoPauliBlacs,&
      & packRhoHelicalRealBlacs, packRhoHelicalCplxBlacs, packERhoPauliBlacs, unpackHSRealBlacs,&
      & unpackHSCplxBlacs, unpackHPauliBlacs, unpackSPauliBlacs, unpackHSHelicalRealBlacs,&
      & unpackHSHelicalCplxBlacs
  use dftbp_dftbplus_eigenvects, only : diagDenseMtxBlacs
  use dftbp_extlibs_mpifx, only : MPI_SUM, MPI_MAX, mpifx_allreduceip, mpifx_bcast
  use dftbp_extlibs_scalapackfx, only : pblasfx_phemm, pblasfx_psymm, pblasfx_ptran,&
      & pblasfx_ptranc, blacsfx_gemr2d
  use dftbp_math_scalafxext, only : phermatinv, psymmatinv
#:endif
#:if WITH_SOCKETS
  use dftbp_dftbplus_mainio, only : receiveGeometryFromSocket
  use dftbp_io_ipisocket, only : IpiSocketComm
#:endif
#:if WITH_TRANSPORT
  use dftbp_dftbplus_initprogram, only : overrideContactCharges
  use dftbp_transport_negfint, only : TNegfInt_final
  use dftbp_transport_negfvars, only : TTransPar
#:endif
  implicit none

  private
  public :: runDftbPlus
  public :: processGeometry

  !> Should further output be appended to detailed.out?
  logical, parameter :: tAppendDetailedOut = .false.


contains

  !> The main DFTB program itself
  subroutine runDftbPlus(this, env)

    !> Global variables
    type(TDftbPlusMain), intent(inout) :: this

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Geometry steps so far
    integer :: iGeoStep

    !> Lattice geometry steps so far
    integer :: iLatGeoStep

    !> Do we have the final geometry?
    logical :: tGeomEnd

    !> Do we take an optimization step on the lattice or the internal coordinates if optimizing both
    !> in a periodic geometry
    logical :: tCoordStep

    !> If scc/geometry driver should be stopped
    logical :: tStopScc, tStopDriver

    !> Locality measure for the wavefunction
    real(dp) :: localisation

    !> Flag to write out geometries (and charge data if scc) when moving atoms about - in the case
    !> of drivers like conjugate gradient/steepest descent the geometries are written anyway
    logical :: tWriteRestart

    !> Lattice vectors returned by the optimizer
    real(dp) :: constrLatDerivs(9)

    !> MD instantaneous thermal energy
    real(dp) :: tempIon

    !> Whether charges should be written
    logical :: tWriteCharges

    !> Should the geometry loop be stopped early
    logical :: tExitGeoOpt

    !> Which state is being calculated in the determinant loop?
    integer :: iDet
    logical :: isUnReduced

    type(TStatus) :: errStatus
    real(dp), pointer :: pDynMatrix(:,:), pDipDerivMatrix(:,:), pPolDerivMatrix(:,:,:)

    call initGeoOptParameters(this%tCoordOpt, this%nGeoSteps, tGeomEnd, tCoordStep, tStopDriver,&
        & iGeoStep, iLatGeoStep)

    ! If the geometry is periodic, need to update lattice information in geometry loop
    this%tLatticeChanged = this%tPeriodic

    ! As first geometry iteration, require updates for coordinates in dependent routines
    this%tCoordsChanged = .true.

    ! Main geometry loop
    geoOpt: do iGeoStep = 0, this%nGeoSteps
      tWriteRestart = env%tGlobalLead .and. needsRestartWriting(this%isGeoOpt .or.&
          & allocated(this%geoOpt), this%tMd, iGeoStep, this%nGeoSteps, this%restartFreq)

      if (.not. this%tRestartNoSC) then
        call printGeoStepInfo(this%tCoordOpt, this%tLatOpt, iLatGeoStep, iGeoStep)
      end if

      ! DFTB Determinant Loop
      ! Will pass though loop once, unless specified in input to perform multiple determinants
      lpDets : do iDet = 1, this%nDets

        this%deltaDftb%iDeterminant = iDet

        call preDetCharges(isUnReduced, iDet, this%nDets, iGeoStep, this%deltaDftb, this%qInput,&
            & this%qDets, this%qBlockIn, this%qBlockDets, this%densityMatrix%deltaRhoIn,&
            & this%deltaRhoDets)
        if (isUnReduced) then
          call reduceCharges(this%orb, this%nIneqOrb, this%iEqOrbitals, this%qInput, this%qInpRed,&
              & this%qBlockIn, this%iEqBlockDftbu, this%qiBlockIn, this%iEqBlockDftbuLS,&
              & this%iEqBlockOnSite, this%iEqBlockOnSiteLS)
        end if

        call processGeometry(this, env, iGeoStep, iLatGeoStep, tWriteRestart, tStopScc,&
            & tExitGeoOpt, errStatus)
        if (errStatus%hasError()) then
          call error(errStatus%message)
        end if

        call postDetCharges(iDet, this%nDets, this%qOutput, this%qDets, this%qBlockDets,&
            & this%qBlockOut, this%deltaRhoDets, this%densityMatrix%deltaRhoOut)

      end do lpDets

      call this%deltaDftb%postProcessDets(this%dftbEnergy, this%qOutput, this%qDets,&
          & this%qBlockOut, this%qBlockDets, this%dipoleMoment, this%totalStress,&
          & this%tripletStress, this%mixedStress, this%derivs, this%tripletderivs, this%mixedderivs)

      if (this%tWriteDetailedOut .and. this%deltaDftb%nDeterminant() > 1) then
        call writeDetailedOut2Dets(this%fdDetailedOut, userOut, tAppendDetailedOut,&
            & this%dftbEnergy, this%electronicSolver, this%deltaDftb, this%q0, this%orb,&
            & this%qOutput, this%qDets, this%qBlockDets, this%species, this%iAtInCentralRegion,&
            & this%tPrintMulliken, this%cm5Cont)
      end if

      if (.not.this%tRestartNoSC .and.&
          & this%electronicSolver%iSolver /= electronicSolverTypes%OnlyTransport) then
        call printEnergies(this%dftbEnergy, this%electronicSolver, this%deltaDftb)
      end if

      if (this%tStress) then

        call printVolume(this%cellVol)

        ! MD case includes the atomic kinetic energy contribution, so print that later
        if (.not. (this%tMD .or. this%tHelical)) then
          call printPressureAndFreeEnergy(this%extPressure, this%intPressure,&
              & this%dftbEnergy(this%deltaDftb%iDeterminant)%EGibbs)
        end if
      end if

      call postprocessDerivs(this%derivs, this%conAtom, this%conVec, this%tLatOpt,&
          & this%totalLatDeriv, this%extLatDerivs, this%normOrigLatVec, this%tLatOptFixAng,&
          & this%tLatOptFixLen, this%tLatOptIsotropic, constrLatDerivs)

      if (tExitGeoOpt) then
        exit geoOpt
      end if

      call printMaxForces(this%derivs, constrLatDerivs, this%tCoordOpt, this%tLatOpt,&
          & this%indMovedAtom)
    #:if WITH_SOCKETS
      if (this%tSocket) then
        call sendEnergyAndForces(env, this%socket, this%dftbEnergy(this%deltaDftb%iFinal),&
            & this%derivs, this%totalStress, this%cellVol)
      end if
    #:endif

      tWriteCharges = allocated(this%qInput) .and. tWriteRestart .and. this%tMulliken&
          & .and. this%tSccCalc .and. .not. this%tDerivs&
          & .and. this%maxSccIter > 1 .and. this%deltaDftb%nDeterminant() == 1&
          & .and. this%tWriteCharges
    #:if WITH_SCALAPACK
      if (this%isHybridXc .and. this%tRealHS) tWriteCharges = .false.
    #:endif
      if (tWriteCharges) then
        call writeCharges(fCharges, this%tWriteChrgAscii, this%orb, this%qInput, this%qBlockIn,&
            & this%qiBlockIn, this%densityMatrix, this%tRealHS, size(this%iAtInCentralRegion),&
            & this%hybridXcAlg, coeffsAndShifts=this%supercellFoldingMatrix,&
            & multipoles=this%multipoleInp)
      end if

      if (this%tDipole.and.allocated(this%derivDriver)) then
        call dipoleAdd(this%derivDriver, this%dipoleMoment)
      end if

      if (this%doPerturbEachGeom.and.allocated(this%derivDriver)) then

        if (this%isEResp) then
          call this%response%wrtEField(env, this%parallelKS, this%filling, this%eigen,&
              & this%eigVecsReal, this%eigvecsCplx, this%ints%hamiltonian, this%ints%overlap,&
              & this%orb, this%nAtom, this%species, this%neighbourList, this%nNeighbourSK,&
              & this%denseDesc, this%iSparseStart, this%img2CentCell, this%coord, this%scc,&
              & this%maxPerturbIter, this%perturbSccTol, this%isPerturbConvRequired,&
              & this%nMixElements, this%nIneqOrb, this%iEqOrbitals, this%tempElec, this%Ef,&
              & this%spinW, this%thirdOrd, this%dftbU, this%iEqBlockDftbu, this%onSiteElements,&
              & this%iEqBlockOnSite, this%hybridXc, this%nNeighbourCam, this%pChrgMixerReal,&
              & this%kPoint, this%kWeight, this%iCellVec, this%cellVec, this%polarisability,&
              & this%dEidE, this%dqOut, this%neFermi, this%dEfdE, errStatus, this%dynRespEFreq)
          if (errStatus%hasError()) then
            call error(errStatus%message)
          end if
          call polAdd(this%derivDriver, this%polarisability(:,:,1))
        end if
      end if

      if (this%tForces) then
        call getNextGeometry(this, env, iGeoStep, tWriteRestart, constrLatDerivs, tCoordStep,&
            & tGeomEnd, tStopDriver, iLatGeoStep, tempIon, tExitGeoOpt)
        if (tExitGeoOpt) then
          exit geoOpt
        end if
      end if

      if (this%tWriteDetailedOut .and. this%tMd) then
        call writeDetailedOut6(this%fdDetailedOut%unit, this%dftbEnergy(this%deltaDftb%iFinal),&
            & tempIon)
      end if

      if (tGeomEnd) then
        call env%globalTimer%stopTimer(globalTimers%postSCC)
        exit geoOpt
      end if

      tStopDriver = tStopScc .or. tStopDriver .or. hasStopFile(fStopDriver)
      if (tStopDriver) then
        call env%globalTimer%stopTimer(globalTimers%postSCC)
        exit geoOpt
      end if
      call env%globalTimer%stopTimer(globalTimers%postSCC)
    end do geoOpt

    call env%globalTimer%startTimer(globalTimers%postGeoOpt)

  #:if WITH_SOCKETS
    if (this%tSocket .and. env%tGlobalLead) then
      call this%socket%shutdown()
    end if
  #:endif

    if (allocated(this%plumedCalc)) then
      call TPlumedCalc_final(this%plumedCalc)
    end if

    tGeomEnd = this%tMD .or. tGeomEnd .or. this%tDerivs

    if (env%tGlobalLead) then
      if (this%tWriteDetailedOut) then
        call writeDetailedOut7(this%fdDetailedOut%unit,&
            & this%isGeoOpt .or. allocated(this%geoOpt), tGeomEnd, this%tMd, this%tDerivs,&
            & this%eField, this%dipoleMoment, this%deltaDftb, this%eFieldScaling,&
            & this%dipoleMessage)
      end if

      call writeFinalDriverStatus(this%isGeoOpt .or. allocated(this%geoOpt), tGeomEnd, this%tMd,&
          & this%tDerivs)

      if (this%tMD) then
        call closeFile(this%fdMd)
        write(stdOut, "(2A)") 'MD information accumulated in ', mdOut
      end if
    end if

    if (env%tGlobalLead .and. this%tDerivs) then
      if (this%tDipole) then
        if (this%doPerturbEachGeom) then
          call getHessianMatrix(this%derivDriver, pDynMatrix, pDipDerivMatrix, pPolDerivMatrix)
        else
          call getHessianMatrix(this%derivDriver, pDynMatrix, pDipDerivMatrix)
        end if
      else
        if (this%doPerturbEachGeom) then
          call getHessianMatrix(this%derivDriver, pDynMatrix, pol=pPolDerivMatrix)
        else
          call getHessianMatrix(this%derivDriver, pDynMatrix)
        end if
      end if
      call writeHessianOut(hessianOut, pDynMatrix, this%indMovedAtom, errStatus)
      if (errStatus%hasError()) then
        call error(errStatus%message)
      end if
      if (this%tDipole) then
        call writeBornChargesOut(bornChargesOut,&
            & this%eFieldScaling%scaledSoluteDipole(pDipDerivMatrix), this%indMovedAtom,&
            & size(this%indDerivAtom), errStatus)
        if (errStatus%hasError()) then
          call error(errStatus%message)
        end if
        if (this%tWriteDetailedOut) then
          call writeDetailedOut8(this%fdDetailedOut%unit,&
              & this%eFieldScaling%scaledSoluteDipole(pDipDerivMatrix))
        end if
      end if
      if (this%doPerturbEachGeom) then
        call writeBornDerivs(bornDerivativesOut, pPolDerivMatrix, this%indMovedAtom,&
            & size(this%indDerivAtom), errStatus)
        if (errStatus%hasError()) then
          call error(errStatus%message)
        end if
      end if
    else
      nullify(pDynMatrix)
      if (this%tDipole) then
        nullify(pDipDerivMatrix)
      end if
      if (this%doPerturbEachGeom) then
        nullify(pPolDerivMatrix)
      end if
    end if

    if (this%tWriteShifts) then
      call writeShifts(fShifts, this%orb, this%potential%intShell)
    end if

    ! Here time propagation is called
    if (allocated(this%electronDynamics)) then
      call runDynamics(this%electronDynamics, this%boundaryCond, this%eigvecsReal, this%H0,&
          & this%species, this%q0, this%referenceN0, this%ints, this%filling, this%neighbourList,&
          & this%nNeighbourSK, this%denseDesc%iAtomStart, this%iSparseStart, this%img2CentCell,&
          & this%orb, this%coord0, this%spinW, this%repulsive, env, this%tDualSpinOrbit, this%xi,&
          & this%thirdOrd, this%solvation, this%eFieldScaling, this%hybridXc, this%qDepExtPot,&
          & this%dftbU, this%iAtInCentralRegion, this%tFixEf, this%Ef, this%coord,&
          & this%onsiteElements, this%skHamCont, this%skOverCont, this%latVec, this%invLatVec,&
          & this%iCellVec, this%rCellVec, this%cellVec, this%electronicSolver, this%densityMatrix,&
          & this%eigvecsCplx, this%taggedWriter, this%refExtPot, errStatus)
      if (errStatus%hasError()) then
        call error(errStatus%message)
      end if
    end if

  #:if WITH_TRANSPORT

    if (env%tGlobalLead .and. this%isAContactCalc) then
      ! Note: shift and charges are saved in QM representation (not UD)
      call writeContactShifts(this%transpar%contacts(this%transpar%taskContInd)%name, this%orb,&
          & this%potential%coulombShell, this%qOutput, this%Ef, this%qBlockOut,&
          & .not.this%transpar%tWriteBinShift)
    end if

    if (this%tLocalCurrents) then
      call this%negfInt%local_currents(env, this%parallelKS%localKS, this%ints%hamiltonian,&
          & this%ints%overlap, this%neighbourList, this%nNeighbourSK, this%cutOff%skCutoff,&
          & this%denseDesc%iAtomStart, this%iSparseStart, this%img2CentCell, this%iCellVec,&
          & this%cellVec, this%rCellVec, this%orb, this%kPoint, this%kWeight, this%coord0Fold,&
          & this%species0, this%speciesName, this%mu, this%lCurrArray, errStatus)
      if (errStatus%hasError()) then
        call error(errStatus%message)
      end if
    end if

    if (this%tTunn) then
      call this%negfInt%calc_current(env, this%parallelKS%localKS, this%ints%hamiltonian,&
          & this%ints%overlap, this%neighbourList%iNeighbour, this%nNeighbourSK,&
          & this%densedesc%iAtomStart, this%iSparseStart, this%img2CentCell, this%iCellVec,&
          & this%cellVec, this%orb, this%kPoint, this%kWeight, this%tunneling, this%current,&
          & this%ldos, this%leadCurrents, this%writeTunn, this%tWriteLDOS, this%regionLabelLDOS,&
          & this%mu)
    end if

  #:endif

    if (this%doPerturbation) then

      if (this%isEResp) then
        call this%response%wrtEField(env, this%parallelKS, this%filling, this%eigen,&
            & this%eigVecsReal, this%eigvecsCplx, this%ints%hamiltonian, this%ints%overlap,&
            & this%orb, this%nAtom, this%species, this%neighbourList, this%nNeighbourSK,&
            & this%denseDesc, this%iSparseStart, this%img2CentCell, this%coord, this%scc,&
            & this%maxPerturbIter, this%perturbSccTol, this%isPerturbConvRequired,&
            & this%nMixElements, this%nIneqOrb, this%iEqOrbitals, this%tempElec, this%Ef,&
            & this%spinW, this%thirdOrd, this%dftbU, this%iEqBlockDftbu, this%onSiteElements,&
            & this%iEqBlockOnSite, this%hybridXc, this%nNeighbourCam, this%pChrgMixerReal,&
            & this%kPoint, this%kWeight, this%iCellVec, this%cellVec, this%polarisability,&
            & this%dEidE, this%dqOut, this%neFermi, this%dEfdE, errStatus, this%dynRespEFreq)
        if (errStatus%hasError()) then
          call error(errStatus%message)
        end if
        if (this%tWriteBandDat) then
          call writeDerivBandOut(derivEBandOut, this%dEidE, this%kWeight)
        end if
        if (env%tGlobalLead .and. this%tWriteDetailedOut) then
          call writeDetailedOut9(this%fdDetailedOut%unit, this%neFermi)
          call writeDetailedOut10(this%fdDetailedOut%unit, this%orb, this%polarisability,&
              & this%dqOut, this%dEfdE)
        end if
      end if

      if (this%isKernelResp) then
        call this%response%wrtVAtom(env, this%parallelKS, this%tWriteAutotest, autotestTag,&
            & this%tWriteResultsTag, resultsTag, this%taggedWriter, this%tWriteBandDat,&
            & this%fdDetailedOut, this%filling, this%eigen, this%eigVecsReal, this%eigvecsCplx,&
            & this%ints%hamiltonian, this%ints%overlap, this%orb, this%nAtom, this%species,&
            & this%neighbourList, this%nNeighbourSK, this%denseDesc, this%iSparseStart,&
            & this%img2CentCell, this%isRespKernelRPA, this%scc, this%maxPerturbIter,&
            & this%perturbSccTol, this%isPerturbConvRequired, this%nMixElements, this%nIneqOrb,&
            & this%iEqOrbitals, this%tempElec, this%Ef, this%spinW, this%thirdOrd, this%dftbU,&
            & this%iEqBlockDftbu, this%onSiteElements, this%iEqBlockOnSite, this%hybridXc,&
            & this%nNeighbourCam, this%pChrgMixerReal, this%kPoint, this%kWeight, this%iCellVec,&
            & this%cellVec, this%neFermi, errStatus, this%dynKernelFreq, this%tHelical, this%coord)
        if (errStatus%hasError()) then
          call error(errStatus%message)
        end if
        if (env%tGlobalLead .and. this%tWriteDetailedOut) then
          call writeDetailedOut9(this%fdDetailedOut%unit, this%neFermi)
        end if
      end if

    end if

    if (env%tGlobalLead .and. this%tWriteDetailedOut) then
      call closeFile(this%fdDetailedOut)
    end if

    if (allocated(this%pipekMezey)) then
      ! NOTE: the canonical DFTB ground state orbitals are over-written after this point
      if (withMpi) then
        call error("Pipek-Mezey localisation does not yet work with MPI")
      end if
      if (this%nSpin > 2) then
        call error("Pipek-Mezey localisation not implemented for non-colinear DFTB")
      end if
      call calcPipekMezeyLocalisation(env, this%pipekMezey, this%tPrintEigvecsTxt, this%nEl,&
          & this%filling, this%ints, this%kPoint, this%neighbourList, this%nNeighbourSk,&
          & this%denseDesc, this%iSparseStart, this%img2CentCell, this%iCellVec, this%cellVec,&
          & this%runId, this%orb, this%species, this%speciesName, this%parallelKS, localisation,&
          & this%eigvecsReal, this%SSqrReal, this%eigvecsCplx, this%SSqrCplx, this%tHelical,&
          & this%coord)
    end if

    if (this%tWriteAutotest.and..not.this%tRestartNoSC) then
      if (this%tPeriodic) then
        this%cellVol = abs(determinant33(this%latVec))
        this%dftbEnergy(this%deltaDftb%iFinal)%EGibbs =&
            & this%dftbEnergy(this%deltaDftb%iFinal)%EMermin + this%extPressure * this%cellVol
      end if
      call writeAutotestTag(autotestTag, this%electronicSolver, this%tPeriodic, this%cellVol,&
          & this%tMulliken, this%qOutput, this%derivs, this%chrgForces, this%excitedDerivs,&
          & this%tStress, this%totalStress, pDynMatrix, this%dftbEnergy(this%deltaDftb%iFinal),&
          & this%extPressure, this%coord0, this%tLocalise, localisation, this%electrostatPot,&
          & this%taggedWriter, this%tunneling, this%ldos, this%lCurrArray, this%polarisability,&
          & this%dEidE, this%dipoleMoment, this%eFieldScaling)
    end if
    if (this%tWriteResultsTag) then
      call writeResultsTag(resultsTag, this%dftbEnergy(this%deltaDftb%iFinal), this%derivs,&
          & this%chrgForces, this%nEl, this%Ef, this%eigen, this%filling, this%electronicSolver,&
          & this%tStress, this%totalStress, pDynMatrix, pDipDerivMatrix, this%tPeriodic,&
          & this%cellVol, this%tMulliken, this%qOutput, this%q0, this%taggedWriter, this%cm5Cont,&
          & this%polarisability, this%dEidE, this%dqOut, this%neFermi, this%dEfdE,&
          & this%dipoleMoment, this%multipoleOut, this%eFieldScaling, this%reks)
    end if
    if (this%tWriteCosmoFile .and. allocated(this%solvation)) then
      call writeCosmoFile(this%solvation, this%species0, this%speciesName, this%coord0, &
          & this%dftbEnergy(this%deltaDftb%iFinal)%EMermin)
    end if
    if (this%tWriteDetailedXML) then
      call writeDetailedXml(this%runId, this%speciesName, this%species0, this%pCoord0Out,&
          & this%tPeriodic, this%tHelical, this%latVec, this%origin, this%tRealHS, this%nKPoint,&
          & this%nSpin, size(this%eigen, dim=1), this%nOrb, this%kPoint, this%kWeight,&
          & this%filling, this%occNatural)
    end if

    call env%globalTimer%stopTimer(globalTimers%postGeoOpt)

  #:if WITH_TRANSPORT
    if (this%electronicSolver%iSolver == electronicSolverTypes%GF .or. &
      & this%electronicSolver%iSolver == electronicSolverTypes%OnlyTransport) then
      call TNegfInt_final(this%negfInt)
    end if
  #:endif

  end subroutine runDftbPlus


  !> Set up charges before determinant calculations
  subroutine preDetCharges(isUnReduced, iDet, nDets, iGeoStep, deltaDftb, qInput, qDets, qBlockIn,&
      & qBlockDets, deltaRhoIn, deltaRhoDets)

    !> Are charge reductions required after this routine
    logical, intent(out) :: isUnReduced

    !> The current determinant being processed
    integer, intent(in) :: iDet

    !> Total number of determinants
    integer, intent(in) :: nDets

    !> Geometry step
    integer, intent(in) :: iGeoStep

    !> Determinant derived type
    type(TDftbDeterminants), intent(in) :: deltaDftb

    !> Input charges
    real(dp), intent(inout) :: qInput(:,:,:)

    !> Input charges from multiple determinants
    real(dp), intent(inout), allocatable :: qDets(:,:,:,:)

    !> Block charge input (if needed for orbital potentials)
    real(dp), intent(inout), allocatable :: qBlockIn(:,:,:,:)

    !> Block charge input (if needed for orbital potentials), from multiple determinants
    real(dp), intent(inout), allocatable :: qBlockDets(:,:,:,:,:)

    !> Delta density matrix as input for next SCC cycle (if needed for range sep. potentials)
    real(dp), intent(inout), allocatable :: deltaRhoIn(:,:,:)

    !> Delta density matrix (if needed for range sep. potentials), from multiple determinants
    real(dp), intent(inout), allocatable :: deltaRhoDets(:,:,:,:)

    isUnReduced = .false.
    if (nDets > 1) then
      if (iGeoStep == 0) then
        if (deltaDftb%iGround > 0 .and. iDet /= deltaDftb%iGround) then
          qInput(:,:,:) = qDets(:,:,:, deltaDftb%iGround)
          if (allocated(qBlockIn)) then
            qBlockIn(:,:,:,:) = qBlockDets(:,:,:,:, deltaDftb%iGround)
          end if
          if (allocated(deltaRhoIn)) then
            deltaRhoIn(:,:,:) = deltaRhoDets(:,:,:, deltaDftb%iGround)
          end if
          isUnReduced = .true.
        end if
      else
        qInput(:,:,:) = qDets(:,:,:,iDet)
        if (allocated(qBlockIn)) then
          qBlockIn(:,:,:,:) = qBlockDets(:,:,:,:,iDet)
        end if
        if (allocated(deltaRhoIn)) then
          deltaRhoIn(:,:,:) = deltaRhoDets(:,:,:, iDet)
        end if
        isUnReduced = .true.
      end if
    end if

  end subroutine preDetCharges


  !> Store (if necessary) charges after determinant calculations
  subroutine postDetCharges(iDet, nDets, qOutput, qDets, qBlockDets, qBlockOut, deltaRhoDets,&
      & deltaRhoOut)

    !> The current determinant being processed
    integer, intent(in) :: iDet

    !> Total number of determinants
    integer, intent(in) :: nDets

    !> Output charges
    real(dp), intent(inout) :: qOutput(:,:,:)

    !> Output charges from multiple determinants
    real(dp), intent(inout), allocatable :: qDets(:,:,:,:)

    !> Block charge output (if needed for orbital potentials), from multiple determinants
    real(dp), intent(inout), allocatable :: qBlockDets(:,:,:,:,:)

    !> Block charge output (if needed for orbital potentials)
    real(dp), intent(inout), allocatable :: qBlockOut(:,:,:,:)

    !> Delta density matrix (if needed for range sep. potentials), from multiple determinants
    real(dp), intent(inout), allocatable :: deltaRhoDets(:,:,:,:)

    !> Delta density matrix as input for next SCC cycle (if needed for range sep. potentials)
    real(dp), intent(inout), allocatable :: deltaRhoOut(:,:,:)

    if (nDets > 1) then
      qDets(:,:,:, iDet) = qOutput
      if (allocated(qBlockOut)) then
        qBlockDets(:,:,:,:, iDet) = qBlockOut
      end if
      if (allocated(deltaRhoDets)) then
        deltaRhoDets(:,:,:, iDet) = deltaRhoOut
      end if
    end if

  end subroutine postDetCharges


  !> Process the various potential contributions to give final potential to be added to the model
  subroutine processPotentials(env, this, iSccIter, updateScc, q, qBlock, qiBlock)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Global variables
    type(TDftbPlusMain), intent(inout) :: this

    !> Current self-consistent iteration
    integer :: iSccIter

    !> Whether the charges in the scc calculator should be updated before obtaining the potential
    logical, intent(in) :: updateScc

    !> Mulliken populations for orbitals
    real(dp), intent(inout) :: q(:,:,:)

    !> Dual atomic charges
    real(dp), intent(inout), allocatable :: qBlock(:,:,:,:)

    !> Imaginary part of dual atomic charges
    real(dp), intent(inout), allocatable :: qiBlock(:,:,:,:)

    ! Shift due to constraints
    real(dp) :: constrShift(this%orb%mOrb, this%orb%mOrb, this%nAtom, this%nSpin)

    ! Charge difference
    real(dp), allocatable :: dQ(:,:,:)

    if (allocated(this%qDepExtPot)) then
      allocate(dQ(this%orb%mShell, this%nAtom, this%nSpin))
    end if

    call resetInternalPotentials(this%tDualSpinOrbit, this%xi, this%orb, this%species,&
        & this%potential)

    if (this%tSccCalc) then

    #:if WITH_TRANSPORT
      ! Overrides input charges with uploaded contact charges
      if (this%tUpload) then
        call overrideContactCharges(q, this%chargeUp, this%transpar, qBlock, this%blockUp)
      end if
    #:endif

      call getChargePerShell(q, this%orb, this%species, this%chargePerShell)

      call addChargePotentials(env, this%scc, this%tblite, updateScc, q, this%q0,&
          & this%chargePerShell, this%orb, this%multipoleInp, this%species, this%neighbourList,&
          & this%img2CentCell, this%spinW, this%solvation, this%thirdOrd, this%dispersion,&
          & this%potential)

      call addBlockChargePotentials(qBlock, qiBlock, this%dftbU, this%tImHam,&
          & this%species, this%orb, this%potential)

      if (allocated(this%onSiteElements) .and. (iSCCIter > 1 .or. this%tReadChrg)) then
        call addOnsShift(this%potential%intBlock, this%potential%iOrbitalBlock, qBlock,&
            & qiBlock, this%onSiteElements, this%species, this%orb, this%q0)
      end if

    end if

    if (allocated(this%elecConstraint)) then
      call this%elecConstraint%getConstraintShift(constrShift)
      this%potential%intBlock(:,:,:,:) = this%potential%intBlock + constrShift
    end if

    ! All potentials are added up into intBlock
    this%potential%intBlock(:,:,:,:) = this%potential%intBlock + this%potential%extBlock

    if (allocated(this%qDepExtPot)) then
      call getChargePerShell(q, this%orb, this%species, dQ, qRef=this%q0)
      call this%qDepExtPot%addPotential(sum(dQ(:,:,1), dim=1), dQ(:,:,1), this%orb, this%species,&
          & this%potential%intBlock)
    end if

  end subroutine processPotentials


  !> Processes derived charges and populations from the Mulliken populations.
  subroutine processOutputCharges(env, this)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Global variables
    type(TDftbPlusMain), intent(inout) :: this

    ! Square dense overlap storage for calculating delta rho in Gamma-point case with hybrid
    ! xc-functionals
    real(dp), allocatable :: SSqrReal(:,:)

    ! CAM calculations need to deduct atomic charges from delta density matrix
    if (this%isHybridXc) then

      if (this%tRealHS) then
        allocate(SSqrReal, mold=this%SSqrReal)
      #:if WITH_SCALAPACK
        call unpackHSRealBlacs(env%blacs, this%ints%overlap, this%neighbourList%iNeighbour,&
            & this%nNeighbourSK, this%iSparseStart, this%img2CentCell, this%denseDesc, SSqrReal)
      #:else
        call unpackHS(SSqrReal, this%ints%overlap, this%neighbourList%iNeighbour,&
            & this%nNeighbourSK, this%denseDesc%iAtomStart, this%iSparseStart, this%img2CentCell)
      #:endif
      end if

    #:if WITH_SCALAPACK
      if (this%tRealHS .and. this%tPeriodic) then
        call denseSubtractDensityOfAtomsRealPeriodicBlacs(env, this%parallelKS, this%q0,&
            & this%denseDesc, SSqrReal, this%densityMatrix%deltaRhoOut)
      elseif (this%tRealHS .and. (.not. this%tPeriodic)) then
        call denseSubtractDensityOfAtomsRealNonperiodicBlacs(env, this%parallelKS, this%q0,&
            & this%denseDesc, this%densityMatrix%deltaRhoOut)
      end if
    #:else
      if (this%tRealHS) then
        call denseSubtractDensityOfAtomsReal(this%q0, this%denseDesc%iAtomStart,&
            & SSqrReal, this%densityMatrix%deltaRhoOut)
      end if
    #:endif

      if (.not. this%tRealHS) then
        if (this%hybridXc%hybridXcAlg == hybridXcAlgo%matrixBased) then
          call denseSubtractDensityOfAtomsCmplxPeriodicGlobal(env, this%ints, this%denseDesc,&
              & this%neighbourList, this%kPoint, this%densityMatrix%iKiSToiGlobalKS,&
              & this%nNeighbourSK, this%iCellVec, this%cellVec, this%iSparseStart,&
              & this%img2CentCell, this%q0, this%densityMatrix%deltaRhoOutCplx)
        else
          call denseSubtractDensityOfAtomsCmplxPeriodic(env, this%ints, this%denseDesc,&
              & this%parallelKS, this%neighbourList, this%kPoint, this%nNeighbourSK, this%iCellVec,&
              & this%cellVec, this%iSparseStart, this%img2CentCell, this%q0,&
              & this%densityMatrix%deltaRhoOutCplx)
          ! Build real-space delta rho from k-space density matrix:
          ! Also, zero-out deltaRhoOutCplxHS, because of internal summation.
          this%densityMatrix%deltaRhoOutCplxHS(:,:,:,:,:,:) = 0.0_dp
          call transformDualSpaceToBvKRealSpace(this%densityMatrix%deltaRhoOutCplx,&
              & this%parallelKS, this%kPoint, this%kWeight, this%hybridXc%bvKShifts,&
              & this%densityMatrix%deltaRhoOutCplxHS)
        #:if WITH_MPI
          ! Distribute all square, real-space density matrices to all nodes via global summation
          call mpifx_allreduceip(env%mpi%interGroupComm, this%densityMatrix%deltaRhoOutCplxHS,&
              & MPI_SUM)
        #:endif
        end if
      end if
      if (this%tRealHS) deallocate(SSqrReal)
    end if

    ! For non-dual spin-orbit orbitalL is determined during getDensity() call above
    if (this%tDualSpinOrbit) then
      call getLDual(this%orbitalL, this%qiBlockOut, this%orb, this%species)
    end if

    if (this%tMulliken .or. this%isHybridXc) then
      call getMullikenPopulation(env, this%rhoPrim, this%ints, this%orb, this%neighbourList,&
          & this%nNeighbourSk, this%img2CentCell, this%iSparseStart, this%qOutput,&
          & iRhoPrim=this%iRhoPrim, qBlock=this%qBlockOut, qiBlock=this%qiBlockOut,&
          & qNetAtom=this%qNetAtom, multipoles=this%multipoleOut)

      if (this%tSpinSharedEf .or. this%tFixEf .or.&
          & this%electronicSolver%iSolver == electronicSolverTypes%GF) then
        this%nEl(:) = sum(sum(this%qOutput(:, this%iAtInCentralRegion, :size(this%nEl)), dim=1),&
            & dim=1)
        call qm2ud(this%nEl)
      end if

    end if

  #:if WITH_TRANSPORT
    ! Overrides input charges with uploaded contact charges
    if (this%tUpload) then
      call overrideContactCharges(this%qOutput, this%chargeUp, this%transpar, this%qBlockOut,&
          & this%blockUp)
    end if
  #:endif

  end subroutine processOutputCharges


  !> Output charges SCC handling
  subroutine processScc(env, this, iGeoStep, iSccIter, sccErrorQ, tConverged, eOld, diffElec,&
      & tStopScc, errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Global variables
    type(TDftbPlusMain), intent(inout) :: this

    !> Current geometry step
    integer, intent(in) :: iGeoStep

    !> Number of the current SCC step
    integer, intent(in) :: iSccIter

    !> Self-consistency error
    real(dp), intent(out) :: sccErrorQ

    !> Has the calculation converged
    logical, intent(out) :: tConverged

    !> Energy in previous SCC cycle
    real(dp), intent(inout) :: Eold

    !> Difference in electronic energies between this and the previous iterations
    real(dp), intent(out) :: diffElec

    !> If scc driver should be stopped
    logical, intent(out) :: tStopScc

    !> Error status
    type(TStatus), intent(inout) :: errStatus

    logical :: tWriteSccRestart

    tStopScc = .false.

    if (this%tSccCalc) then

      tStopScc = hasStopFile(fStopScc)

      ! Mix charges Input/Output

      if (.not. this%isHybridXc) then
        call getNextInputCharges(env, this%pChrgMixerReal, this%qOutput, this%qOutRed, this%orb,&
            & this%nIneqOrb, this%iEqOrbitals, iGeoStep, iSccIter, this%minSccIter,&
            & this%maxSccIter, this%sccTol, tStopScc, this%tMixBlockCharges, this%tReadChrg,&
            & this%qInput, this%qInpRed, sccErrorQ, tConverged, this%dftbU, this%qBlockOut,&
            & this%iEqBlockDftbU, this%qBlockIn, this%qiBlockOut, this%iEqBlockDftbULS,&
            & this%species0, this%qiBlockIn, this%iEqBlockOnSite, this%iEqBlockOnSiteLS,&
            & this%nIneqDip, this%nIneqQuad, this%multipoleOut, this%multipoleInp)
      else
        if (this%tRealHS) then
          call getNextInputDensityReal(env, this%parallelKS, this%SSqrReal, this%ints,&
              & this%neighbourList, this%nNeighbourSK, this%denseDesc, this%iSparseStart,&
              & this%img2CentCell, this%pChrgMixerReal, this%qOutput, this%orb, this%tHelical,&
              & this%species0, this%species, this%coord, iGeoStep, iSccIter, this%minSccIter,&
              & this%maxSccIter, this%sccTol, tStopScc, this%tReadChrg, this%q0, this%hybridXc,&
              & this%qInput, sccErrorQ, tConverged, this%densityMatrix, this%qBlockIn,&
              & this%qBlockOut, errStatus)
          @:PROPAGATE_ERROR(errStatus)
        else
          call getNextInputDensityCplx(env, this%ints, this%neighbourList, this%nNeighbourSK,&
              & this%denseDesc, this%iSparseStart, this%img2CentCell, this%pChrgMixerReal,&
              & this%pChrgMixerCmplx, this%qOutput, this%orb, this%parallelKS, this%kPoint,&
              & this%kWeight, iGeoStep, iSccIter, this%minSccIter, this%maxSccIter, this%sccTol,&
              & tStopScc, this%tReadChrg, this%checkStopHybridCalc, this%q0, this%iCellVec,&
              & this%cellVec, this%hybridXc, this%qInput, sccErrorQ, tConverged,&
              & this%densityMatrix, this%qBlockIn, this%qBlockOut)
        end if
      end if

      call getSccInfo(iSccIter, this%dftbEnergy(this%deltaDftb%iDeterminant)%Eelec, Eold,&
          & diffElec)
      if (this%tNegf) call printSccHeader()

      tWriteSccRestart = env%tGlobalLead .and. needsSccRestartWriting(this%restartFreq,&
          & iGeoStep, iSccIter, this%minSccIter, this%maxSccIter, this%tMd,&
          & this%isGeoOpt .or. allocated(this%geoOpt),&
          & this%tDerivs, tConverged, this%tReadChrg, tStopScc) .and. this%tWriteCharges
    #:if WITH_SCALAPACK
      if (this%isHybridXc) then
        if (this%tRealHS .and. this%hybridXc%hybridXcAlg == hybridXcAlgo%matrixBased) then
          tWriteSccRestart = .false.
        end if
      end if
    #:endif
      if (tWriteSccRestart) then
        call writeCharges(fCharges, this%tWriteChrgAscii, this%orb, this%qInput, this%qBlockIn,&
            & this%qiBlockIn, this%densityMatrix, this%tRealHS, size(this%iAtInCentralRegion),&
            & this%hybridXcAlg, coeffsAndShifts=this%supercellFoldingMatrix,&
            & multipoles=this%multipoleInp)
      end if

    end if

  end subroutine processScc


  !> Write data from inside the SCC loop
  subroutine sccLoopWriting(this, iGeoStep, iLatGeoStep, iSccIter, diffElec, sccErrorQ)

    !> Global variables
    type(TDftbPlusMain), intent(inout) :: this

    !> Current geometry step
    integer, intent(in) :: iGeoStep

    !> Lattice geometry steps so far
    integer, intent(in) :: iLatGeoStep

    !> Current self-consistent iteration
    integer, intent(in) :: iSccIter

    !> Difference in electronic energies between this and the previous iterations
    real(dp), intent(in) :: diffElec

    !> Self-consistency error
    real(dp), intent(in) :: sccErrorQ

     if (this%tSccCalc) then
      call printSccInfo(allocated(this%dftbU), iSccIter,&
          & this%dftbEnergy(this%deltaDftb%iDeterminant)%Eelec, diffElec, sccErrorQ)
      if (this%tNegf) then
        call printBlankLine()
      end if
    end if

    if (this%tWriteDetailedOut .and. this%deltaDftb%nDeterminant() == 1) then
      call openOutputFile(userOut, tAppendDetailedOut, this%fdDetailedOut)
      call writeDetailedOut1(this%fdDetailedOut%unit, this%iDistribFn, this%nGeoSteps,&
          & iGeoStep, this%tMD, this%tDerivs, this%tCoordOpt, this%tLatOpt, iLatGeoStep,&
          & iSccIter, this%dftbEnergy(this%deltaDftb%iDeterminant), diffElec, sccErrorQ,&
          & this%indMovedAtom, this%pCoord0Out, this%tPeriodic, this%tSccCalc, this%tNegf,&
          & this%invLatVec, this%kPoint)
      call writeDetailedOut2(this%fdDetailedOut%unit, this%q0, this%qOutput, this%orb,&
          & this%species, allocated(this%dftbU), this%tImHam .or. this%tSpinOrbit,&
          & this%tPrintMulliken, this%orbitalL, this%qBlockOut, this%nSpin,&
          & allocated(this%onSiteElements), this%iAtInCentralRegion, this%cm5Cont,&
          & this%qNetAtom)
      call writeDetailedOut3(this%fdDetailedOut%unit, this%qInput, this%qOutput,&
          & this%dftbEnergy(this%deltaDftb%iDeterminant), this%species, allocated(this%dftbU),&
          & this%tPrintMulliken, this%Ef, this%extPressure, this%cellVol, this%tAtomicEnergy,&
          & this%dispersion, allocated(this%eField), this%tPeriodic, this%nSpin, this%tSpin,&
          & this%tSpinOrbit, this%tSccCalc, allocated(this%onSiteElements),&
          & this%iAtInCentralRegion, this%electronicSolver, allocated(this%halogenXCorrection),&
          & this%isHybridXc, allocated(this%thirdOrd), allocated(this%solvation))
    end if

  end subroutine sccLoopWriting


  !> Process current geometry
  subroutine processGeometry(this, env, iGeoStep, iLatGeoStep, tWriteRestart, tStopScc,&
      & tExitGeoOpt, errStatus)

    !> Global variables
    type(TDftbPlusMain), intent(inout) :: this

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Current geometry step
    integer, intent(in) :: iGeoStep

    !> Current lattice step
    integer, intent(in) :: iLatGeoStep

    !> Flag to write out geometries (and charge data if scc)
    logical, intent(in) :: tWriteRestart

    !> If scc driver should be stopped
    logical, intent(out) :: tStopScc

    !> Whether main code should exit the geometry optimisation loop
    logical, intent(out) :: tExitGeoOpt

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    !! Self-consistency error in the last iterations
    real(dp) :: sccErrorQ

    !! Difference in electronic energy last iterations
    real(dp) :: diffElec

    !! Loop variables
    integer :: iSccIter

    !! Energy in previous scc cycles
    real(dp) :: Eold

    !! Whether scc converged
    logical :: tConverged

    !! Charge difference
    real(dp), allocatable :: dQ(:,:,:)

    !! Auxiliary dipole storage
    real(dp), allocatable :: dipoleTmp(:)

    !! Whether constraints are converged
    logical :: constrConverged

    integer :: iKS, iConstrIter, nConstrIter
    logical :: isFirstDet

    if (this%tDipole) allocate(dipoleTmp(3))
    isFirstDet = this%deltaDftb%iDeterminant == 1

    call env%globalTimer%startTimer(globalTimers%preSccInit)

    if (allocated(this%qDepExtPot)) allocate(dQ(this%orb%mShell, this%nAtom, this%nSpin))

    call this%electronicSolver%reset()
    tExitGeoOpt = .false.

    if (this%tMD .and. tWriteRestart .and. isFirstDet) then
      if (iGeoStep == 0) then
        call openOutputFile(mdOut, .false., this%fdMd)
      end if
      call writeMdOut1(this%fdMd%unit, iGeoStep, this%pMDIntegrator)
    end if

    if (this%tLatticeChanged .and. isFirstDet) then
      call handleLatticeChange(this%latVec, this%scc, this%tblite, this%tStress, this%extPressure,&
          & this%cutOff%mCutOff, this%repulsive, this%dispersion, this%solvation, this%cm5Cont,&
          & this%recVec, this%invLatVec, this%cellVol, this%recCellVol, this%extLatDerivs,&
          & this%cellVec, this%rCellVec, this%boundaryCond)
    end if

    if (this%tCoordsChanged .and. isFirstDet) then
      call handleCoordinateChange(env, this%boundaryCond, this%coord0, this%latVec, this%invLatVec,&
          & this%species0, this%cutOff, this%orb, this%tPeriodic, this%tRealHS, this%tHelical,&
          & this%scc, this%tblite, this%repulsive, this%dispersion,this%solvation, this%thirdOrd,&
          & this%hybridXc, this%reks, this%img2CentCell, this%iCellVec, this%neighbourList,&
          & this%symNeighbourList, this%nAllAtom, this%coord0Fold, this%coord,this%species,&
          & this%cellVec, this%rCellVec, this%denseDesc, this%nNeighbourSk, this%nNeighbourCam,&
          & this%nNeighbourCamSym, this%ints, this%H0, this%rhoPrim, this%iRhoPrim, this%ERhoPrim,&
          & this%iSparseStart, this%cm5Cont, this%skOverCont, errStatus)
        @:PROPAGATE_ERROR(errStatus)
    end if

  #:if WITH_TRANSPORT
    if (this%tNegf .and. isFirstDet) then
      call setupNegfStuff(this%negfInt, this%denseDesc, this%transpar, this%ginfo,&
          & this%neighbourList, this%nNeighbourSK, this%img2CentCell, this%orb)
    end if
  #:endif

    if (this%tSccCalc .and. .not. allocated(this%reks) .and. .not. this%tRestartNoSC) then
      if (this%isHybridXc) then
        if (withMpi .and. this%tRealHS&
            & .and. this%hybridXc%hybridXcAlg == hybridXcAlgo%matrixBased) then
          call TMixerReal_reset(this%pChrgMixerReal, this%nOrb**2 * this%nSpin)
        elseif (allocated(this%pChrgMixerCmplx)) then
          call TMixerCmplx_reset(this%pChrgMixerCmplx, this%nMixElements)
        else
          call TMixerReal_reset(this%pChrgMixerReal, this%nMixElements)
        end if
      else
        call TMixerReal_reset(this%pChrgMixerReal, this%nMixElements)
      end if
    end if

    if (this%electronicSolver%isElsiSolver .and. isFirstDet .and. .not. this%tLargeDenseMatrices)&
        & then
      call this%electronicSolver%elsi%updateGeometry(env, this%neighbourList, this%nNeighbourSK,&
          & this%denseDesc%iAtomStart, this%iSparseStart, this%img2CentCell)
    end if

    if (isFirstDet) then
      call env%globalTimer%startTimer(globalTimers%sparseH0S)
      select case(this%hamiltonianType)
      case default
        call error("Invalid Hamiltonian")
      case(hamiltonianTypes%dftb)
        call buildH0(env, this%H0, this%skHamCont, this%atomEigVal, this%coord, this%nNeighbourSk,&
            & this%neighbourList%iNeighbour, this%species, this%iSparseStart, this%orb)
        call buildS(env, this%ints%overlap, this%skOverCont, this%coord, this%nNeighbourSk,&
            & this%neighbourList%iNeighbour, this%species, this%iSparseStart, this%orb)
      case(hamiltonianTypes%xtb)
        @:ASSERT(allocated(this%tblite), "Compiled without TBLITE included")
        call this%tblite%buildSH0(env, this%species, this%coord, this%nNeighbourSk, &
            & this%neighbourList%iNeighbour, this%img2CentCell, this%iSparseStart, &
            & this%orb, this%H0, this%ints%overlap, this%ints%dipoleBra, this%ints%dipoleKet, &
            & this%ints%quadrupoleBra, this%ints%quadrupoleKet)
      end select
      call env%globalTimer%stopTimer(globalTimers%sparseH0S)

      if (this%tSetFillingTemp) then
        call this%temperatureProfile%getTemperature(this%tempElec)
      end if
      call this%electronicSolver%updateElectronicTemp(this%tempElec)
    end if

    if (allocated(this%repulsive)) then
      call this%repulsive%getEnergy(this%coord, this%species, this%img2CentCell,&
          & this%neighbourList,this%dftbEnergy(this%deltaDftb%iDeterminant)%atomRep,&
          & this%dftbEnergy(this%deltaDftb%iDeterminant)%ERep,&
          & iAtInCentralRegion=this%iAtInCentralRegion)
    end if

    if (allocated(this%halogenXCorrection)) then
      call this%halogenXCorrection%getEnergies(this%dftbEnergy(&
          & this%deltaDftb%iDeterminant)%atomHalogenX, this%coord, this%species,&
          & this%neighbourList, this%img2CentCell)
      this%dftbEnergy(this%deltaDftb%iDeterminant)%EHalogenX =&
          & sum(this%dftbEnergy(this%deltaDftb%iDeterminant)%atomHalogenX(this%iAtInCentralRegion))
    end if

    if (isFirstDet) then

      call resetExternalPotentials(this%refExtPot, this%potential)

      if (this%tReadShifts) then
        call readShifts(fShifts, this%orb, this%nAtom, this%nSpin, this%potential%extShell)
      end if

      call addUpExternalField(this%eField, this%tPeriodic, this%neighbourList, this%nNeighbourSk,&
          & this%iCellVec, this%cellVec, this%deltaT, iGeoStep, this%coord0Fold, this%coord,&
          & this%potential)

      call mergeExternalPotentials(this%orb, this%species, this%potential)

    end if

    ! For non-scc calculations with transport only, jump out of geometry loop
    if (this%electronicSolver%iSolver == electronicSolverTypes%OnlyTransport) then
      if (this%tWriteDetailedOut) then
        call openOutputFile(userOut, tAppendDetailedOut, this%fdDetailedOut)
      end if
      ! We need to define Hamiltonian by adding the potential
      call getSccHamiltonian(env, this%H0, this%ints, this%nNeighbourSK, this%neighbourList,&
          & this%species, this%orb, this%iSparseStart, this%img2CentCell, this%potential,&
          & allocated(this%reks), this%ints%hamiltonian, this%ints%iHamiltonian)
      tExitGeoOpt = .true.
      return
    end if

    if (isFirstDet) then
      if (this%electronicSolver%iSolver == electronicSolverTypes%pexsi) then
        call this%electronicSolver%elsi%initPexsiDeltaVRanges(this%tSccCalc, this%potential)
      end if
    end if

    if (.not.this%tRestartNoSC) then
      call initSccLoop(this%tSccCalc, this%xlbomdIntegrator, this%minSccIter, this%maxSccIter,&
          & this%sccTol, tConverged, this%tNegf, this%reks)
    else
      tConverged = .true.
    end if

    call env%globalTimer%stopTimer(globalTimers%preSccInit)

    call env%globalTimer%startTimer(globalTimers%scc)

    REKS_SCC: if (allocated(this%reks)) then

      lpSCC_REKS: do iSccIter = 1, this%maxSccIter

        if (iSccIter == 1) then
          call getReksInitialSettings(env, this%denseDesc, this%h0, this%ints, this%neighbourList,&
              & this%nNeighbourSK, this%iSparseStart, this%img2CentCell, this%electronicSolver,&
              & iGeoStep, this%HSqrReal, this%SSqrReal, this%eigvecsReal, this%eigen, this%reks,&
              & errStatus)
          @:PROPAGATE_ERROR(errStatus)
        end if

        call getDensityMatrixL(env, this%denseDesc, this%neighbourList, this%nNeighbourSK,&
            & this%iSparseStart, this%img2CentCell, this%orb, this%species, this%coord,&
            & this%tPeriodic, this%tHelical, this%eigvecsReal, this%parallelKS, this%rhoPrim,&
            & this%SSqrReal, this%rhoSqrReal, this%q0, this%densityMatrix, this%hybridXc,&
            & this%reks, this%apiCallBack, errstatus)
        @:PROPAGATE_ERROR(errStatus)

        call getMullikenPopulationL(env, this%denseDesc, this%neighbourList, this%nNeighbourSK,&
            & this%img2CentCell, this%iSparseStart, this%orb, this%rhoPrim, this%ints,&
            & this%iRhoPrim, this%qBlockOut, this%qiBlockOut, this%qNetAtom, this%reks)

        call getHamiltonianLandEnergyL(env, this%denseDesc, this%scc, this%tblite, this%orb,&
            & this%species, this%neighbourList, this%symNeighbourList, this%nNeighbourSK,&
            & this%iSparseStart, this%img2CentCell, this%H0, this%ints, this%spinW, this%cellVol,&
            & this%extPressure, this%dftbEnergy(1), this%q0, this%iAtInCentralRegion,&
            & this%solvation, this%thirdOrd, this%potential, this%hybridXc, this%nNeighbourCam,&
            & this%nNeighbourCamSym, this%tDualSpinOrbit, this%xi, this%isExtField, this%isXlbomd,&
            & this%dftbU, this%dftbEnergy(1)%TS, this%qDepExtPot, this%qBlockOut, this%qiBlockOut,&
            & this%tFixEf, this%Ef, this%rhoPrim, this%onSiteElements, this%dispersion, tConverged,&
            & this%species0, this%referenceN0, this%qNetAtom, this%multipoleOut, this%reks,&
            & errStatus)
        @:PROPAGATE_ERROR(errStatus)
        call optimizeFONsAndWeights(this%eigvecsReal, this%filling, this%dftbEnergy(1), this%reks)

        call getFockandDiag(env, this%denseDesc, this%neighbourList, this%nNeighbourSK,&
            & this%iSparseStart, this%img2CentCell, this%eigvecsReal, this%electronicSolver,&
            & this%eigen, this%reks)

        ! Creates (delta) density matrix for averaged state from real eigenvectors.
        call getDensityFromRealEigvecs(env, this%denseDesc, this%filling(:,1,:),&
            & this%neighbourList, this%nNeighbourSK, this%iSparseStart, this%img2CentCell,&
            & this%orb, this%species, this%coord, this%tPeriodic, this%tHelical, this%eigVecsReal,&
            & this%parallelKS, this%densityMatrix, this%rhoPrim, this%SSqrReal, this%rhoSqrReal,&
            & this%hybridXc, this%apiCallBack, errStatus)
        @:PROPAGATE_ERROR(errStatus)
        ! For hybrid xc-functional calculations deduct atomic charges from deltaRho
        if (this%isHybridXc) then
          call denseSubtractDensityOfAtomsNospinRealNonperiodicReks(this%q0,&
              & this%denseDesc%iAtomStart, this%densityMatrix%deltaRhoOut)
        end if
        call getMullikenPopulation(env, this%rhoPrim, this%ints, this%orb, this%neighbourList,&
            & this%nNeighbourSK, this%img2CentCell, this%iSparseStart, this%qOutput,&
            & iRhoPrim=this%iRhoPrim, qBlock=this%qBlockOut, qiBlock=this%qiBlockOut,&
            & qNetAtom=this%qNetAtom, multipoles=this%multipoleOut)

        ! Check charge convergence and guess new eigenvectors
        tStopScc = hasStopFile(fStopScc)
        if (this%isHybridXc) then
          call getReksNextInputDensity(sccErrorQ, this%sccTol, tConverged, iSccIter,&
              & this%minSccIter, this%maxSccIter, iGeoStep, tStopScc, this%eigvecsReal,&
              & this%densityMatrix%deltaRhoOut, this%densityMatrix%deltaRhoIn,&
              & this%reks)
        else
          call getReksNextInputCharges(this%qInput, this%qOutput, this%qDiff, sccErrorQ,&
              & this%sccTol, tConverged, iSccIter, this%minSccIter, this%maxSccIter, iGeoStep,&
              & tStopScc, this%eigvecsReal, this%reks)
        end if

        call getSccInfo(iSccIter, this%dftbEnergy(1)%Eavg, Eold, diffElec)
        call printReksSccInfo(iSccIter, this%dftbEnergy(1)%Eavg, diffElec, sccErrorQ,&
            & this%reks)

        if (tConverged .or. tStopScc) then

          call printReksSAInfo(this%reks, this%dftbEnergy(1)%Eavg)

          call getStateInteraction(env, this%denseDesc, this%neighbourList, this%nNeighbourSK,&
              & this%iSparseStart, this%img2CentCell, this%coord, this%iAtInCentralRegion,&
              & this%eigvecsReal, this%electronicSolver, this%eigen, this%qOutput, this%q0,&
              & this%tDipole, dipoleTmp, this%reks)
          call assignDipoleMoment(dipoleTmp, this%dipoleMoment, this%deltaDftb%iDeterminant,&
              & this%tDipole, this%reks, isSingleState=.true.)

          call getReksEnProperties(env, this%denseDesc, this%neighbourList, this%nNeighbourSK,&
              & this%img2CentCell, this%iSparseStart, this%eigvecsReal, this%coord0, this%reks,&
              & this%densityMatrix, errStatus)
          @:PROPAGATE_ERROR(errStatus)

          if (this%tWriteDetailedOut .and. this%deltaDftb%nDeterminant() == 1) then
            ! In this routine the correct Etotal is evaluated.
            ! If TargetStateL > 0, certain microstate
            ! is optimized. If not, SSR state is optimized.
            call openOutputFile(userOut, tAppendDetailedOut, this%fdDetailedOut)
            call writeReksDetailedOut1(this%fdDetailedOut%unit, this%nGeoSteps, iGeoStep,&
                & this%tMD, this%tDerivs, this%tCoordOpt, this%tLatOpt, iLatGeoStep, iSccIter,&
                & this%dftbEnergy(1), diffElec, sccErrorQ, this%indMovedAtom, this%pCoord0Out,&
                & this%q0, this%qOutput, this%orb, this%species, this%tPrintMulliken,&
                & this%extPressure, this%cellVol, this%tAtomicEnergy, this%dispersion,&
                & this%tPeriodic, this%tSccCalc, this%invLatVec, this%kPoint,&
                & this%iAtInCentralRegion, this%electronicSolver, this%reks,&
                & allocated(this%thirdOrd), this%isHybridXc, qNetAtom=this%qNetAtom)
          end if
          if (this%tWriteBandDat) then
            if (this%tMD .and. iGeoStep /= 0 .and. tWriteRestart) then
              call writeBandOut(bandOut, this%eigen, this%filling, this%kWeight,&
                  & isFileAppended=this%mdOutput%bandStructure)
            else
              call writeBandOut(bandOut, this%eigen, this%filling, this%kWeight)
            end if
          end if

          exit lpSCC_REKS
        end if
      end do lpSCC_REKS

    else ! not REKS_SCC

      ! Standard spin free or unrestricted DFTB

      lpSCC: do iSccIter = 1, this%maxSccIter

        if (allocated(this%elecConstraint)) then
          nConstrIter = this%elecConstraint%getMaxIter()
          call printElecConstrHeader()
          call this%elecConstraint%potOpt%reset()
        else
          nConstrIter = 1
        end if

        lpConstrInner: do iConstrIter = 1, nConstrIter

          call processPotentials(env, this, iSccIter, .true., this%qInput, this%qBlockIn,&
              & this%qiBlockIn)

          if (this%electronicSolver%iSolver == electronicSolverTypes%pexsi .and. this%tSccCalc) then
            call this%electronicSolver%elsi%updatePexsiDeltaVRanges(this%potential)
          end if

          call getSccHamiltonian(env, this%H0, this%ints, this%nNeighbourSK, this%neighbourList,&
              & this%species, this%orb, this%iSparseStart, this%img2CentCell,&
              & this%potential, allocated(this%reks), this%ints%hamiltonian,&
              & this%ints%iHamiltonian)

          if (this%tWriteRealHS .or. this%tWriteHS&
              & .and. any(this%electronicSolver%iSolver ==&
              & [electronicSolverTypes%qr, electronicSolverTypes%divideandconquer,&
              & electronicSolverTypes%relativelyrobust, electronicSolverTypes%magma_gvd])) then
            call writeHSAndStop(env, this%tWriteHS, this%tWriteRealHS, this%tRealHS,&
                & this%ints%overlap, this%neighbourList, this%nNeighbourSK,&
                & this%denseDesc%iAtomStart, this%iSparseStart, this%img2CentCell, this%kPoint,&
                & this%iCellVec, this%cellVec, this%ints%hamiltonian, this%ints%iHamiltonian)
          end if

          call convertToUpDownRepr(this%ints%hamiltonian, this%ints%iHamiltonian)

          call getDensity(env, this%negfInt, iSccIter, this%denseDesc, this%ints,&
              & this%neighbourList, this%symNeighbourList, this%nNeighbourSk, this%iSparseStart,&
              & this%img2CentCell, this%iCellVec, this%cellVec, this%kPoint, this%kWeight,&
              & this%orb, this%tHelical, this%coord, this%species, this%electronicSolver,&
              & this%rCellVec, this%latVec, this%invLatVec, this%tPeriodic, this%tRealHS,&
              & this%tSpinSharedEf, this%tSpinOrbit, this%tDualSpinOrbit, this%tFillKSep,&
              & this%tFixEf, this%tMulliken, this%iDistribFn, this%tempElec, this%nEl,&
              & this%parallelKS, this%Ef, this%mu, this%dftbEnergy(this%deltaDftb%iDeterminant),&
              & this%hybridXc, this%eigen, this%filling, this%rhoPrim, this%xi, this%orbitalL,&
              & this%HSqrReal, this%SSqrReal, this%eigvecsReal, this%iRhoPrim, this%HSqrCplx,&
              & this%SSqrCplx, this%eigvecsCplx, this%rhoSqrReal, this%densityMatrix,&
              & this%nNeighbourCam, this%nNeighbourCamSym, this%deltaDftb, this%apiCallBack,&
              & errStatus)
          if (errStatus%hasError()) call error(errStatus%message)

          if (this%tWriteBandDat) then
            if (this%deltaDftb%nDeterminant() == 1) then
              if (this%tMD .and. iGeoStep /= 0 .and. tWriteRestart) then
                ! the iGeoStep test is so that the initial step has a new file
                call writeBandOut(bandOut, this%eigen, this%filling, this%kWeight,&
                    & isFileAppended=this%mdOutput%bandStructure)
              else
                call writeBandOut(bandOut, this%eigen, this%filling, this%kWeight)
              end if
            else
              ! Multiple determinants
              if (this%tMD .and. iGeoStep /= 0 .and. tWriteRestart) then
                ! the iGeoStep test is so that the initial step has a new file
                call writeBandOut(this%deltaDftb%determinantName(this%deltaDftb%iDeterminant) //&
                    & '_' //  bandOut, this%eigen, this%filling, this%kWeight,&
                    & isFileAppended=this%mdOutput%bandStructure)
              else
                call writeBandOut(this%deltaDftb%determinantName(this%deltaDftb%iDeterminant) //&
                    & '_' //  bandOut, this%eigen, this%filling, this%kWeight)
              end if
            end if
          end if

          call processOutputCharges(env, this)

          ! Note: if XLBOMD is active, potential created with input charges is needed later,
          ! therefore it should not be overwritten here.
          if (.not. this%isXlbomd) then
            ! iteration is +1 as output potential in iteration 1 only available after solution of H
            call processPotentials(env, this, iSccIter+1, this%updateSccAfterDiag, this%qOutput,&
                & this%qBlockOut, this%qiBlockOut)
          end if

          call calcEnergies(env, this%scc, this%tblite, this%qOutput, this%q0, this%chargePerShell,&
              & this%multipoleOut, this%species, this%isExtField, this%isXlbomd, this%dftbU,&
              & this%tDualSpinOrbit, this%rhoPrim, this%H0, this%orb, this%neighbourList,&
              & this%nNeighbourSk, this%img2CentCell, this%iSparseStart, this%cellVol,&
              & this%extPressure, this%dftbEnergy(this%deltaDftb%iDeterminant)%TS, this%potential,&
              & this%dftbEnergy(this%deltaDftb%iDeterminant), this%thirdOrd, this%solvation,&
              & this%hybridXc, this%reks, this%qDepExtPot, this%qBlockOut, this%qiBlockOut,&
              & this%xi, this%iAtInCentralRegion, this%tFixEf, this%Ef, this%tRealHS,&
              & this%onSiteElements, errStatus, qNetAtom=this%qNetAtom,&
              & vOnSiteAtomInt=this%potential%intOnSiteAtom,&
              & vOnSiteAtomExt=this%potential%extOnSiteAtom,&
              & densityMatrix=this%densityMatrix, kWeights=this%kWeight,&
              & localKS=this%parallelKS%localKS)
          if (errStatus%hasError()) call error(errStatus%message)

          if (allocated(this%elecConstraint)) then
            call sumEnergies(this%dftbEnergy(this%deltaDftb%iDeterminant))
            call this%elecConstraint%propagateConstraints(this%qOutput,&
                & this%dftbEnergy(this%deltaDftb%iDeterminant)%Eelec, constrConverged)
          else
            constrConverged = .true.
          end if

          if (allocated(this%elecConstraint)) then
            call printElecConstrInfo(this%elecConstraint, iConstrIter,&
                & this%dftbEnergy(this%deltaDftb%iDeterminant)%Eelec)
          end if

          if (constrConverged) exit lpConstrInner

        end do lpConstrInner

        call processScc(env, this, iGeoStep, iSccIter, sccErrorQ, tConverged, eOld, diffElec,&
            & tStopScc, errStatus)
        if (errStatus%hasError()) call error(errStatus%message)

        if (allocated(this%dispersion) .and. .not. tConverged) then
          call this%dispersion%updateOnsiteCharges(this%qNetAtom, this%orb, this%referenceN0,&
              & this%species0, tConverged)
          call calcDispersionEnergy(this%dispersion,&
              & this%dftbEnergy(this%deltaDftb%iDeterminant)%atomDisp,&
              & this%dftbEnergy(this%deltaDftb%iDeterminant)%Edisp, this%iAtInCentralRegion)
        end if
        call sumEnergies(this%dftbEnergy(this%deltaDftb%iDeterminant))

        call sccLoopWriting(this, iGeoStep, iLatGeoStep, iSccIter, diffElec, sccErrorQ)

        if (tConverged .or. tStopScc) exit lpSCC

      end do lpSCC

    end if REKS_SCC

  #:if WITH_SCALAPACK
    if (this%isSparseReorderRequired) then
      if (allocated(this%eigvecsReal)) then
        do iKS = 1, this%parallelKS%nLocalKS
          call blacsfx_gemr2d(this%denseDesc%nOrb, this%denseDesc%nOrb,&
              & this%eigvecsReal(:,:,iKS), 1, 1, this%denseDesc%blacsOrbSqr,&
              & this%eigVecsRealReordered(:,:,iKS), 1, 1, this%denseDesc%blacsColumnSqr,&
              & env%blacs%orbitalGrid%ctxt)
        end do
      else if (allocated(this%eigvecsCplx)) then
        do iKS = 1, this%parallelKS%nLocalKS
          call blacsfx_gemr2d(this%denseDesc%nOrb, this%denseDesc%nOrb,&
              & this%eigvecsCplx(:,:,iKS), 1, 1, this%denseDesc%blacsOrbSqr,&
              & this%eigVecsCplxReordered(:,:,iKS), 1, 1, this%denseDesc%blacsColumnSqr,&
              & env%blacs%orbitalGrid%ctxt)
        end do
      end if
    end if
  #:endif

    if (allocated(this%dispersion) .and. .not.allocated(this%reks)) then
      ! If we get to this point for a dispersion model, if it is charge dependent it may require
      ! evaluation post-hoc if SCC was not achieved but the input settings are to proceed with
      ! non-converged SCC.
      call this%dispersion%updateOnsiteCharges(this%qNetAtom, this%orb, this%referenceN0,&
          & this%species0, tConverged .or. .not. this%isSccConvRequired)
      call calcDispersionEnergy(this%dispersion,&
          & this%dftbEnergy(this%deltaDftb%iDeterminant)%atomDisp,&
          & this%dftbEnergy(this%deltaDftb%iDeterminant)%Edisp,&
          & this%iAtInCentralRegion)
      call sumEnergies(this%dftbEnergy(this%deltaDftb%iDeterminant))
    end if

    if (this%tWriteDetailedOut .and. this%deltaDftb%nDeterminant() == 1) then
      call closeFile(this%fdDetailedOut)
      call openOutputFile(userOut, tAppendDetailedOut, this%fdDetailedOut)
      if (allocated(this%reks)) then
        call writeReksDetailedOut1(this%fdDetailedOut%unit, this%nGeoSteps, iGeoStep, this%tMD,&
            & this%tDerivs, this%tCoordOpt, this%tLatOpt, iLatGeoStep, iSccIter,&
            & this%dftbEnergy(1), diffElec, sccErrorQ, this%indMovedAtom, this%pCoord0Out,&
            & this%q0, this%qOutput, this%orb, this%species, this%tPrintMulliken,&
            & this%extPressure, this%cellVol, this%tAtomicEnergy, this%dispersion, this%tPeriodic,&
            & this%tSccCalc, this%invLatVec, this%kPoint, this%iAtInCentralRegion,&
            & this%electronicSolver, this%reks, allocated(this%thirdOrd), this%isHybridXc,&
            & qNetAtom=this%qNetAtom)
      else
        call writeDetailedOut1(this%fdDetailedOut%unit, this%iDistribFn, this%nGeoSteps,&
            & iGeoStep, this%tMD, this%tDerivs, this%tCoordOpt, this%tLatOpt, iLatGeoStep,&
            & iSccIter, this%dftbEnergy(this%deltaDftb%iDeterminant), diffElec, sccErrorQ,&
            & this%indMovedAtom, this%pCoord0Out, this%tPeriodic, this%tSccCalc, this%tNegf,&
            & this%invLatVec, this%kPoint)
        call writeDetailedOut2(this%fdDetailedOut%unit, this%q0, this%qOutput, this%orb,&
            & this%species, allocated(this%dftbU), this%tImHam.or.this%tSpinOrbit,&
            & this%tPrintMulliken, this%orbitalL, this%qBlockOut, this%nSpin,&
            & allocated(this%onSiteElements), this%iAtInCentralRegion, this%cm5Cont, this%qNetAtom)
        call writeDetailedOut3(this%fdDetailedOut%unit, this%qInput, this%qOutput,&
            & this%dftbEnergy(this%deltaDftb%iDeterminant), this%species, allocated(this%dftbU),&
            & this%tPrintMulliken, this%Ef, this%extPressure, this%cellVol, this%tAtomicEnergy,&
            & this%dispersion, allocated(this%eField), this%tPeriodic, this%nSpin, this%tSpin,&
            & this%tSpinOrbit, this%tSccCalc, allocated(this%onSiteElements),&
            & this%iAtInCentralRegion, this%electronicSolver, allocated(this%halogenXCorrection),&
            & this%isHybridXc, allocated(this%thirdOrd), allocated(this%solvation))
      end if
    end if

    call env%globalTimer%stopTimer(globalTimers%scc)

    if (allocated(this%scc)) then
      call this%scc%finishSccLoop(env)
    end if

    if (allocated(this%dispersion)) then
      if (.not. this%dispersion%energyAvailable()) then
        call warning("Dispersion contributions are not included in the energy")
      end if
    end if

    if (allocated(this%elecConstraint)) then
      if (.not. constrConverged) then
        call warning("Constraints did NOT converge, maximal micro-iterations exceeded")
        if (this%elecConstraint%isConstrConvRequired) then
          call env%shutdown()
        end if
      end if
    end if

    call env%globalTimer%startTimer(globalTimers%eigvecWriting)
    if (this%tPrintEigVecs) then
      call writeEigenvectors(env, this%runId, this%neighbourList, this%nNeighbourSk, this%cellVec,&
          & this%iCellVec, this%denseDesc, this%iSparseStart, this%img2CentCell, this%species,&
          & this%speciesName, this%orb, this%kPoint, this%ints%overlap, this%parallelKS,&
          & this%tPrintEigvecsTxt, this%eigvecsReal, this%SSqrReal, this%eigvecsCplx, this%SSqrCplx)
    end if

    if (this%tProjEigenvecs) then
      call writeProjectedEigenvectors(env, this%regionLabels, this%eigen, this%neighbourList,&
          & this%nNeighbourSk, this%cellVec, this%iCellVec, this%denseDesc, this%iSparseStart,&
          & this%img2CentCell, this%orb, this%ints%overlap, this%kPoint, this%kWeight,&
          & this%iOrbRegion, this%parallelKS, this%eigvecsReal, this%SSqrReal, this%eigvecsCplx,&
          & this%SSqrCplx)
    end if
    call env%globalTimer%stopTimer(globalTimers%eigvecWriting)

    if (this%tSccCalc .and. .not. this%isXlbomd .and. .not. tConverged&
        & .and. .not. this%tRestartNoSC) then
      block
        character(len=*), parameter :: msg = "SCC is NOT converged, maximal SCC iterations exceeded"
        if (this%isSccConvRequired) then
          call error(msg)
        else
          call warning(msg)
        end if
      end block
    end if

    call env%globalTimer%startTimer(globalTimers%postSCC)

    if (this%isLinResp) then
      call env%globalTimer%startTimer(globalTimers%lrExcitation)
      call calculateLinRespExcitations(env, this%linearResponse, this%parallelKS, this%scc,&
          & this%qOutput, this%q0, this%ints, this%eigvecsReal, this%eigen(:,1,:),&
          & this%filling(:,1,:), this%coord, this%species, this%speciesName, this%orb,&
          & this%skHamCont, this%skOverCont, autotestTag, this%taggedWriter, this%runId,&
          & this%neighbourList, this%nNeighbourSK, this%denseDesc, this%iSparseStart,&
          & this%img2CentCell, this%tWriteAutotest, this%tCasidaForces, this%tLinRespZVect,&
          & this%tPrintExcitedEigvecs, this%tPrintEigvecsTxt, this%nonSccDeriv,&
          & this%dftbEnergy(1), this%energiesCasida, this%SSqrReal, this%rhoSqrReal,&
          & this%densityMatrix%deltaRhoOut, this%excitedDerivs, this%naCouplings, this%occNatural,&
          & this%hybridXc)
      call env%globalTimer%stopTimer(globalTimers%lrExcitation)  
    end if

    if (allocated(this%ppRPA)) then
      call unpackHS(this%SSqrReal, this%ints%overlap, this%neighbourList%iNeighbour,&
          & this%nNeighbourSK, this%denseDesc%iAtomStart, this%iSparseStart, this%img2CentCell)
      call adjointLowerTriangle(this%SSqrReal)
      if (withMpi) then
        call error("pp-RPA calc. does not work with MPI yet")
      end if
      call ppRPAenergies(this%ppRPA, env, this%denseDesc, this%eigvecsReal, this%eigen(:,1,:),&
          & this%scc, this%SSqrReal, this%species0, this%nEl(1), this%neighbourList%iNeighbour,&
          & this%img2CentCell, this%orb, this%tWriteAutotest, autotestTag, this%taggedWriter)
    end if

    if (this%isXlbomd) then
      call getXlbomdCharges(this%xlbomdIntegrator, this%qOutRed, this%pChrgMixerReal, this%orb,&
          & this%nIneqOrb, this%iEqOrbitals, this%qInput, this%qInpRed, this%dftbU,&
          & this%iEqBlockDftbU, this%qBlockIn, this%species0, this%iEqBlockDftbuLs, this%qiBlockIn,&
          & this%iEqBlockOnSite, this%iEqBlockOnSiteLS)
    end if

    if (this%tDipole .and. .not. allocated(this%reks) .and. .not. this%tRestartNoSC) then
      call getDipoleMoment(this%qOutput, this%q0, this%multipoleOut%dipoleAtom, this%coord0,&
          & this%dipoleMoment(:,this%deltaDftb%iDeterminant), this%iAtInCentralRegion)
    #:block DEBUG_CODE
      call checkDipoleViaHellmannFeynman(env, this%rhoPrim, this%q0, this%coord0, this%ints,&
          & this%orb, this%neighbourList, this%nNeighbourSk, this%species, this%iSparseStart,&
          & this%img2CentCell, this%eFieldScaling, this%hamiltonianType, this%nDipole)
    #:endblock DEBUG_CODE
    end if

    ! MD geometry files are written only later, once velocities for the current geometry are known
    if ((this%isGeoOpt .or. allocated(this%geoOpt)) .and. tWriteRestart) then
      if (.not. (this%deltaDftb%isSpinPurify .and.&
          & this%deltaDftb%iDeterminant == determinants%triplet)) then
        call writeCurrentGeometry(this%geoOutFile, this%pCoord0Out, this%tLatOpt, this%tMd,&
            & this%tAppendGeo.and.iGeoStep>0, this%tFracCoord, this%tPeriodic, this%tHelical,&
            & this%tPrintMulliken, this%species0, this%speciesName, this%latVec, this%origin,&
            & iGeoStep, iLatGeoStep, this%nSpin, this%qOutput, this%velocities)
      endif
    end if

    if (this%tForces) then
      call env%globalTimer%startTimer(globalTimers%forceCalc)
      if (allocated(this%reks)) then
        call getReksGradients(env, this%denseDesc, this%scc, this%hybridXc, this%dispersion,&
            & this%neighbourList, this%nNeighbourSK, this%iSparseStart, this%img2CentCell,&
            & this%orb, this%nonSccDeriv, this%skHamCont, this%skOverCont, this%repulsive,&
            & this%coord, this%coord0, this%species, this%q0, this%eigvecsReal,&
            & this%chrgForces, this%ints%overlap, this%spinW, this%derivs, this%tWriteAutotest,&
            & autotestTag, this%taggedWriter, this%reks, errStatus,&
            & symNeighbourList=this%symNeighbourList, nNeighbourCamSym=this%nNeighbourCamSym)
        @:PROPAGATE_ERROR(errStatus)
        call getReksGradProperties(env, this%denseDesc, this%neighbourList, this%nNeighbourSK,&
            & this%iSparseStart, this%img2CentCell, this%eigvecsReal, this%orb,&
            & this%iAtInCentralRegion, this%coord, this%coord0, this%ints%overlap, this%rhoPrim,&
            & this%qOutput, this%q0, this%tDipole, dipoleTmp, this%chrgForces, this%reks)
        call assignDipoleMoment(dipoleTmp, this%dipoleMoment, this%deltaDftb%iDeterminant,&
            & this%tDipole, this%reks, isSingleState=.false.)
      else
        call env%globalTimer%startTimer(globalTimers%energyDensityMatrix)
        call getEnergyWeightedDensity(env, this%negfInt, this%electronicSolver, this%denseDesc,&
            & this%forceType, this%filling, this%eigen, this%kPoint, this%kWeight,&
            & this%neighbourList, this%nNeighbourSK, this%orb, this%iSparseStart,&
            & this%img2CentCell, this%iCellVec, this%cellVec, this%tRealHS, this%ints,&
            & this%parallelKS, this%tHelical, this%species, this%coord, iSccIter, this%mu,&
            & this%ERhoPrim, this%densityMatrix, this%eigvecsReal, this%SSqrReal, this%eigvecsCplx,&
            & this%SSqrCplx, errStatus)
        @:PROPAGATE_ERROR(errStatus)
        call env%globalTimer%stopTimer(globalTimers%energyDensityMatrix)
        call getGradients(env, this%parallelKS, this%boundaryCond, this%scc, this%tblite,&
            & this%isExtField, this%isXlbomd, this%nonSccDeriv, this%rhoPrim, this%ERhoPrim,&
            & this%qOutput, this%q0, this%skHamCont, this%skOverCont, this%repulsive,&
            & this%neighbourList, this%symNeighbourList, this%nNeighbourSk, this%nNeighbourCamSym,&
            & this%iCellVec, this%cellVec, this%rCellVec, this%invLatVec, this%species,&
            & this%img2CentCell, this%iSparseStart, this%orb, this%potential, this%coord,&
            & this%derivs, this%groundDerivs, this%tripletderivs, this%mixedderivs, this%iRhoPrim,&
            & this%thirdOrd, this%solvation, this%qDepExtPot, this%chrgForces, this%dispersion,&
            & this%hybridXc, this%SSqrReal, this%ints, this%denseDesc, this%halogenXCorrection,&
            & this%tHelical, this%coord0, this%deltaDftb, this%tPeriodic, this%tRealHS,&
            & this%kPoint, this%kWeight, this%densityMatrix, errStatus)
        @:PROPAGATE_ERROR(errStatus)
        if (this%isCIopt) then
          call conicalIntersectionOptimizer(this%derivs, this%excitedDerivs,&
              & this%linearResponse%indNACouplings, this%linearResponse%energyShiftCI,&
              & this%naCouplings, this%energiesCasida)
        else if (this%tCasidaForces) then
          this%derivs(:,:) = this%derivs + this%excitedDerivs(:,:,1)
        end if
      end if

      call env%globalTimer%stopTimer(globalTimers%forceCalc)

      call updateDerivsByPlumed(env, this%plumedCalc, iGeoStep, this%derivs,&
          & this%dftbEnergy(this%deltaDftb%iDeterminant)%EMermin, this%coord0, this%mass,&
          & this%tPeriodic, this%latVec)

      if (this%tStress) then
        call env%globalTimer%startTimer(globalTimers%stressCalc)
        if (allocated(this%reks)) then
          call getReksStress(env, this%denseDesc, this%scc, this%nonSccDeriv, this%skHamCont,&
              & this%skOverCont, this%repulsive, this%neighbourList, this%nNeighbourSk,&
              & this%species, this%img2CentCell, this%iSparseStart, this%orb,&
              & this%dispersion, this%coord, this%q0, this%invLatVec, this%cellVol,&
              & this%totalStress, this%totalLatDeriv, this%intPressure, this%reks)
        else
          call getStress(env, this%scc, this%tblite, this%thirdOrd, this%isExtField,&
              & this%nonSccDeriv, this%rhoPrim, this%ERhoPrim, this%qOutput, this%q0,&
              & this%skHamCont, this%skOverCont, this%repulsive, this%neighbourList,&
              & this%nNeighbourSk, this%species, this%img2CentCell, this%iSparseStart,&
              & this%orb, this%potential, this%coord, this%latVec, this%invLatVec,&
              & this%cellVol, this%coord0, this%totalStress, this%totalLatDeriv,&
              & this%intPressure, this%iRhoPrim, this%solvation, this%dispersion,&
              & this%halogenXCorrection, this%deltaDftb, this%tripletStress, this%mixedStress)
        end if
        call env%globalTimer%stopTimer(globalTimers%stressCalc)

      end if

    end if

    if (this%tWriteDetailedOut .and. this%deltaDftb%nDeterminant() == 1) then
      call writeDetailedOut4(this%fdDetailedOut%unit, this%tSccCalc,&
          & allocated(this%elecConstraint), tConverged, constrConverged, this%isXlbomd,&
          & this%isLinResp, this%isGeoOpt .or. allocated(this%geoOpt), this%tMD, this%tPrintForces,&
          & this%tStress, this%tPeriodic, this%dftbEnergy(this%deltaDftb%iDeterminant),&
          & this%totalStress, this%totalLatDeriv, this%derivs, this%chrgForces, this%indMovedAtom,&
          & this%cellVol, this%intPressure, this%geoOutFile, this%iAtInCentralRegion)
    end if

    if (this%tSccCalc .and. allocated(this%electrostatPot)&
        & .and. (.not. (this%isGeoOpt .or. allocated(this%geoOpt) .or. this%tMD)&
        & .or. needsRestartWriting(this%isGeoOpt .or. allocated(this%geoOpt), this%tMd,&
        & iGeoStep, this%nGeoSteps, this%restartFreq))) then
      call this%electrostatPot%evaluate(env, this%scc, this%eField)
      call writeEsp(this%electrostatPot, env, iGeoStep, this%nGeoSteps)
    end if

  end subroutine processGeometry


  !> Process geometry for constrains
  subroutine postprocessDerivs(derivs, conAtom, conVec, tLatOpt, totalLatDerivs, extLatDerivs,&
      & normLatVecs, tLatOptFixAng, tLatOptFixLen, tLatOptIsotropic, constrLatDerivs)

    !> On input energy derivatives, on exit resulting projected derivatives
    real(dp), intent(inout), allocatable :: derivs(:,:)

    !> Atoms being constrained
    integer, allocatable, intent(in) :: conAtom(:)

    !> Vector to project out forces
    real(dp), allocatable, intent(in) :: conVec(:,:)

    !> Whether lattice optimisation is on
    logical, intent(in) :: tLatOpt

    !> Derivative of total energy with respect to lattice vectors
    real(dp), intent(in) :: totalLatDerivs(:,:)

    !> Derivative of cell volume wrt to lattice vectors, needed for pV term
    real(dp), intent(in) :: extLatDerivs(:,:)

    !> Unit normals parallel to lattice vectors
    real(dp), intent(in) :: normLatVecs(:,:)

    !> Are the angles of the lattice being fixed during optimisation?
    logical, intent(in) :: tLatOptFixAng

    !> Are the magnitude of the lattice vectors fixed
    logical, intent(in) :: tLatOptFixLen(:)

    !> Is the optimisation isotropic
    logical, intent(in) :: tLatOptIsotropic

    !> Lattice vectors returned by the optimizer
    real(dp), intent(out) :: constrLatDerivs(:)

    if (allocated(conAtom)) then
      call constrainForces(conAtom, conVec, derivs)
    end if

    if (tLatOpt) then
      ! Only include the extLatDerivs contribution if not MD, as the barostat would otherwise
      ! take care of this, hence add it here rather than to totalLatDeriv itself
      call constrainLatticeDerivs(totalLatDerivs + extLatDerivs, normLatVecs, tLatOptFixAng,&
          & tLatOptFixLen, tLatOptIsotropic, constrLatDerivs)
    end if

  end subroutine postprocessDerivs


  !> Next geometry step from driver
  subroutine getNextGeometry(this, env, iGeoStep, tWriteRestart, constrLatDerivs,&
      & tCoordStep, tGeomEnd, tStopDriver, iLatGeoStep, tempIon, tExitGeoOpt)

    !> Global variables
    type(TDftbPlusMain), intent(inout) :: this

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Current geometry step
    integer, intent(in) :: iGeoStep

    !> Flag to write out geometries (and charge data if scc)
    logical, intent(in) :: tWriteRestart

    !> Lattice vectors returned by the optimizer
    real(dp), intent(in) :: constrLatDerivs(:)

    !> Do we take an optimization step on the lattice or the internal coordinates if optimizing both
    !> in a periodic geometry
    logical, intent(inout) :: tCoordStep

    !> Do we have the final geometry?
    logical, intent(inout) :: tGeomEnd

    !> If geometry driver should be stopped
    logical, intent(inout) :: tStopDriver

    !> Current lattice step
    integer, intent(inout) :: iLatGeoStep

    !> MD instantaneous thermal energy
    real(dp), intent(out) :: tempIon

    !> Whether geometry optimisation should be stop
    logical, intent(out) :: tExitGeoOpt


    !> Difference between last calculated and new geometry.
    real(dp) :: diffGeo

    !> Has this completed?
    logical :: tCoordEnd, converged

    ! initially assume that coordinates and lattice vectors won't be updated
    this%tCoordsChanged = .false.
    this%tLatticeChanged = .false.

    tExitGeoOpt = .false.
    if (this%tDerivs) then
      call getNextDerivStep(this%derivDriver, this%derivs, this%indMovedAtom, &
           & this%indDerivAtom, this%coord0, tGeomEnd)
      if (tGeomEnd) then
        call env%globalTimer%stopTimer(globalTimers%postSCC)
        tExitGeoOpt = .true.
        return
      end if
      this%tCoordsChanged = .true.
    else if (allocated(this%geoOpt)) then
      block
        real(dp) :: energy, ediff, dnorm, damax, gnorm, gamax
        logical :: econv, dconv, gconv

        dnorm = norm2(this%displ)
        damax = maxval(abs(this%displ))

        call this%filter%transformDerivative(this%coord0, this%latVec, &
            & this%derivs, this%totalStress, this%gcurr)
        call this%geoOpt%step(this%dftbEnergy(this%deltaDftb%iFinal)%Emermin, &
            & this%gcurr, this%displ)
        call this%filter%transformStructure(this%coord0, this%latVec, this%displ)

        energy = this%dftbEnergy(this%deltaDftb%iFinal)%Emermin
        ediff = energy - this%elast
        gnorm = norm2(this%gcurr)
        gamax = maxval(abs(this%gcurr))
        write(stdOut, '(a)') stepSummary(energy, ediff, gnorm, gamax, dnorm, damax, 2)

        econv = ediff <= epsilon(0.0_dp) .and. abs(ediff) < this%optTol%energy
        dconv = dnorm / this%filter%nvar < this%optTol%dispNorm .and. damax < this%optTol%dispElem
        gconv = gnorm / this%filter%nvar < this%optTol%gradNorm .and. gamax < this%optTol%gradElem
        converged = econv .and. gconv .and. dconv
      end block

      this%elast = this%dftbEnergy(this%deltaDftb%iFinal)%Emermin

      if (tGeomEnd) then
        call env%globalTimer%stopTimer(globalTimers%postSCC)
        tExitGeoOpt = .true.
        return
      end if
      tGeomEnd = converged
      this%tCoordsChanged = .true.
      this%tLatticeChanged = this%tPeriodic .and. this%filter%lattice
    else if (this%isGeoOpt) then
      this%tCoordsChanged = .true.
      if (tCoordStep) then
        call getNextCoordinateOptStep(this%pGeoCoordOpt, this%dftbEnergy(this%deltaDftb%iFinal),&
            & this%derivs, this%indMovedAtom, this%coord0, diffGeo, tCoordEnd,&
            & .not. this%tCasidaForces)
        if (.not. this%tLatOpt) then
          tGeomEnd = tCoordEnd
        end if
        if (.not. tGeomEnd .and. tCoordEnd .and. diffGeo < tolSameDist) then
          tCoordStep = .false.
        end if
      else
        call getNextLatticeOptStep(this%pGeoLatOpt, this%dftbEnergy(this%deltaDftb%iFinal),&
            & constrLatDerivs, this%origLatVec, this%tLatOptFixAng, this%tLatOptFixLen,&
            & this%tLatOptIsotropic, this%indMovedAtom, this%latVec, this%coord0, diffGeo, tGeomEnd)
        iLatGeoStep = iLatGeoStep + 1
        this%tLatticeChanged = .true.
        if (.not. tGeomEnd .and. this%tCoordOpt) then
          tCoordStep = .true.
          call reset(this%pGeoCoordOpt,&
              & reshape(this%coord0(:, this%indMovedAtom), [this%nMovedCoord]))
        end if
      end if
      if (tGeomEnd .and. diffGeo < tolSameDist) then
        call env%globalTimer%stopTimer(globalTimers%postSCC)
        tExitGeoOpt = .true.
        return
      end if
    else if (this%tMD) then
      ! New MD coordinates saved in a temporary variable, as writeCurrentGeometry() below
      ! needs the old ones to write out consistent geometries and velocities.
      this%newCoords(:,:) = this%coord0
      call getNextMdStep(this%pMdIntegrator, this%pMdFrame, this%temperatureProfile, this%derivs,&
          & this%movedMass, this%mass, this%cellVol, this%invLatVec, this%species0,&
          & this%indMovedAtom, this%tStress, this%tBarostat,&
          & this%dftbEnergy(this%deltaDftb%iFinal), this%newCoords, this%latVec,&
          & this%intPressure, this%totalStress, this%totalLatDeriv, this%velocities, tempIon)
      this%tCoordsChanged = .true.
      this%tLatticeChanged = this%tBarostat
      call printMdInfo(this%tSetFillingTemp, this%eField, this%tPeriodic, this%tempElec,&
          & tempIon, this%intPressure, this%extPressure,&
          & this%dftbEnergy(this%deltaDftb%iFinal))
      if (tWriteRestart) then
        if (this%tPeriodic) then
          this%cellVol = abs(determinant33(this%latVec))
          this%dftbEnergy(this%deltaDftb%iFinal)%EGibbs =&
              & this%dftbEnergy(this%deltaDftb%iFinal)%EMermin&
              & + this%extPressure * this%cellVol
        end if
        call writeMdOut2(this%fdMd%unit, this%tPeriodic, this%tPrintForces, this%tStress,&
            & this%tBarostat, this%isLinResp, this%eField, this%tFixEf, this%tPrintMulliken,&
            & this%dftbEnergy, this%energiesCasida, this%latVec, this%derivs, this%totalStress,&
            & this%cellVol, this%intPressure, this%extPressure, tempIon, this%qOutput, this%q0,&
            & this%dipoleMoment, this%eFieldScaling, this%dipoleMessage, this%electronicSolver,&
            & this%deltaDftb, this%mdOutput)
        call writeCurrentGeometry(this%geoOutFile, this%pCoord0Out, .false., .true., .true.,&
            & this%tFracCoord, this%tPeriodic, this%tHelical, this%tPrintMulliken, this%species0,&
            & this%speciesName, this%latVec, this%origin, iGeoStep, iLatGeoStep, this%nSpin,&
            & this%qOutput, this%velocities)
      end if
      this%coord0(:,:) = this%newCoords
      if (this%tWriteDetailedOut  .and. this%deltaDftb%nDeterminant() == 1) then
        call writeDetailedOut5(this%fdDetailedOut%unit, this%tPrintForces, this%tSetFillingTemp,&
            & this%tPeriodic, this%tStress, this%totalStress, this%totalLatDeriv,&
            & this%dftbEnergy(this%deltaDftb%iFinal), this%tempElec, this%extPressure,&
            & this%intPressure, tempIon)
      end if
    else if (this%tSocket .and. iGeoStep < this%nGeoSteps) then
      ! Only receive geometry from socket, if there are still geometry iterations left
    #:if WITH_SOCKETS
      call receiveGeometryFromSocket(env, this%socket, this%tPeriodic, this%coord0, this%latVec,&
          & this%tCoordsChanged, this%tLatticeChanged, tStopDriver)
    #:else
      call error("Internal error: code compiled without socket support")
    #:endif
    end if

  end subroutine getNextGeometry


  function stepSummary(energy, ediff, gnorm, gamax, dnorm, damax, prlevel) result(str)
    real(dp), intent(in) :: energy, ediff, gnorm, gamax, dnorm, damax
    integer, intent(in) :: prlevel
    character(len=:), allocatable :: str
    character(len=*), parameter :: nl = new_line('a')

    str = ""
    if (prlevel <= 0) return

    if (prlevel > 1) then
      str = str//nl//"total energy  "//format_string(energy, '(es14.7)')//" H    "//&
        &            "   energy change "//format_string(ediff, '(es14.7)')//" H"
      str = str//nl//"gradient norm "//format_string(gnorm, '(es14.7)')//" H/a0 "//&
        &            "   max. gradient "//format_string(gamax, '(es14.7)')//" H/a0"
      str = str//nl//"step length   "//format_string(dnorm, '(es14.7)')//" a0   "//&
        &            "   max. step     "//format_string(damax, '(es14.7)')//" a0"
    else
      str = str//nl//"total energy  "//format_string(energy, '(es14.7)')//" H"
    end if

  contains
    function format_string(val, format) result(str)
      real(dp), intent(in) :: val
      character(len=*), intent(in) :: format
      character(len=:), allocatable :: str

      character(len=128) :: buffer
      integer :: stat

      write(buffer, format, iostat=stat) val
      if (stat == 0) then
        str = trim(buffer)
      else
        str = "*"
      end if
    end function format_string
  end function stepSummary

  !> Initialises some parameters before geometry loop starts.
  subroutine initGeoOptParameters(tCoordOpt, nGeoSteps, tGeomEnd, tCoordStep, tStopDriver,&
      & iGeoStep, iLatGeoStep)

    !> Are atomic coordinates changing
    logical, intent(in) :: tCoordOpt

    !> Number of geometry steps
    integer, intent(in) :: nGeoSteps

    !> Have the geometry changes terminated
    logical, intent(out) :: tGeomEnd

    !> Are the atomic coordinates changing
    logical, intent(out) :: tCoordStep

    !> Should the geometry driver stop
    logical, intent(out) :: tStopDriver

    !> Step of the geometry driver
    integer, intent(out) :: iGeoStep

    !> Number of steps changing the lattice vectors
    integer, intent(out) :: iLatGeoStep

    tGeomEnd = (nGeoSteps == 0)

    tCoordStep = .false.
    if (tCoordOpt) then
      tCoordStep = .true.
    end if
    tStopDriver = .false.

    iGeoStep = 0
    iLatGeoStep = 0

  end subroutine initGeoOptParameters


  !> Does the operations that are necessary after a lattice vector update
  subroutine handleLatticeChange(latVecs, sccCalc, tblite, tStress, extPressure, mCutOff,&
      & repulsive, dispersion, solvation, cm5Cont, recVecs, recVecs2p, cellVol, recCellVol,&
      & extLatDerivs, cellVecs, rCellVecs, boundaryCond)

    !> Lattice vectors
    real(dp), intent(in) :: latVecs(:,:)

    !> Module variables
    type(TScc), allocatable, intent(inout) :: sccCalc

    !> Library interface handler
    type(TTBLite), allocatable, intent(inout) :: tblite

    !> Evaluate stress
    logical, intent(in) :: tStress

    !> External pressure
    real(dp), intent(in) :: extPressure

    !> Maximum distance for interactions
    real(dp), intent(inout) :: mCutOff

    !> Repulsive interaction
    class(TRepulsive), allocatable, intent(inout) :: repulsive

    !> Dispersion interactions object
    class(TDispersionIface), allocatable, intent(inout) :: dispersion

    !> Solvation model
    class(TSolvation), allocatable, intent(inout) :: solvation

    !> Charge model 5
    type(TChargeModel5), allocatable, intent(inout) :: cm5Cont

    !> Reciprocal lattice vectors
    real(dp), intent(out) :: recVecs(:,:)

    !> Reciprocal lattice vectors in units of 2 pi
    real(dp), intent(out) :: recVecs2p(:,:)

    !> Unit cell volume
    real(dp), intent(out) :: cellVol

    !> Reciprocal lattice unit cell volume
    real(dp), intent(out) :: recCellVol

    !> Derivative of pV term
    real(dp), intent(out) :: extLatDerivs(:,:)

    !> Translation vectors to lattice cells in units of lattice constants
    real(dp), allocatable, intent(out) :: cellVecs(:,:)

    !> Vectors to unit cells in absolute units
    real(dp), allocatable, intent(out) :: rCellVecs(:,:)

    !> Boundary conditions on the calculation
    type(TBoundaryConditions), intent(in) :: boundaryCond

    cellVol = abs(determinant33(latVecs))
    recVecs2p(:,:) = latVecs
    call matinv(recVecs2p)
    recVecs2p = transpose(recVecs2p)
    recVecs = 2.0_dp * pi * recVecs2p
    recCellVol = abs(determinant33(recVecs))
    if (tStress) then
      call derivDeterminant33(extLatDerivs, latVecs)
      extLatDerivs(:,:) = extPressure * extLatDerivs
    end if
    if (allocated(sccCalc)) then
      call sccCalc%updateLatVecs(latVecs, recVecs, boundaryCond, cellVol)
      mCutOff = max(mCutOff, sccCalc%getCutOff())
    end if
    if (allocated(tblite)) then
      call tblite%updateLatVecs(latVecs)
      mCutOff = max(mCutOff, tblite%getRCutOff())
    end if
    if (allocated(repulsive)) then
      call repulsive%updateLatVecs(latVecs)
    end if
    if (allocated(dispersion)) then
      call dispersion%updateLatVecs(latVecs)
      mCutOff = max(mCutOff, dispersion%getRCutOff())
    end if
    if (allocated(solvation)) then
      call solvation%updateLatVecs(latVecs)
      mCutOff = max(mCutOff, solvation%getRCutOff())
    end if
    if (allocated(cm5Cont)) then
       call cm5Cont%updateLatVecs(latVecs)
       mCutoff = max(mCutOff, cm5Cont%getRCutOff())
    end if
    call getCellTranslations(cellVecs, rCellVecs, latVecs, recVecs2p, mCutOff)

  end subroutine handleLatticeChange


  !> Does the operations that are necessary after atomic coordinates change
  subroutine handleCoordinateChange(env, boundaryCond, coord0, latVec, invLatVec, species0, cutOff,&
      & orb, tPeriodic, tRealHS, tHelical, sccCalc, tblite, repulsive, dispersion, solvation,&
      & thirdOrd, hybridXc, reks, img2CentCell, iCellVec, neighbourList, symNeighbourList,&
      & nAllAtom, coord0Fold, coord, species, cellVec, rCellVec, denseDescr, nNeighbourSK,&
      & nNeighbourCam, nNeighbourCamSym, ints, H0, rhoPrim, iRhoPrim, ERhoPrim, iSparseStart,&
      & cm5Cont, skOverCont, errStatus)

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> Boundary conditions on the calculation
    type(TBoundaryConditions), intent(in) :: boundaryCond

    !> Central cell coordinates
    real(dp), intent(in) :: coord0(:,:)

    !> Lattice vectors if periodic
    real(dp), intent(in) :: latVec(:,:)

    !> Inverse of the lattice vectors
    real(dp), intent(in) :: invLatVec(:,:)

    !> Chemical species of central cell atoms
    integer, intent(in) :: species0(:)

    !> Longest cut-off distances that neighbour maps are generated for
    type(TCutoffs), intent(in) :: cutOff

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Is the geometry periodic
    logical, intent(in) :: tPeriodic

    !> Is the hamiltonian real (no k-points/molecule/gamma point)?
    logical, intent(in) :: tRealHS

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> SCC module internal variables
    type(TScc), allocatable, intent(inout) :: sccCalc

    !> Library interface handler
    type(TTBLite), allocatable, intent(inout) :: tblite

    !> Repulsive
    class(TRepulsive), allocatable, intent(inout) :: repulsive

    !> Dispersion interactions
    class(TDispersionIface), allocatable, intent(inout) :: dispersion

    !> Solvation model
    class(TSolvation), allocatable, intent(inout) :: solvation

    !> Third order SCC interactions
    type(TThirdOrder), allocatable, intent(inout) :: thirdOrd

    !> Range separation contributions
    class(THybridXcFunc), allocatable, intent(inout) :: hybridXc

    !> Data type for REKS
    type(TReksCalc), allocatable, intent(inout) :: reks

    !> Image atoms to their equivalent in the central cell
    integer, allocatable, intent(inout) :: img2CentCell(:)

    !> Index for which unit cell an atom is in
    integer, allocatable, intent(inout) :: iCellVec(:)

    !> List of neighbouring atoms
    type(TNeighbourList), intent(inout) :: neighbourList

    !> List of neighbouring atoms (symmetric version)
    type(TSymNeighbourList), intent(inout), allocatable :: symNeighbourList

    !> Total number of atoms including images
    integer, intent(out) :: nAllAtom

    !> Central cell atomic coordinates, folded inside the central cell
    real(dp), intent(out) :: coord0Fold(:,:)

    !> Coordinates of all atoms including images
    real(dp), allocatable, intent(inout) :: coord(:,:)

    !> Species of all atoms including images
    integer, allocatable, intent(inout) :: species(:)

    !> Vectors to units cells in relative units
    real(dp), allocatable, intent(in) :: cellVec(:,:)

    !> Vectors to units cells in absolute units
    real(dp), allocatable, intent(in) :: rCellVec(:,:)

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDescr

    !> Number of neighbours of each real atom
    integer, intent(out) :: nNeighbourSK(:)

    !> Number of neighbours for each of the atoms for the exchange contributions of CAM functionals
    integer, intent(inout), allocatable :: nNeighbourCam(:)

    !> Symmetric neighbour list version of nNeighbourCam
    integer, intent(inout), allocatable :: nNeighbourCamSym(:)

    !> Integral container
    type(TIntegral), intent(inout) :: ints

    !> Non-SCC hamiltonian storage
    real(dp), allocatable, intent(inout) :: h0(:)

    !> Sparse density matrix storage
    real(dp), allocatable, intent(inout) :: rhoPrim(:,:)

    !> Imaginary part of sparse density matrix storage
    real(dp), allocatable, intent(inout) :: iRhoPrim(:,:)

    !> Energy weighted density matrix storage
    real(dp), allocatable, intent(inout) :: ERhoPrim(:)

    !> Index array for location of atomic blocks in large sparse arrays
    integer, allocatable, intent(inout) :: iSparseStart(:,:)

    !> Charge model 5
    type(TChargeModel5), allocatable, intent(inout) :: cm5Cont

    !> Sparse overlap part
    type(TSlakoCont), intent(in) :: skOverCont

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    !> Total size of orbitals in the sparse data structures, where the decay of the overlap sets the
    !> sparsity pattern
    integer :: sparseSize

    coord0Fold(:,:) = coord0

    call boundaryCond%foldCoordsToCell(coord0Fold, latVec)

    if (tHelical) then
      call updateNeighbourListAndSpecies(env, coord, species, img2CentCell, iCellVec,&
          & neighbourList, nAllAtom, coord0Fold, species0, cutoff%mCutoff, rCellVec,&
          & errStatus, helicalBoundConds=latVec)
    else
      call updateNeighbourListAndSpecies(env, coord, species, img2CentCell, iCellVec,&
          & neighbourList, nAllAtom, coord0Fold, species0, cutoff%mCutOff, rCellVec, errStatus)
    end if
    @:PROPAGATE_ERROR(errStatus)

    call getNrOfNeighboursForAll(nNeighbourSK, neighbourList, cutoff%skCutOff)

    call getSparseDescriptor(neighbourList%iNeighbour, nNeighbourSK, img2CentCell, orb,&
        & iSparseStart, sparseSize)
    call reallocateSparseArrays(sparseSize, reks, ints, H0, rhoPrim, iRhoPrim, ERhoPrim)

    if (allocated(nNeighbourCam)) then
      ! count neighbours for CAM interactions (for non-symmetric neighbour list)
      call getNrOfNeighboursForAll(nNeighbourCam, neighbourList, cutoff%camCutOff)
    end if

    if (allocated(symNeighbourList)) then
      call updateNeighbourListAndSpecies(env, symNeighbourList%coord, symNeighbourList%species,&
          & symNeighbourList%img2CentCell, symNeighbourList%iCellVec,&
          & symNeighbourList%neighbourList, symNeighbourList%nAllAtom, coord0Fold, species0,&
          & cutoff%camCutOff, rCellVec, errStatus, symmetric=.true.)
      if (allocated(nNeighbourCamSym)) then
        ! count neighbours for CAM interactions (for symmetric neighbour list)
        call getNrOfNeighboursForAll(nNeighbourCamSym, symNeighbourList%neighbourList,&
            & cutoff%camCutOff)
        call getSparseDescriptor(symNeighbourList%neighbourList%iNeighbour, nNeighbourCamSym,&
            & symNeighbourList%img2CentCell, orb, symNeighbourList%iPair,&
            & symNeighbourList%sparseSize)
      end if
    end if

    if (allocated(sccCalc)) then
      call sccCalc%updateCoords(env, coord0, coord, species, neighbourList)
    end if

    if (allocated(tblite)) then
      call tblite%updateCoords(env, neighbourList, img2CentCell, coord, species)
    end if

    if (allocated(repulsive)) then
      call repulsive%updateCoords(coord, species, img2CentCell, neighbourList)
    end if

    if (allocated(dispersion)) then
      call dispersion%updateCoords(env, neighbourList, img2CentCell, coord, species0, errStatus)
      @:PROPAGATE_ERROR(errStatus)
    end if
    if (allocated(solvation)) then
      call solvation%updateCoords(env, neighbourList, img2CentCell, coord, species0)
    end if
    if (allocated(thirdOrd)) then
      call thirdOrd%updateCoords(neighbourList, species)
    end if
    if (allocated(hybridXc)) then
      if (.not. tPeriodic) then
        call hybridXc%updateCoords_cluster(coord)
      elseif (tPeriodic .and. tRealHS) then
        call hybridXc%updateCoords_gamma(env, symNeighbourList, nNeighbourCamSym, skOverCont, orb,&
            & latVec, invLatVec, denseDescr%iAtomStart)
      elseif (.not. tRealHS) then
        call hybridXc%updateCoords_kpts(env, symNeighbourList, nNeighbourCamSym, skOverCont, orb,&
            & latVec, invLatVec, denseDescr%iAtomStart)
      end if
    end if
    if (allocated(cm5Cont)) then
       call cm5Cont%updateCoords(neighbourList, img2CentCell, coord, species)
    end if

  end subroutine handleCoordinateChange


#:if WITH_TRANSPORT

  !> Initialise transport
  subroutine setupNegfStuff(negfInt, denseDescr, transpar, ginfo, neighbourList, nNeighbourSK,&
      & img2CentCell, orb)

    !> NEGF interface
    type(TNegfInt), intent(inout) :: negfInt

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDescr

    !> Transport settings
    type(TTransPar), intent(in) :: transpar

    !> libNEGF data
    type(TNEGFInfo), intent(in) :: ginfo

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Image atoms to their equivalent in the central cell
    integer, intent(in) :: img2CentCell(:)

    !> List of neighbouring atoms
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours of each real atom
    integer, intent(in) :: nNeighbourSK(:)

    ! known issue about the PLs: We need an automatic partitioning
    call negfInt%setup_csr(denseDescr%iAtomStart, neighbourList%iNeighbour, nNeighbourSK,&
        & img2CentCell, orb)

    call negfInt%setup_str(denseDescr, transpar, ginfo%greendens, neighbourList%iNeighbour,&
        & nNeighbourSK, img2CentCell)

    call negfInt%setup_dephasing(ginfo%tundos)  !? why tundos

  end subroutine setupNegfStuff

#:endif


  !> Decides, whether restart file should be written during the run.
  function needsRestartWriting(isGeoOpt, tMd, iGeoStep, nGeoSteps, restartFreq)&
      & result(tWriteRestart)

    !> Are geometries being optimised
    logical, intent(in) :: isGeoOpt

    !> Is this a molecular dynamics run
    logical, intent(in) :: tMd

    !> Current geometry step
    integer, intent(in) :: iGeoStep

    !> Number of geometry steps in total
    integer, intent(in) :: nGeoSteps

    !> Frequency of restart in geometry steps
    integer, intent(in) :: restartFreq

    !> Should a restart file be written?
    logical :: tWriteRestart

    if (restartFreq > 0 .and. (isGeoOpt .or. tMD)) then
      tWriteRestart = (iGeoStep == nGeoSteps .or. (mod(iGeoStep, restartFreq) == 0))
    else
      tWriteRestart = .false.
    end if

  end function needsRestartWriting


  !> Ensures that sparse array have enough storage to hold all necessary elements.
  subroutine reallocateSparseArrays(sparseSize, reks, ints,&
      & H0, rhoPrim, iRhoPrim, ERhoPrim)

    !> Size of the sparse overlap
    integer, intent(in) :: sparseSize

    !> Data type for REKS
    type(TReksCalc), allocatable, intent(inout) :: reks

    !> Integral container
    type(TIntegral), intent(inout) :: ints

    !> Sparse storage for non-SCC hamiltonian
    real(dp), allocatable, intent(inout) :: H0(:)

    !> Sparse storage for density matrix
    real(dp), allocatable, intent(inout) :: rhoPrim(:,:)

    !> Sparse storage for imaginary part of density matrix (not reallocated if not initially
    !> allocated)
    real(dp), allocatable, intent(inout) :: iRhoPrim(:,:)

    !> Sparse storage for energy weighted density matrix (not reallocated if not initially
    !> allocated)
    real(dp), allocatable, intent(inout) :: ERhoPrim(:)

    integer :: nSpin, nDipole, nQuadrupole

    #:block DEBUG_CODE
      @:ASSERT(size(H0) == size(ints%overlap))
      if (.not. allocated(reks)) then
        @:ASSERT(size(ints%hamiltonian, dim=1) == size(ints%overlap))
        @:ASSERT(all(shape(rhoPrim) == shape(ints%hamiltonian)))
        if (allocated(iRhoPrim)) then
          @:ASSERT(all(shape(iRhoPrim) == shape(rhoPrim)))
          @:ASSERT(all(shape(ints%iHamiltonian) == shape(ints%hamiltonian)))
        end if
        if (allocated(ERhoPrim)) then
          @:ASSERT(size(ERhoPrim) == size(rhoPrim, dim=1))
        end if
      end if
      @:ASSERT(allocated(ints%dipoleKet) .eqv. allocated(ints%dipoleBra))
      if (allocated(ints%dipoleKet)) then
        @:ASSERT(size(ints%overlap) == size(ints%dipoleKet, 2))
        @:ASSERT(all(shape(ints%dipoleKet) == shape(ints%dipoleBra)))
      end if
      @:ASSERT(allocated(ints%quadrupoleKet) .eqv. allocated(ints%quadrupoleBra))
      if (allocated(ints%quadrupoleKet)) then
        @:ASSERT(size(ints%overlap) == size(ints%quadrupoleKet, 2))
        @:ASSERT(all(shape(ints%quadrupoleKet) == shape(ints%quadrupoleBra)))
      end if
    #:endblock DEBUG_CODE

    if (allocated(reks)) then
      if (size(ints%overlap, dim=1) == sparseSize) then
        ! When the size of sparse matrices are different,
        ! phase of MOs can affect gradient of REKS
        return
      end if
    else
      if (size(ints%hamiltonian, dim=1) >= sparseSize) then
        ! Sparse matrices are big enough
        return
      end if
    end if

    nSpin = size(rhoPrim, dim=2)
    if (.not. allocated(reks)) then
      deallocate(ints%hamiltonian)
    end if
    deallocate(ints%overlap)
    deallocate(H0)
    deallocate(rhoPrim)
    if (.not. allocated(reks)) then
      allocate(ints%hamiltonian(sparseSize, nSpin))
    end if
    allocate(ints%overlap(sparseSize))
    allocate(H0(sparseSize))
    allocate(rhoPrim(sparseSize, nSpin))
    if (allocated(iRhoPrim)) then
      deallocate(iRhoPrim)
      deallocate(ints%iHamiltonian)
      allocate(iRhoPrim(sparseSize, nSpin))
      allocate(ints%iHamiltonian(sparseSize, nSpin))
    end if
    if (allocated(ERhoPrim)) then
      deallocate(ERhoPrim)
      allocate(ERhoPrim(sparseSize))
    end if
    if (allocated(reks)) then
      call reks%reallocate(sparseSize)
    end if
    if (allocated(ints%dipoleKet)) then
      nDipole = size(ints%dipoleKet, 1)
      deallocate(ints%dipoleBra, ints%dipoleKet)
      allocate(ints%dipoleKet(nDipole, sparseSize))
      allocate(ints%dipoleBra(nDipole, sparseSize))
    end if
    if (allocated(ints%quadrupoleKet)) then
      nQuadrupole = size(ints%quadrupoleKet, 1)
      deallocate(ints%quadrupoleBra, ints%quadrupoleKet)
      allocate(ints%quadrupoleKet(nQuadrupole, sparseSize))
      allocate(ints%quadrupoleBra(nQuadrupole, sparseSize))
    end if

  end subroutine reallocateSparseArrays


  !> Initialise basic variables before the scc loop.
  subroutine initSccLoop(tSccCalc, xlbomdIntegrator, minSccIter, maxSccIter, sccTol, tConverged,&
      & tNegf, reks)

    !> Is this an SCC calculation?
    logical, intent(in) :: tSccCalc

    !> Details for extended Lagrange integrator (of used)
    type(TXLBOMD), allocatable, intent(inout) :: xlbomdIntegrator

    !> Minimum number of SCC cycles that can be used
    integer, intent(inout) :: minSccIter

    !> Maximum number of SCC cycles
    integer, intent(inout) :: maxSccIter

    !> Tolerance for SCC convergence
    real(dp), intent(inout) :: sccTol

    !> Has SCC convergence been achieved?
    logical, intent(out) :: tConverged

    !> Is this a transport calculation?
    logical, intent(in) :: tNegf

    !> Data type for REKS
    type(TReksCalc), allocatable, intent(inout) :: reks

    if (allocated(xlbomdIntegrator)) then
      call xlbomdIntegrator%getSCCParameters(minSccIter, maxSccIter, sccTol)
    end if

    tConverged = (.not. tSccCalc)

    if (allocated(reks)) then
      if (tSccCalc) then
        call printReksSccHeader(reks)
      end if
    else
      if (tSccCalc .and. .not. tNegf) then
        call printSccHeader()
      end if
    end if

  end subroutine initSccLoop


  !> Transform the hamiltonian from QM to UD representation
  !> Hack due to not using Pauli-type structure for diagonalisation
  !> For collinear spin, qm2ud will produce the right potential:
  !> (Vq, uB*Bz*\sigma_z) -> (Vq + uB*Bz*\sigma_z, Vq - uB*Bz*\sigma_z)
  !> For non-collinear spin-orbit, all blocks are multiplied by 1/2:
  !> (Vq/2, uL* Lx*\sigma_x/2, uL* Ly*\sigma_y/2, uL* Lz*\sigma_z/2)
  subroutine convertToUpDownRepr(Ham, iHam)
    real(dp), intent(inout) :: Ham(:,:)
    real(dp), intent(inout), allocatable :: iHam(:,:)

    integer :: nSpinBlocks

    nSpinBlocks = size(ham, dim=2)

    if (nSpinBlocks > 1) then
      ham = 2.0_dp * ham
      if (allocated(iHam)) then
        iHam = 2.0_dp * iHam
      end if
    end if

    if (nSpinBlocks /= 4) then
      call qm2ud(ham)
      if (allocated(iHam)) then
        call qm2ud(iHam)
      end if
    end if

  end subroutine convertToUpDownRepr


  !> Returns the sparse density matrix.
  !>
  !> All operations (e.g. non-dual spin orbit coupling), which need access to full (unpacked)
  !> Hamiltonian or the full (unpacked) density matrix, must also invoked from within this routine,
  !> as those unpacked quantities do not exist elsewhere.
  !>
  subroutine getDensity(env, negfInt, iScc, denseDesc, ints, neighbourList, symNeighbourList,&
      & nNeighbourSK, iSparseStart, img2CentCell, iCellVec, cellVec, kPoint, kWeight, orb,&
      & tHelical, coord, species, electronicSolver, rCellVecs, latVecs, recVecs2p, tPeriodic,&
      & tRealHS, tSpinSharedEf, tSpinOrbit, tDualSpinOrbit, tFillKSep, tFixEf, tMulliken,&
      & iDistribFn, tempElec, nEl, parallelKS, Ef, mu, energy, hybridXc, eigen, filling, rhoPrim,&
      & xi, orbitalL, HSqrReal, SSqrReal, eigvecsReal, iRhoPrim, HSqrCplx, SSqrCplx, eigvecsCplx,&
      & rhoSqrReal, densityMatrix, nNeighbourCam, nNeighbourCamSym, deltaDftb, apiCallBack,&
      & errStatus)

    use dftbp_elecsolvers_dmsolvertypes, only : densityMatrixTypes

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> NEGF interface
    type(TNegfInt), intent(inout) :: negfInt

    !> SCC iteration counter (needed by GF)
    integer, intent(in) :: iSCC

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> List of neighbours for each atom (symmetric version)
    type(TSymNeighbourList), intent(in), allocatable :: symNeighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> The k-points
    real(dp), intent(in) :: kPoint(:,:)

    !> Weights for k-points
    real(dp), intent(in) :: kWeight(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Coordinates of all atoms including images
    real(dp), allocatable, intent(inout) :: coord(:,:)

    !> Species of all atoms in the system
    integer, intent(in) :: species(:)

    !> Electronic solver information
    type(TElectronicSolver), intent(inout) :: electronicSolver

    !> Vectors to unit cells in absolute units
    real(dp), intent(in) :: rCellVecs(:,:)

    !> Lattice vectors
    real(dp), intent(in) :: latVecs(:,:)

    !> Reciprocal lattice vectors in units of 2 pi
    real(dp), intent(in) :: recVecs2p(:,:)

    !> Is the system periodic (gamma/general k-points)?
    logical, intent(in) :: tPeriodic

    !> Is the hamiltonian real (no k-points/molecule/gamma point)?
    logical, intent(in) :: tRealHS

    !> Is the Fermi level common across spin channels?
    logical, intent(in) :: tSpinSharedEf

    !> Are spin orbit interactions present
    logical, intent(in) :: tSpinOrbit

    !> Are block population spin orbit interactions present
    logical, intent(in) :: tDualSpinOrbit

    !> Fill k-points separately if true (no charge transfer across the BZ)
    logical, intent(in) :: tFillKSep

    !> Whether fixed Fermi level(s) should be used. (No charge conservation!)
    logical, intent(in) :: tFixEf

    !> Should Mulliken populations be generated/output
    logical, intent(in) :: tMulliken

    !> Occupation function for electronic states
    integer, intent(in) :: iDistribFn

    !> Electronic temperature
    real(dp), intent(in) :: tempElec

    !> Number of electrons
    real(dp), intent(in) :: nEl(:)

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Fermi level(s)
    real(dp), intent(inout) :: Ef(:)

    !> Electrochemical potentials (contact, spin)
    real(dp), allocatable, intent(in) :: mu(:,:)

    !> Energy contributions and total
    type(TEnergies), intent(inout) :: energy

    !> Data for hybrid xc-functional calculation
    class(THybridXcFunc), allocatable, intent(inout) :: hybridXc

    !> Eigenvalues (level, kpoint, spin)
    real(dp), intent(out) :: eigen(:,:,:)

    !> Occupations (level, kpoint, spin)
    real(dp), intent(out) :: filling(:,:,:)

    !> Sparse density matrix
    real(dp), intent(out) :: rhoPrim(:,:)

    !> Spin orbit constants
    real(dp), intent(in), allocatable :: xi(:,:)

    !> Orbital moments of atomic shells
    real(dp), intent(inout), allocatable :: orbitalL(:,:,:)

    !> Imaginary part of density matrix
    real(dp), intent(inout), allocatable :: iRhoPrim(:,:)

    !> Dense real hamiltonian storage
    real(dp), intent(inout), allocatable :: HSqrReal(:,:)

    !> Dense real overlap storage
    real(dp), intent(inout), allocatable :: SSqrReal(:,:)

    !> Real eigenvectors on exit
    real(dp), intent(inout), allocatable :: eigvecsReal(:,:,:)

    !> Dense complex (k-points) hamiltonian storage
    complex(dp), intent(inout), allocatable :: HSqrCplx(:,:)

    !> Dense complex (k-points) overlap storage
    complex(dp), intent(inout), allocatable :: SSqrCplx(:,:)

    !> Complex eigenvectors on exit
    complex(dp), intent(inout), allocatable :: eigvecsCplx(:,:,:)

    !> Dense density matrix
    real(dp), intent(inout), allocatable :: rhoSqrReal(:,:,:)

    !> Holds real and complex delta density matrices and pointers
    type(TDensityMatrix), intent(inout) :: densityMatrix

    !> Number of neighbours for each of the atoms for the exchange contributions of CAM functionals
    integer, intent(in), allocatable :: nNeighbourCam(:)

    !> Symmetric neighbour list version of nNeighbourCam
    integer, intent(in), allocatable :: nNeighbourCamSym(:)

    !> Determinant derived type
    type(TDftbDeterminants), intent(inout) :: deltaDftb

    !> Object for invocation of the density, overlap, and hamiltonian matrices exported by callbacks
    type(TAPICallback), intent(inout), allocatable :: apiCallBack

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    select case (densityMatrix%iDensityMatrixAlgorithm)

    case (densityMatrixTypes%none)

      if (electronicSolver%iSolver == electronicSolverTypes%onlyTransport) then
        call error("OnlyTransport solver cannot calculate the density matrix")
      else
        call error("Cannot calculate the density matrix with the hosen electronic solver")
      end if

    case(densityMatrixTypes%fromEigenVecs, densityMatrixTypes%magma_fromEigenVecs)

      call getDensityFromDenseDiag(env, denseDesc, ints, neighbourList, symNeighbourList,&
          & nNeighbourSK, iSparseStart, img2CentCell, iCellVec, cellVec, kPoint, kWeight, orb,&
          & tHelical, coord, species, electronicSolver, rCellVecs, latVecs, recVecs2p, tPeriodic,&
          & tRealHS, tSpinSharedEf, tSpinOrbit, tDualSpinOrbit, tFillKSep, tFixEf, tMulliken,&
          & iDistribFn, tempElec, nEl, parallelKS, Ef, energy, hybridXc, eigen, filling, rhoPrim,&
          & xi, orbitalL, HSqrReal, SSqrReal, eigvecsReal, iRhoPrim, HSqrCplx, SSqrCplx,&
          & eigvecsCplx, rhoSqrReal, densityMatrix, nNeighbourCam, nNeighbourCamSym, deltaDftb,&
          & apiCallBack, errStatus)
      @:PROPAGATE_ERROR(errStatus)

    case(densityMatrixTypes%elecSolverProvided)

      call env%globalTimer%startTimer(globalTimers%densityMatrix)
      if (electronicSolver%iSolver == electronicSolverTypes%GF) then

      #:if WITH_TRANSPORT
        call negfInt%calcdensity_green(iSCC, env, parallelKS%localKS, ints%hamiltonian,&
            & ints%overlap, neighbourlist%iNeighbour, nNeighbourSK, denseDesc%iAtomStart,&
            & iSparseStart, img2CentCell, iCellVec, cellVec, orb, kPoint, kWeight, mu, rhoPrim,&
            & energy%Eband, Ef, energy%E0, energy%TS)
      #:else
        call error("Internal error: getDensity : GF solver called although code compiled without&
            & transport")
      #:endif
        call ud2qm(rhoPrim)

      else

        call electronicSolver%elsi%getDensity(env, denseDesc, ints%hamiltonian, ints%overlap,&
            & neighbourList, nNeighbourSK, iSparseStart, img2CentCell, iCellVec, cellVec, kPoint,&
            & kWeight, tHelical, orb, species, coord, tRealHS, tSpinSharedEf, tSpinOrbit,&
            & tDualSpinOrbit, tMulliken, parallelKS, Ef, energy, rhoPrim, energy%Eband, energy%TS,&
            & ints%iHamiltonian, xi, orbitalL, HSqrReal, SSqrReal, iRhoPrim, HSqrCplx, SSqrCplx)

      end if
      call env%globalTimer%stopTimer(globalTimers%densityMatrix)

    end select

  end subroutine getDensity


  !> Returns the density matrix using dense diagonalisation.
  subroutine getDensityFromDenseDiag(env, denseDesc, ints, neighbourList, symNeighbourList,&
      & nNeighbourSK, iSparseStart, img2CentCell, iCellVec, cellVec, kPoint, kWeight, orb,&
      & tHelical, coord, species, electronicSolver, rCellVecs, latVecs, recVecs2p, tPeriodic,&
      & tRealHS, tSpinSharedEf, tSpinOrbit, tDualSpinOrbit, tFillKSep, tFixEf, tMulliken,&
      & iDistribFn, tempElec, nEl, parallelKS, Ef, energy, hybridXc, eigen, filling, rhoPrim, xi,&
      & orbitalL, HSqrReal, SSqrReal, eigvecsReal, iRhoPrim, HSqrCplx, SSqrCplx, eigvecsCplx,&
      & rhoSqrReal, densityMatrix, nNeighbourCam, nNeighbourCamSym, deltaDftb, apiCallBack,&
      & errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> List of neighbours for each atom (symmetric version)
    type(TSymNeighbourList), intent(in), allocatable :: symNeighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> The k-points
    real(dp), intent(in) :: kPoint(:,:)

    !> Weights for k-points
    real(dp), intent(in) :: kWeight(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Coordinates of all atoms including images
    real(dp), allocatable, intent(inout) :: coord(:,:)

    !> Species of all atoms in the system
    integer, intent(in) :: species(:)

    !> Electronic solver information
    type(TElectronicSolver), intent(inout) :: electronicSolver

    !> Vectors to unit cells in absolute units
    real(dp), intent(in) :: rCellVecs(:,:)

    !> Lattice vectors
    real(dp), intent(in) :: latVecs(:,:)

    !> Reciprocal lattice vectors in units of 2 pi
    real(dp), intent(in) :: recVecs2p(:,:)

    !> Is the system periodic (gamma/general k-points)?
    logical, intent(in) :: tPeriodic

    !> Is the hamiltonian real (no k-points/molecule/gamma point)?
    logical, intent(in) :: tRealHS

    !> Is the Fermi level common across spin channels?
    logical, intent(in) :: tSpinSharedEf

    !> Are spin orbit interactions present
    logical, intent(in) :: tSpinOrbit

    !> Are block population spin orbit interactions present
    logical, intent(in) :: tDualSpinOrbit

    !> Fill k-points separately if true (no charge transfer across the BZ)
    logical, intent(in) :: tFillKSep

    !> Whether fixed Fermi level(s) should be used. (No charge conservation!)
    logical, intent(in) :: tFixEf

    !> Should Mulliken populations be generated/output
    logical, intent(in) :: tMulliken

    !> Occupation function for electronic states
    integer, intent(in) :: iDistribFn

    !> Electronic temperature
    real(dp), intent(in) :: tempElec

    !> Number of electrons
    real(dp), intent(in) :: nEl(:)

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Fermi level(s)
    real(dp), intent(inout) :: Ef(:)

    !> Energy contributions and total
    type(TEnergies), intent(inout) :: energy

    !> Data for hybrid xc-functional calculation
    class(THybridXcFunc), intent(inout), allocatable :: hybridXc

    !> Eigenvalues (level, kpoint, spin)
    real(dp), intent(out) :: eigen(:,:,:)

    !> Occupations (level, kpoint, spin)
    real(dp), intent(out) :: filling(:,:,:)

    !> Sparse density matrix
    real(dp), intent(out) :: rhoPrim(:,:)

    !> Spin orbit constants
    real(dp), intent(in), allocatable :: xi(:,:)

    !> Orbital moments of atomic shells
    real(dp), intent(inout), allocatable :: orbitalL(:,:,:)

    !> Imaginary part of density matrix
    real(dp), intent(inout), allocatable :: iRhoPrim(:,:)

    !> Dense real hamiltonian storage
    real(dp), intent(inout), allocatable :: HSqrReal(:,:)

    !> Dense real overlap storage
    real(dp), intent(inout), allocatable :: SSqrReal(:,:)

    !> Real eigenvectors on exit
    real(dp), intent(inout), allocatable :: eigvecsReal(:,:,:)

    !> Dense complex (k-points) hamiltonian storage
    complex(dp), intent(inout), allocatable :: HSqrCplx(:,:)

    !> Dense complex (k-points) overlap storage
    complex(dp), intent(inout), allocatable :: SSqrCplx(:,:)

    !> Complex eigenvectors on exit
    complex(dp), intent(inout), allocatable :: eigvecsCplx(:,:,:)

    !> Dense density matrix
    real(dp), intent(inout), allocatable :: rhoSqrReal(:,:,:)

    !> Holds real and complex delta density matrices and pointers
    type(TDensityMatrix), intent(inout) :: densityMatrix

    !> Nr. of neighbours for each atom for the exchange contributions (CAM functionals)
    integer, intent(in), allocatable :: nNeighbourCam(:)

    !> Symmetric neighbour list version of nNeighbourCam
    integer, intent(in), allocatable :: nNeighbourCamSym(:)

    !> Determinant derived type
    type(TDftbDeterminants), intent(inout) :: deltaDftb

    !> Object for invocation of the density, overlap, and hamiltonian matrices exported by callbacks
    type(Tapicallback), intent(inout), allocatable :: apiCallBack

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    integer :: nSpin

    nSpin = size(ints%hamiltonian, dim=2)
    call env%globalTimer%startTimer(globalTimers%diagonalization)
    if (nSpin /= 4) then
      if (tRealHS) then
        call buildAndDiagDenseRealHam(env, denseDesc, ints, species, neighbourList,&
            & symNeighbourList, nNeighbourSK, iSparseStart, img2CentCell, orb, tPeriodic, tHelical,&
            & coord, electronicSolver, parallelKS, hybridXc, densityMatrix%deltaRhoIn,&
            & nNeighbourCam, nNeighbourCamSym, HSqrReal, SSqrReal, eigVecsReal, eigen(:,1,:),&
            & apiCallBack, errStatus)
        @:PROPAGATE_ERROR(errStatus)
      else
        call buildAndDiagDenseCplxHam(env, denseDesc, ints, kPoint, kWeight, neighbourList,&
            & symNeighbourList, nNeighbourSK, iSparseStart, img2CentCell, rCellVecs, iCellVec,&
            & recVecs2p, cellVec, electronicSolver, parallelKS, tHelical, orb, species, coord,&
            & hybridXc, densityMatrix, nNeighbourCamSym, HSqrCplx, SSqrCplx, eigVecsCplx, eigen,&
            & apiCallBack, errStatus)
        @:PROPAGATE_ERROR(errStatus)
      end if
    else
      call buildAndDiagDensePauliHam(env, denseDesc, ints, kPoint, neighbourList,&
          & nNeighbourSK, iSparseStart, img2CentCell, iCellVec, cellVec, orb, electronicSolver,&
          & parallelKS, eigen(:,:,1), HSqrCplx, SSqrCplx, eigVecsCplx, apiCallBack, errStatus,&
          & xi, species)
      @:PROPAGATE_ERROR(errStatus)
    end if
    call env%globalTimer%stopTimer(globalTimers%diagonalization)

    call getFillingsAndBandEnergies(eigen, nEl, nSpin, tempElec, kWeight, tSpinSharedEf,&
        & tFillKSep, tFixEf, iDistribFn, Ef, filling, energy%Eband, energy%TS, energy%E0, deltaDftb)

    call env%globalTimer%startTimer(globalTimers%densityMatrix)
    if (nSpin /= 4) then
      if (tRealHS) then
        call getDensityFromRealEigvecs(env, denseDesc, filling(:,1,:), neighbourList, nNeighbourSK,&
            & iSparseStart, img2CentCell, orb, species, coord, tPeriodic, tHelical, eigVecsReal,&
            & parallelKS, densityMatrix, rhoPrim, SSqrReal, rhoSqrReal, hybridXc, apiCallBack,&
            & errStatus)
        @:PROPAGATE_ERROR(errStatus)
      else
        call getDensityFromCplxEigvecs(env, denseDesc, filling, kPoint, kWeight, neighbourList,&
            & nNeighbourSK, iSparseStart, img2CentCell, iCellVec, cellVec, orb,&
            & parallelKS, tHelical, species, coord, eigvecsCplx, densityMatrix, rhoPrim, SSqrCplx,&
            & hybridXc, apiCallBack, errStatus)
        @:PROPAGATE_ERROR(errStatus)
      end if
      call ud2qm(rhoPrim)
    else
      ! Pauli structure of eigenvectors
      filling(:,:,1) = 2.0_dp * filling(:,:,1)
      call getDensityFromPauliEigvecs(env, denseDesc, tRealHS, tSpinOrbit, tDualSpinOrbit,&
          & tMulliken, kPoint, kWeight, filling(:,:,1), neighbourList, nNeighbourSK, orb,&
          & iSparseStart, img2CentCell, iCellVec, cellVec, species, parallelKS, eigVecsCplx,&
          & SSqrCplx, energy, densityMatrix, rhoPrim, xi, orbitalL, iRhoPrim, apiCallBack,&
          & errStatus)
      @:PROPAGATE_ERROR(errStatus)
      filling(:,:,1) = 0.5_dp * filling(:,:,1)
    end if
    call env%globalTimer%stopTimer(globalTimers%densityMatrix)

  end subroutine getDensityFromDenseDiag


  !> Builds and diagonalises dense Hamiltonians.
  subroutine buildAndDiagDenseRealHam(env, denseDesc, ints, species, neighbourList,&
      & symNeighbourList, nNeighbourSK, iSparseStart, img2CentCell, orb, tPeriodic, tHelical,&
      & coord, electronicSolver, parallelKS, hybridXc, deltaRhoIn, nNeighbourCam,&
      & nNeighbourCamSym, HSqrReal, SSqrReal, eigvecsReal, eigen, apiCallBack, errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> List of neighbours for each atom (symmetric version)
    type(TSymNeighbourList), intent(in), allocatable :: symNeighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Species of all atoms in the system
    integer, intent(in) :: species(:)

    !> Is the system periodic?
    logical, intent(in) :: tPeriodic

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Coordinates of all atoms including images
    real(dp), allocatable, intent(inout) :: coord(:,:)

    !> Electronic solver information
    type(TElectronicSolver), intent(inout) :: electronicSolver

    !> The k-points and spins to be handled
    type(TParallelKS), intent(in) :: parallelKS

    !>Data for hybrid xc-functional calculation
    class(THybridXcFunc), intent(inout), allocatable :: hybridXc

    !> Change in density matrix during last hybridXc SCC cycle
    real(dp), intent(in), allocatable :: deltaRhoIn(:,:,:)

    !> Number of neighbours for each of the atoms for the exchange contributions of CAM functionals
    integer, intent(in), allocatable :: nNeighbourCam(:)

    !> Symmetric neighbour list version of nNeighbourCam
    integer, intent(in), allocatable :: nNeighbourCamSym(:)

    !> Dense hamiltonian matrix
    real(dp), intent(out) :: HSqrReal(:,:)

    !> Dense overlap matrix
    real(dp), intent(out) :: SSqrReal(:,:)

    !> Eigenvectors on eixt
    real(dp), intent(out) :: eigvecsReal(:,:,:)

    !> Eigenvalues
    real(dp), intent(out) :: eigen(:,:)

    !> Object for invocation of the density, overlap, and hamiltonian matrices exported by callbacks
    type(Tapicallback), intent(in), allocatable :: apiCallBack

    !> Status of operation
    type(TStatus), intent(inout) :: errStatus

    integer :: iKS, iSpin, iK

    eigen(:,:) = 0.0_dp

    do iKS = 1, parallelKS%nLocalKS
      iSpin = parallelKS%localKS(2, iKS)
    #:if WITH_SCALAPACK
      call env%globalTimer%startTimer(globalTimers%sparseToDense)
      if (tHelical) then
        call unpackHSHelicalRealBlacs(env%blacs, ints%hamiltonian(:,iSpin),&
            & neighbourList%iNeighbour, nNeighbourSK, iSparseStart, img2CentCell, orb, species,&
            & coord, denseDesc, HSqrReal)
        call unpackHSHelicalRealBlacs(env%blacs, ints%overlap, neighbourList%iNeighbour,&
            & nNeighbourSK, iSparseStart, img2CentCell, orb, species, coord, denseDesc,&
            & SSqrReal)
      else
        call unpackHSRealBlacs(env%blacs, ints%hamiltonian(:,iSpin), neighbourList%iNeighbour,&
            & nNeighbourSK, iSparseStart, img2CentCell, denseDesc, HSqrReal)
        call unpackHSRealBlacs(env%blacs, ints%overlap, neighbourList%iNeighbour, nNeighbourSK,&
            & iSparseStart, img2CentCell, denseDesc, SSqrReal)
      end if
      call env%globalTimer%stopTimer(globalTimers%sparseToDense)

      ! Add hybrid xc-functional contribution to Hamiltonian of current spin-channel
      if (allocated(hybridXc)) then
        call hybridXc%addCamHamiltonian_real(env, denseDesc, SSqrReal, deltaRhoIn(:,:, iKS),&
            & HSqrReal, errStatus)
        @:PROPAGATE_ERROR(errStatus)
      end if

      if (allocated(apiCallBack)) then
        call apiCallBack%invokeHSCallBack(parallelKS%localKS(:,iKS),&
            & electronicSolver%hasCholesky(iKS), SSqrReal, HSqrReal, denseDesc)
      endif

      call diagDenseMtxBlacs(electronicSolver, 1, 'V', denseDesc%blacsOrbSqr, HSqrReal, SSqrReal,&
          & eigen(:,iSpin), eigvecsReal(:,:,iKS), errStatus)
      @:PROPAGATE_ERROR(errStatus)
    #:else
      call env%globalTimer%startTimer(globalTimers%sparseToDense)
      if (tHelical) then
        call unpackHelicalHS(HSqrReal, ints%hamiltonian(:,iSpin), neighbourList%iNeighbour,&
            & nNeighbourSK, denseDesc%iAtomStart, iSparseStart, img2CentCell, orb, species, coord)
        call unpackHelicalHS(SSqrReal, ints%overlap, neighbourList%iNeighbour, nNeighbourSK,&
            & denseDesc%iAtomStart, iSparseStart, img2CentCell, orb, species, coord)
      else
        call unpackHS(HSqrReal, ints%hamiltonian(:,iSpin), neighbourList%iNeighbour,&
            & nNeighbourSK, denseDesc%iAtomStart, iSparseStart, img2CentCell)
        call unpackHS(SSqrReal, ints%overlap, neighbourList%iNeighbour, nNeighbourSK,&
            & denseDesc%iAtomStart, iSparseStart, img2CentCell)
      end if
      call env%globalTimer%stopTimer(globalTimers%sparseToDense)

      ! Add hybrid xc-functional contribution to Hamiltonian of current spin-channel
      if (allocated(hybridXc)) then
        call hybridXc%addCamHamiltonian_real(env, deltaRhoIn(:,:, iKS), SSqrReal, ints%overlap,&
            & neighbourList%iNeighbour, nNeighbourCam, denseDesc%iAtomStart, iSparseStart, orb,&
            & img2CentCell, tPeriodic, HSqrReal, errStatus)
        @:PROPAGATE_ERROR(errStatus)
      end if

      if (allocated(apiCallBack)) then
        call apiCallBack%invokeHSCallBack(parallelKS%localKS(:,iKS),&
            & electronicSolver%hasCholesky(iKS), SSqrReal, HSqrReal)
      end if

      ! Warning: SSqrReal gets overwritten here
      call diagDenseMtx(env, electronicSolver, 'V', HSqrReal, SSqrReal, eigen(:, iSpin),&
          & errStatus)
      @:PROPAGATE_ERROR(errStatus)
      eigvecsReal(:,:,iKS) = HSqrReal
    #:endif
    end do

  #:if WITH_SCALAPACK
    ! Distribute all eigenvalues to all nodes via global summation
    call mpifx_allreduceip(env%mpi%interGroupComm, eigen, MPI_SUM)
  #:endif

  end subroutine buildAndDiagDenseRealHam


  !> Builds and diagonalises dense k-point dependent Hamiltonians.
  subroutine buildAndDiagDenseCplxHam(env, denseDesc, ints, kPoint, kWeight, neighbourList,&
      & symNeighbourList, nNeighbourSK, iSparseStart, img2CentCell, rCellVecs, iCellVec, recVecs2p,&
      & cellVec, electronicSolver, parallelKS, tHelical, orb, species, coord, hybridXc,&
      & densityMatrix, nNeighbourCamSym, HSqrCplx, SSqrCplx, eigvecsCplx, eigen, apiCallBack,&
      & errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> The k-points
    real(dp), intent(in) :: kPoint(:,:)

    !> The k-point weight (for energy contribution)
    real(dp), intent(in) :: kWeight(:)

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> List of neighbours for each atom (symmetric version)
    type(TSymNeighbourList), intent(in), allocatable :: symNeighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Vectors to unit cells in absolute units
    real(dp), intent(in) :: rCellVecs(:,:)

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Reciprocal lattice vectors in units of 2 pi
    real(dp), intent(in) :: recVecs2p(:,:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> Electronic solver information
    type(TElectronicSolver), intent(inout) :: electronicSolver

    !> The k-points and spins to be handled
    type(TParallelKS), intent(in) :: parallelKS

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Species of all atoms in the system
    integer, intent(in) :: species(:)

    !> Atomic coordinates
    real(dp), intent(in) :: coord(:,:)

    !> Data for hybrid xc-functional calculation
    class(THybridXcFunc), intent(inout), allocatable :: hybridXc

    !> Holds real and complex delta density matrices
    type(TDensityMatrix), intent(inout) :: densityMatrix

    !> Symmetric neighbour list version of nNeighbourCam
    integer, intent(in), allocatable :: nNeighbourCamSym(:)

    !> Dense hamiltonian matrix
    complex(dp), intent(out) :: HSqrCplx(:,:)

    !> Dense overlap matrix
    complex(dp), intent(out) :: SSqrCplx(:,:)

    !> Complex eigenvectors
    complex(dp), intent(out) :: eigvecsCplx(:,:,:)

    !> Eigenvalues
    real(dp), intent(out) :: eigen(:,:,:)

    !> Object for invocation of the density, overlap, and hamiltonian matrices exporting callbacks
    type(Tapicallback), intent(in), allocatable :: apiCallBack

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    !! Temporary storage for square, k-space CAM-Hamiltonian contribution
    complex(dp), allocatable :: HSqrCplxCam(:,:,:)

    !! Temporary storage for square, k-space overlap
    complex(dp), allocatable :: SSqrCplxCam(:,:,:)

    !! Indices for k-points and spins + composite
    integer :: iK, iSpin, iKS

    eigen(:,:,:) = 0.0_dp

    if (allocated(hybridXc)) then

      if (hybridXc%hybridXcAlg == hybridXcAlgo%matrixBased) then
        ! Pre-generate overlap matrix on all MPI processes
        allocate(SSqrCplxCam(size(densityMatrix%deltaRhoInCplx, dim=1),&
            & size(densityMatrix%deltaRhoInCplx, dim=2), size(kPoint, dim=2)),&
            & source=(0.0_dp, 0.0_dp))
        do iKS = 1, parallelKS%nLocalKS
          iSpin = parallelKS%localKS(2, iKS)
          ! cycling in this case is crucial, since we allow more MPI groups than k-points
          if (iSpin == 2) cycle
          iK = parallelKS%localKS(1, iKS)
          call env%globalTimer%startTimer(globalTimers%sparseToDense)
          call unpackHS(SSqrCplxCam(:,:, iK), ints%overlap, kPoint(:, iK),&
              & neighbourList%iNeighbour, nNeighbourSK, iCellVec, cellVec, denseDesc%iAtomStart,&
              & iSparseStart, img2CentCell)
          call env%globalTimer%stopTimer(globalTimers%sparseToDense)
          call adjointLowerTriangle(SSqrCplxCam(:,:, iK))
        end do
      #:if WITH_SCALAPACK
        ! Distribute overlap matrices to all nodes via global summation
        call mpifx_allreduceip(env%mpi%globalComm, SSqrCplxCam, MPI_SUM)
      #:endif
      end if

      ! Get CAM-Hamiltonian contribution for all spins/k-points
      call hybridXc%getCamHamiltonian_kpts(env, denseDesc, orb, ints, densityMatrix, neighbourList,&
          & nNeighbourSK, symNeighbourList, nNeighbourCamSym, iCellVec, cellVec, rCellVecs,&
          & iSparseStart, img2CentCell, kPoint, kWeight, HSqrCplxCam, errStatus)
      @:PROPAGATE_ERROR(errStatus)
    end if

    ! Loop over all spins/k-points associated with MPI group
    do iKS = 1, parallelKS%nLocalKS
      ! Get global k-point index from local iKS composite
      iK = parallelKS%localKS(1, iKS)
      ! Get global spin index from local iKS composite
      iSpin = parallelKS%localKS(2, iKS)
    #:if WITH_SCALAPACK
      call env%globalTimer%startTimer(globalTimers%sparseToDense)
      if (tHelical) then
        call unpackHSHelicalCplxBlacs(env%blacs, ints%hamiltonian(:,iSpin), kPoint(:,iK),&
            & neighbourList%iNeighbour, nNeighbourSK, iCellVec, cellVec, iSparseStart,&
            & img2CentCell, orb, species, coord, denseDesc, HSqrCplx)
        if (.not. electronicSolver%hasCholesky(iKS)) then
          call unpackHSHelicalCplxBlacs(env%blacs, ints%overlap, kPoint(:,iK),&
              & neighbourList%iNeighbour, nNeighbourSK, iCellVec, cellVec, iSparseStart,&
              & img2CentCell, orb, species, coord, denseDesc, SSqrCplx)
        end if
      else
        call unpackHSCplxBlacs(env%blacs, ints%hamiltonian(:,iSpin), kPoint(:,iK),&
            & neighbourList%iNeighbour, nNeighbourSK, iCellVec, cellVec, iSparseStart,&
            & img2CentCell, denseDesc, HSqrCplx)
        if (.not. electronicSolver%hasCholesky(iKS)) then
          call unpackHSCplxBlacs(env%blacs, ints%overlap, kPoint(:,iK), neighbourList%iNeighbour,&
              & nNeighbourSK, iCellVec, cellVec, iSparseStart, img2CentCell, denseDesc, SSqrCplx)
        end if
      end if
      call env%globalTimer%stopTimer(globalTimers%sparseToDense)

      ! Add pre-calculated CAM contribution to local, non-distributed Hamiltonian
      ! (Works only if total number of MPI processes matches number of MPI groups.)
      if (allocated(hybridXc)) then
        HSqrCplx(:,:) = HSqrCplx + HSqrCplxCam(:,:, densityMatrix%iKiSToiGlobalKS(iK, iSpin))
      end if

      if (allocated(apiCallBack)) then
        call apiCallBack%invokeHSCallBack(parallelKS%localKS(:,iKS),&
            & electronicSolver%hasCholesky(iKS), SSqrCplx, HSqrCplx, denseDesc)
      endif

      call diagDenseMtxBlacs(env, electronicSolver, iKS, 'V', denseDesc%blacsOrbSqr, HSqrCplx,&
          & SSqrCplx, eigen(:,iK,iSpin), eigvecsCplx(:,:,iKS), errStatus)
      @:PROPAGATE_ERROR(errStatus)

    #:else
      call env%globalTimer%startTimer(globalTimers%sparseToDense)
      if (tHelical) then
        call unpackHelicalHS(HSqrCplx, ints%hamiltonian(:,iSpin), kPoint(:,iK),&
            & neighbourList%iNeighbour, nNeighbourSK, iCellVec, cellVec, denseDesc%iAtomStart,&
            & iSparseStart, img2CentCell, orb, species, coord)
        call unpackHelicalHS(SSqrCplx, ints%overlap, kPoint(:,iK), neighbourList%iNeighbour,&
            & nNeighbourSK, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart, img2CentCell,&
            & orb, species, coord)
      else
        call unpackHS(HSqrCplx, ints%hamiltonian(:,iSpin), kPoint(:,iK), neighbourList%iNeighbour,&
            & nNeighbourSK, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart, img2CentCell)
        call unpackHS(SSqrCplx, ints%overlap, kPoint(:,iK), neighbourList%iNeighbour, nNeighbourSK,&
            & iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart, img2CentCell)
      end if
      call env%globalTimer%stopTimer(globalTimers%sparseToDense)

      ! Add pre-calculated CAM contribution to local, non-distributed Hamiltonian
      ! (Works only if total number of MPI processes matches number of MPI groups.)
      if (allocated(hybridXc)) then
        HSqrCplx(:,:) = HSqrCplx + HSqrCplxCam(:,:, densityMatrix%iKiSToiGlobalKS(iK, iSpin))
      end if

      if (allocated(apiCallBack)) then
        call apiCallBack%invokeHSCallBack(parallelKS%localKS(:,iKS),&
            & electronicSolver%hasCholesky(iKS), SSqrCplx, HSqrCplx)
      endif

      call diagDenseMtx(env, electronicSolver, 'V', HSqrCplx, SSqrCplx, eigen(:, iK, iSpin),&
          & errStatus)
      @:PROPAGATE_ERROR(errStatus)
      eigvecsCplx(:,:, iKS) = HSqrCplx
    #:endif
    end do

  #:if WITH_SCALAPACK
    ! Distribute all eigenvalues to all nodes via global summation
    call mpifx_allreduceip(env%mpi%interGroupComm, eigen, MPI_SUM)
  #:endif

  end subroutine buildAndDiagDenseCplxHam


  !> Builds and diagonalizes Pauli two-component Hamiltonians.
  subroutine buildAndDiagDensePauliHam(env, denseDesc, ints, kPoint, neighbourList,&
      & nNeighbourSK, iSparseStart, img2CentCell, iCellVec, cellVec, orb, electronicSolver,&
      & parallelKS, eigen, HSqrCplx, SSqrCplx, eigvecsCplx, apiCallBack, errStatus, xi, species)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> The k-points
    real(dp), intent(in) :: kPoint(:,:)

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Electronic solver information
    type(TElectronicSolver), intent(inout) :: electronicSolver

    !> The k-points and spins to be handled
    type(TParallelKS), intent(in) :: parallelKS

    !> Eigenvalues (orbital, kpoint)
    real(dp), intent(out) :: eigen(:,:)

    !> Dense hamiltonian matrix
    complex(dp), intent(out) :: HSqrCplx(:,:)

    !> Dense overlap matrix
    complex(dp), intent(out) :: SSqrCplx(:,:)

    !> Eigenvectors
    complex(dp), intent(out) :: eigvecsCplx(:,:,:)

    !> Object for invocation of the density, overlap, and hamiltonian matrices exported by callbacks
    type(Tapicallback), intent(in), allocatable :: apiCallBack

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    !> Spin orbit constants
    real(dp), intent(in), allocatable :: xi(:,:)

    !> Species of atoms
    integer, intent(in), optional :: species(:)

    integer :: iKS, iK

    eigen(:,:) = 0.0_dp
    do iKS = 1, parallelKS%nLocalKS
      iK = parallelKS%localKS(1, iKS)
      call env%globalTimer%startTimer(globalTimers%sparseToDense)
    #:if WITH_SCALAPACK
      if (allocated(ints%iHamiltonian)) then
        call unpackHPauliBlacs(env%blacs, ints%hamiltonian, kPoint(:,iK), neighbourList%iNeighbour,&
            & nNeighbourSK, iCellVec, cellVec, iSparseStart, img2CentCell, orb%mOrb, denseDesc,&
            & HSqrCplx, iorig=ints%iHamiltonian)
      else
        call unpackHPauliBlacs(env%blacs, ints%hamiltonian, kPoint(:,iK), neighbourList%iNeighbour,&
            & nNeighbourSK, iCellVec, cellVec, iSparseStart, img2CentCell, orb%mOrb, denseDesc,&
            & HSqrCplx)
      end if
      if (.not. electronicSolver%hasCholesky(iKS)) then
        call unpackSPauliBlacs(env%blacs, ints%overlap, kPoint(:,iK), neighbourList%iNeighbour,&
            & nNeighbourSK, iCellVec, cellVec, iSparseStart, img2CentCell, orb%mOrb, denseDesc,&
            & SSqrCplx)
      end if
    #:else
      if (allocated(ints%iHamiltonian)) then
        call unpackHPauli(ints%hamiltonian, kPoint(:,iK), neighbourList%iNeighbour, nNeighbourSK,&
            & iSparseStart, denseDesc%iAtomStart, img2CentCell, iCellVec, cellVec, HSqrCplx,&
            & iHam=ints%iHamiltonian)
      else
        call unpackHPauli(ints%hamiltonian, kPoint(:,iK), neighbourList%iNeighbour, nNeighbourSK,&
            & iSparseStart, denseDesc%iAtomStart, img2CentCell, iCellVec, cellVec, HSqrCplx)
      end if
      call unpackSPauli(ints%overlap, kPoint(:,iK), neighbourList%iNeighbour, nNeighbourSK,&
          & denseDesc%iAtomStart, iSparseStart, img2CentCell, iCellVec, cellVec, SSqrCplx)
    #:endif
      if (allocated(xi) .and. .not. allocated(ints%iHamiltonian)) then
        call addOnsiteSpinOrbitHam(env, xi, species, orb, denseDesc, HSqrCplx)
      end if
      call env%globalTimer%stopTimer(globalTimers%sparseToDense)
    #:if WITH_SCALAPACK

      if (allocated(apiCallBack)) then
        call apiCallBack%invokeHSCallBack(parallelKS%localKS(:,iKS),&
            & electronicSolver%hasCholesky(iKS), SSqrCplx, HSqrCplx, denseDesc)
      endif

      call diagDenseMtxBlacs(env, electronicSolver, iKS, 'V', denseDesc%blacsOrbSqr, HSqrCplx,&
          & SSqrCplx, eigen(:,iK), eigvecsCplx(:,:,iKS), errStatus)
      @:PROPAGATE_ERROR(errStatus)

    #:else

      if (allocated(apiCallBack)) then
        call apiCallBack%invokeHSCallBack(parallelKS%localKS(:,iKS),&
            & electronicSolver%hasCholesky(iKS), SSqrCplx, HSqrCplx)
      endif

      call diagDenseMtx(env, electronicSolver, 'V', HSqrCplx, SSqrCplx, eigen(:,iK), errStatus)
      @:PROPAGATE_ERROR(errStatus)
      eigvecsCplx(:,:,iKS) = HSqrCplx

    #:endif
    end do

  #:if WITH_SCALAPACK
    call mpifx_allreduceip(env%mpi%interGroupComm, eigen, MPI_SUM)
  #:endif

  end subroutine buildAndDiagDensePauliHam


  !> Creates sparse density matrix from real eigenvectors.
  subroutine getDensityFromRealEigvecs(env, denseDesc, filling, neighbourList, nNeighbourSK,&
      & iSparseStart, img2CentCell, orb, species, coord, tPeriodic, tHelical, eigvecs, parallelKS,&
      & densityMatrix, rhoPrim, work, rhoSqrReal, hybridXc, apiCallBack, errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Filling
    real(dp), intent(in) :: filling(:,:)

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Species of atoms
    integer, intent(in), optional :: species(:)

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> All coordinates
    real(dp), intent(in) :: coord(:,:)

    !> Is the system periodic (gamma)?
    logical, intent(in) :: tPeriodic

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Eigenvectors
    real(dp), intent(inout) :: eigvecs(:,:,:)

    !> Holds density generation settings and real-space delta density matrix
    type(TDensityMatrix), intent(inout) :: densityMatrix

    !> Sparse density matrix
    real(dp), intent(out) :: rhoPrim(:,:)

    !> Work space array
    real(dp), intent(out) :: work(:,:)

    !> Dense density matrix if needed
    real(dp), intent(inout), allocatable  :: rhoSqrReal(:,:,:)

    !> Data for hybrid xc-functional calculation
    class(THybridXcFunc), intent(in), allocatable :: hybridXc

    !> Object for invocation of the density, overlap, and hamiltonian matrices exporting callbacks
    type(Tapicallback), intent(in), allocatable :: apiCallBack

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    integer :: iKS, iK, iSpin

    rhoPrim(:,:) = 0.0_dp

    do iKS = 1, parallelKS%nLocalKS
      iSpin = parallelKS%localKS(2, iKS)

    #:if WITH_SCALAPACK
      if (.not. allocated(densityMatrix%deltaRhoOut)) then
        call makeDensityMtxRealBlacs(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr,&
            & filling(:,iSpin), eigvecs(:,:,iKS), work)
        call env%globalTimer%startTimer(globalTimers%denseToSparse)
        if (tHelical) then
          call packRhoHelicalRealBlacs(env%blacs, denseDesc, work, neighbourList%iNeighbour,&
              & nNeighbourSK, iSparseStart, img2CentCell, orb, species, coord, rhoPrim(:,iSpin))
        else
          call packRhoRealBlacs(env%blacs, denseDesc, work, neighbourList%iNeighbour,&
              & nNeighbourSK, orb%mOrb, iSparseStart, img2CentCell, rhoPrim(:,iSpin))
        end if
        call env%globalTimer%stopTimer(globalTimers%denseToSparse)
      else
        call makeDensityMtxRealBlacs(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr,&
            & filling(:,iSpin), eigvecs(:,:,iKS), densityMatrix%deltaRhoOut(:,:,iKS))
        call env%globalTimer%startTimer(globalTimers%denseToSparse)
        if (tHelical) then
          call packRhoHelicalRealBlacs(env%blacs, denseDesc, densityMatrix%deltaRhoOut(:,:,iKS),&
              & neighbourList%iNeighbour, nNeighbourSK, iSparseStart, img2CentCell, orb, species,&
              & coord, rhoPrim(:,iSpin))
        else
          call packRhoRealBlacs(env%blacs, denseDesc, densityMatrix%deltaRhoOut(:,:,iKS),&
              & neighbourList%iNeighbour, nNeighbourSK, orb%mOrb, iSparseStart, img2CentCell,&
              & rhoPrim(:,iSpin))
        end if
        call env%globalTimer%stopTimer(globalTimers%denseToSparse)
      end if
    #:else

      ! Either pack density matrix or delta density matrix
      if (.not. allocated(densityMatrix%deltaRhoOut)) then
        call densityMatrix%getDensityMatrix(work, eigvecs(:,:,iKS), filling(:,iSpin), errStatus)
        @:PROPAGATE_ERROR(errStatus)
        call env%globalTimer%startTimer(globalTimers%denseToSparse)
        if (tHelical) then
          call packHelicalHS(rhoPrim(:,iSpin), work, neighbourlist%iNeighbour, nNeighbourSK,&
              & denseDesc%iAtomStart, iSparseStart, img2CentCell, orb, species, coord)
        else
          call packHS(rhoPrim(:,iSpin), work, neighbourlist%iNeighbour, nNeighbourSK, orb%mOrb,&
              & denseDesc%iAtomStart, iSparseStart, img2CentCell)
        end if
        call env%globalTimer%stopTimer(globalTimers%denseToSparse)
      else

        ! Hybrid xc-functional: store density matrix in deltaRhoOut
        ! (at this point, deltaRhoOut still contains the full density, not yet delta-density)
        call densityMatrix%getDensityMatrix(densityMatrix%deltaRhoOut(:,:,iSpin), eigvecs(:,:,iKS),&
            & filling(:,iSpin), errStatus)
        @:PROPAGATE_ERROR(errStatus)

        call env%globalTimer%startTimer(globalTimers%denseToSparse)
        if (tHelical) then
          call packHelicalHS(rhoPrim(:,iSpin), densityMatrix%deltaRhoOut(:,:,iSpin),&
              & neighbourlist%iNeighbour, nNeighbourSK, denseDesc%iAtomStart, iSparseStart,&
              & img2CentCell, orb, species, coord)
        else
          call packHS(rhoPrim(:,iSpin), densityMatrix%deltaRhoOut(:,:,iSpin),&
              & neighbourlist%iNeighbour, nNeighbourSK, orb%mOrb, denseDesc%iAtomStart,&
              & iSparseStart, img2CentCell)
        end if
        call env%globalTimer%stopTimer(globalTimers%denseToSparse)
      end if
    #:endif

      if (allocated(apiCallBack)) then
        iK = parallelKS%localKS(1, iKS)
      #:if WITH_SCALAPACK
        call apiCallBack%invokeDM(iK, iSpin, work, denseDesc%blacsOrbSqr)
      #:else
        call apiCallBack%invokeDM(iK, iSpin, work)
      #:endif
      endif

      ! Store full density matrix for linear-response excited gradient evaluation
      ! (at this point equivalent to deltaRhoOut, but deltaRhoOut is later transformed into
      ! delta-density, therefore we store it separately for now)
      if (allocated(rhoSqrReal)) then
        if (.not. allocated(densityMatrix%deltaRhoOut)) then
          rhoSqrReal(:,:, iSpin) = work
        else
          rhoSqrReal(:,:, iSpin) = densityMatrix%deltaRhoOut(:,:,iSpin)
        end if
      end if

    end do

  #:if WITH_SCALAPACK
    if (allocated(hybridXc)) then
      if (allocated(densityMatrix%deltaRhoOut) .and. hybridXc%hybridXcAlg ==&
          & hybridXcAlgo%matrixBased) then
        ! Add up and distribute density matrix contribution from each group
        call mpifx_allreduceip(env%mpi%globalComm, rhoPrim, MPI_SUM)
      end if
    else
      if (.not. allocated(densityMatrix%deltaRhoOut)) then
        ! Add up and distribute density matrix contribution from each group
        call mpifx_allreduceip(env%mpi%globalComm, rhoPrim, MPI_SUM)
      end if
    end if
  #:endif

  end subroutine getDensityFromRealEigvecs


  !> Creates sparse density matrix from complex eigenvectors.
  subroutine getDensityFromCplxEigvecs(env, denseDesc, filling, kPoint, kWeight, neighbourList,&
      & nNeighbourSK, iSparseStart, img2CentCell, iCellVec, cellVec, orb, parallelKS, tHelical,&
      & species, coord, eigvecs, densityMatrix, rhoPrim, work, hybridXc, apiCallBack, errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Occupations of single particle states in the ground state
    real(dp), intent(in) :: filling(:,:,:)

    !> The k-points
    real(dp), intent(in) :: kPoint(:,:)

    !> Weights for k-points
    real(dp), intent(in) :: kWeight(:)

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Species for atoms
    integer, intent(in) :: species(:)

    !> All coordinates
    real(dp), intent(in) :: coord(:,:)

    !> Eigenvectors of the system
    complex(dp), intent(inout) :: eigvecs(:,:,:)

    !> Holds real and complex delta density matrices and pointers
    type(TDensityMatrix), intent(inout) :: densityMatrix

    !> Density matrix in sparse storage
    real(dp), intent(out) :: rhoPrim(:,:)

    !> Workspace array
    complex(dp), intent(out) :: work(:,:)

    !> Data for hybrid xc-functional calculation
    class(THybridXcFunc), intent(in), allocatable :: hybridXc

    !> Object for invocation of the density, overlap, and hamiltonian matrices exporting callbacks
    type(Tapicallback), intent(in), allocatable :: apiCallBack

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    !! K-point-spin composite index and k-point/spin index
    integer :: iKS, iK, iSpin

    rhoPrim(:,:) = 0.0_dp

    if (allocated(densityMatrix%deltaRhoOutCplx)) then
      densityMatrix%deltaRhoOutCplx(:,:,:) = (0.0_dp, 0.0_dp)
    end if

    do iKS = 1, parallelKS%nLocalKS
      iK = parallelKS%localKS(1, iKS)
      iSpin = parallelKS%localKS(2, iKS)
    #:if WITH_SCALAPACK
      call makeDensityMtxCplxBlacs(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr, filling(:,iK&
          &,iSpin), eigvecs(:,:,iKS), work)
      call env%globalTimer%startTimer(globalTimers%denseToSparse)
      if (tHelical) then
        call packRhoHelicalCplxBlacs(env%blacs, denseDesc, work, kPoint(:,iK), kWeight(iK),&
            & neighbourList%iNeighbour, nNeighbourSK, iCellVec, cellVec, iSparseStart,&
            & img2CentCell, orb, species, coord, rhoPrim(:,iSpin))
      else
        call packRhoCplxBlacs(env%blacs, denseDesc, work, kPoint(:,iK), kWeight(iK),&
            & neighbourList%iNeighbour, nNeighbourSK, orb%mOrb, iCellVec, cellVec, iSparseStart,&
            & img2CentCell, rhoPrim(:,iSpin))
      end if
      call env%globalTimer%stopTimer(globalTimers%denseToSparse)
    #:else
      call densityMatrix%getDensityMatrix(work, eigvecs(:,:,iKS), filling(:,iK,iSpin), errStatus)
      @:PROPAGATE_ERROR(errStatus)
      call env%globalTimer%startTimer(globalTimers%denseToSparse)
      if (tHelical) then
        call packHelicalHS(rhoPrim(:,iSpin), work, kPoint(:,iK), kWeight(iK),&
            & neighbourList%iNeighbour, nNeighbourSK, orb%mOrb, iCellVec, cellVec,&
            & denseDesc%iAtomStart, iSparseStart, img2CentCell, orb, species, coord)
      else
        ! Square density matrix "work" at certain k-point --> sparse form "rhoPrim"
        call packHS(rhoPrim(:,iSpin), work, kPoint(:,iK), kWeight(iK), neighbourList%iNeighbour,&
            & nNeighbourSK, orb%mOrb, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart,&
            & img2CentCell)
      end if
      call env%globalTimer%stopTimer(globalTimers%denseToSparse)
    #:endif
      if (allocated(hybridXc)) then
        ! Store square density matrix P(iKS), since currently needed for q0 substraction
        call adjointLowerTriangle(work)
        if (hybridXc%hybridXcAlg == hybridXcAlgo%matrixBased) then
          densityMatrix%deltaRhoOutCplx(:,:, densityMatrix%iKiSToiGlobalKS(iK, iSpin)) = work
        else
          densityMatrix%deltaRhoOutCplx(:,:, iKS) = work
        end if
      end if

      if (allocated(apiCallBack)) then
        iK = parallelKS%localKS(1, iKS)
      #:if WITH_SCALAPACK
        call apiCallBack%invokeDM(iK, iSpin, work, denseDesc%blacsOrbSqr)
      #:else
        call apiCallBack%invokeDM(iK, iSpin, work)
      #:endif
      endif

    end do

  #:if WITH_SCALAPACK
    ! Add up and distribute density matrix contribution from each group
    call mpifx_allreduceip(env%mpi%globalComm, rhoPrim, MPI_SUM)

    ! Add up and distribute density matrix contribution from each process
    if (allocated(hybridXc)) then
      if (hybridXc%hybridXcAlg == hybridXcAlgo%matrixBased) then
        call mpifx_allreduceip(env%mpi%globalComm, densityMatrix%deltaRhoOutCplx, MPI_SUM)
      end if
    end if
  #:endif

  end subroutine getDensityFromCplxEigvecs


  !> Creates sparse density matrix from two component complex eigenvectors.
  subroutine getDensityFromPauliEigvecs(env, denseDesc, tRealHS, tSpinOrbit, tDualSpinOrbit,&
      & tMulliken, kPoint, kWeight, filling, neighbourList, nNeighbourSK, orb, iSparseStart,&
      & img2CentCell, iCellVec, cellVec, species, parallelKS, eigvecs, work, dftbEnergy,&
      & densityMatrix, rhoPrim, xi, orbitalL, iRhoPrim, apiCallBack, errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Is the hamiltonian real (no k-points/molecule/gamma point)?
    logical, intent(in) :: tRealHS

    !> Are spin orbit interactions present
    logical, intent(in) :: tSpinOrbit

    !> Are block population spin orbit interactions present
    logical, intent(in) :: tDualSpinOrbit

    !> Should Mulliken populations be generated/output
    logical, intent(in) :: tMulliken

    !> The k-points
    real(dp), intent(in) :: kPoint(:,:)

    !> Weights for k-points
    real(dp), intent(in) :: kWeight(:)

    !> Occupations of molecular orbitals/Bloch states
    real(dp), intent(in) :: filling(:,:)

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> Species of all atoms in the system
    integer, intent(in) :: species(:)

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Eigenvectors
    complex(dp), intent(inout) :: eigvecs(:,:,:)

    !> Work space array
    complex(dp), intent(inout) :: work(:,:)

    !> Energy contributions and total
    type(TEnergies), intent(inout) :: dftbEnergy

    !> Holds real and complex delta density matrices and pointers
    type(TDensityMatrix), intent(inout) :: densityMatrix

    !> Sparse stored density matrix
    real(dp), intent(out) :: rhoPrim(:,:)

    !> Spin orbit constants
    real(dp), intent(in), allocatable :: xi(:,:)

    !> Angular momentum of atomic shells
    real(dp), intent(inout), allocatable :: orbitalL(:,:,:)

    !> Imaginary part of density matrix  if required
    real(dp), intent(inout), allocatable :: iRhoPrim(:,:)

    !> Object for invocation of the density, overlap, and hamiltonian matrices exporting callbacks
    type(Tapicallback), intent(in), allocatable :: apiCallBack

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    real(dp), allocatable :: rVecTemp(:), orbitalLPart(:,:,:)
    integer :: nAtom
    integer :: iKS, iK
    logical :: tImHam

    nAtom = size(orb%nOrbAtom)
    tImHam = allocated(iRhoPrim)

    rhoPrim(:,:) = 0.0_dp
    if (allocated(iRhoPrim)) then
      iRhoPrim(:,:) = 0.0_dp
    end if
    work(:,:) = 0.0_dp

    if (tSpinOrbit .and. .not. tDualSpinOrbit) then
      dftbEnergy%atomLS(:) = 0.0_dp
      allocate(rVecTemp(nAtom))
    end if

    if (tMulliken .and. tSpinOrbit .and. .not. tDualSpinOrbit) then
      allocate(orbitalLPart(3, orb%mShell, nAtom))
      orbitalL(:,:,:) = 0.0_dp
    end if

    do iKS = 1, parallelKS%nLocalKS
      iK = parallelKS%localKS(1, iKS)

    #:if WITH_SCALAPACK
      call makeDensityMtxCplxBlacs(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr, filling(:,iK),&
          & eigvecs(:,:,iKS), work)
    #:else
      call densityMatrix%getDensityMatrix(work, eigvecs(:,:,iKS), filling(:,iK), errStatus)
      @:PROPAGATE_ERROR(errStatus)
    #:endif

      if (allocated(apiCallBack)) then
        iK = parallelKS%localKS(1, iKS)
      #:if WITH_SCALAPACK
        call apiCallBack%invokeDM(iK, 1, work, denseDesc%blacsOrbSqr)
      #:else
        call apiCallBack%invokeDM(iK, 1, work)
      #:endif
      endif

      if (tSpinOrbit .and. .not. tDualSpinOrbit) then
        call getOnsiteSpinOrbitEnergy(env, rVecTemp, work, denseDesc, xi, orb, species)
        dftbEnergy%atomLS = dftbEnergy%atomLS + kWeight(iK) * rVecTemp
        if (tMulliken) then
          orbitalLPart(:,:,:) = 0.0_dp
          call getLOnsite(env, orbitalLPart, work, denseDesc, orb, species)
          orbitalL(:,:,:) = orbitalL + kWeight(iK) * orbitalLPart
        end if
      end if

      call env%globalTimer%startTimer(globalTimers%denseToSparse)
    #:if WITH_SCALAPACK
      if (tImHam) then
        call packRhoPauliBlacs(env%blacs, denseDesc, work, kPoint(:,iK), kWeight(iK),&
            & neighbourList%iNeighbour, nNeighbourSK, orb%mOrb, iCellVec, cellVec, iSparseStart,&
            & img2CentCell, rhoPrim, iRhoPrim)
      else
        call packRhoPauliBlacs(env%blacs, denseDesc, work, kPoint(:,iK), kWeight(iK),&
            & neighbourList%iNeighbour, nNeighbourSK, orb%mOrb, iCellVec, cellVec, iSparseStart,&
            & img2CentCell, rhoPrim)
      end if
    #:else
      if (tRealHS) then
        call packHSPauli(rhoPrim, work, neighbourlist%iNeighbour, nNeighbourSK, orb%mOrb,&
            & denseDesc%iAtomStart, iSparseStart, img2CentCell)
        if (tImHam) then
          call packHSPauliImag(iRhoPrim, work, neighbourlist%iNeighbour, nNeighbourSK, orb%mOrb,&
              & denseDesc%iAtomStart, iSparseStart, img2CentCell)
        end if
      else
        call packHS(rhoPrim, work, kPoint(:,iK), kWeight(iK), neighbourList%iNeighbour,&
            & nNeighbourSK, orb%mOrb, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart,&
            & img2CentCell)
        if (tImHam) then
          call iPackHS(iRhoPrim, work, kPoint(:,iK), kWeight(iK), neighbourlist%iNeighbour,&
              & nNeighbourSK, orb%mOrb, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart,&
              & img2CentCell)
        end if
      end if
    #:endif
      call env%globalTimer%stopTimer(globalTimers%denseToSparse)

    end do

  #:if WITH_SCALAPACK
    call env%globalTimer%startTimer(globalTimers%denseToSparse)
    ! Add up and distribute contributions from each group
    call mpifx_allreduceip(env%mpi%globalComm, rhoPrim, MPI_SUM)
    if (allocated(iRhoPrim)) then
      call mpifx_allreduceip(env%mpi%globalComm, iRhoPrim, MPI_SUM)
    end if
    call mpifx_allreduceip(env%mpi%globalComm, dftbEnergy%atomLS, MPI_SUM)
    if (tMulliken .and. tSpinOrbit .and. .not. tDualSpinOrbit) then
      call mpifx_allreduceip(env%mpi%globalComm, orbitalL, MPI_SUM)
    end if
    call env%globalTimer%stopTimer(globalTimers%denseToSparse)
  #:endif
    if (tSpinOrbit .and. .not. tDualSpinOrbit) then
      dftbEnergy%ELS = sum(dftbEnergy%atomLS)
    end if

  end subroutine getDensityFromPauliEigvecs


  !> Calculates electron fillings and resulting band energy terms.
  subroutine getFillingsAndBandEnergies(eigvals, nElectrons, nSpinBlocks, tempElec, kWeights,&
      & tSpinSharedEf, tFillKSep, tFixEf, iDistribFn, Ef, fillings, Eband, TS, E0, deltaDftb)

    !> Eigenvalue of each level, kpoint and spin channel
    real(dp), intent(inout) :: eigvals(:,:,:)

    !> Nr. of electrons for each spin channel
    real(dp), intent(in) :: nElectrons(:)

    !> Nr. of spin blocks in the Hamiltonian (1 - spin avg, 2 - colinear, 4 - non-colinear)
    integer, intent(in) :: nSpinBlocks

    !> Electronic temperature
    real(dp), intent(in) :: tempElec

    !> Weight of the k-points.
    real(dp), intent(in) :: kWeights(:)

    !> Whether for colinear spin a common Fermi level for both spin channels should be used
    logical, intent(in) :: tSpinSharedEf

    !> Whether each K-point should be filled separately (individual Fermi-level for each k-point)
    logical, intent(in) :: tFillKSep

    !> Whether fixed Fermi level(s) should be used. (No charge conservation!)
    logical, intent(in) :: tFixEf

    !> Selector for the distribution function
    integer, intent(in) :: iDistribFn

    !> Fixed Fermi levels on entry, if tFixEf is .true., otherwise the Fermi levels found for the
    !> given number of electrons on exit
    real(dp), intent(inout) :: Ef(:)

    !> Fillings (orbital, kpoint, spin)
    real(dp), intent(out) :: fillings(:,:,:)

    !> Band energies
    real(dp), intent(out) :: Eband(:)

    !> Band entropies
    real(dp), intent(out) :: TS(:)

    !> Band energies extrapolated to zero Kelvin
    real(dp), intent(out) :: E0(:)

    !> Determinant derived type
    type(TDftbDeterminants), intent(inout) :: deltaDftb

    real(dp) :: EbandTmp(2), TSTmp(2), E0Tmp(2), EfTmp(2), nElecFill(2), kWeightTmp(2)
    integer :: nSpinHams, nKPoints, nLevels, iS, iK

    nLevels = size(fillings, dim=1)
    nKPoints = size(fillings, dim=2)
    nSpinHams = size(fillings, dim=3)

    if (nSpinBlocks == 1) then
      ! Filling functions assume one electron per level, but for spin unpolarised we have two
      nElecFill(1) = 0.5_dp * nElectrons(1)
    else
      nElecFill(:nSpinHams) = nElectrons(:nSpinHams)
    end if

    if (tFixEf) then
      ! Fixed value of the Fermi level for each spin channel
      do iS = 1, nSpinHams
        call electronFill(Eband(iS:iS), fillings(:,:,iS:iS), TS(iS:iS), E0(iS:iS), Ef(iS),&
            & eigvals(:,:,iS:iS), tempElec, iDistribFn, kWeights)
      end do
    else if (nSpinHams == 2 .and. tSpinSharedEf) then
      ! Common Fermi level across two colinear spin channels
      TS(:) = 0.0_dp
      E0(:) = 0.0_dp
      Eband(:) = 0.0_dp
      call Efilling(Eband, Ef(1), TS, E0, fillings, eigvals, sum(nElecFill), tempElec, kWeights,&
          & iDistribFn)
      Ef(2) = Ef(1)
    else if (tFillKSep) then
      ! Every spin channel and every k-point filled up individually.
      Eband(:) = 0.0_dp
      Ef(:) = 0.0_dp
      TS(:) = 0.0_dp
      E0(:) = 0.0_dp
      kWeightTmp(:) = 1.0_dp
      do iK = 1, nKPoints
        call deltaDftb%detFilling(fillings(:,iK:iK,:), EBandTmp(:nSpinHams), EfTmp, TSTmp, E0Tmp,&
            & nElecFill, eigVals(:,iK:iK,:), tempElec, kWeightTmp(:nSpinHams), iDistribFn)
        Eband(:) = Eband + EbandTmp(:nSpinHams) * kWeights(iK)
        Ef(:) = Ef + EfTmp(:nSpinHams) * kWeights(iK)
        TS(:) = TS + TSTmp(:nSpinHams) * kWeights(iK)
        E0(:) = E0 + E0Tmp(:nSpinHams) * kWeights(iK)
      end do
    else
      call deltaDftb%detFilling(fillings, EBand, Ef, TS, E0, nElecFill, eigVals, tempElec,&
          & kWeights, iDistribFn)
    end if

    if (nSpinBlocks == 1) then
      ! Prefactor 2 for spin unpolarised calculations
      Eband(:) = 2.0_dp * Eband
      E0(:) = 2.0_dp * E0
      TS(:) = 2.0_dp * TS
      fillings(:,:,:) = 2.0_dp * fillings
    end if

  end subroutine getFillingsAndBandEnergies


  !> Calculate Mulliken population from sparse density matrix.
  subroutine getMullikenPopulation(env, rhoPrim, ints, orb, neighbourList, nNeighbourSK,&
      & img2CentCell, iSparseStart, qOrb, iRhoPrim, qBlock, qiBlock, qNetAtom, multipoles)

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> Sparse density matrix
    real(dp), intent(in) :: rhoPrim(:,:)

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Atomic neighbours
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each atom within overlap distance
    integer, intent(in) :: nNeighbourSK(:)

    !> Image to actual atom indexing
    integer, intent(in) :: img2CentCell(:)

    !> Sparse matrix indexing array
    integer, intent(in) :: iSparseStart(:,:)

    !> Orbital charges
    real(dp), intent(out) :: qOrb(:,:,:)

    !> Imaginary part of density matrix
    real(dp), intent(in), allocatable :: iRhoPrim(:,:)

    !> Dual atomic charges
    real(dp), intent(inout), allocatable :: qBlock(:,:,:,:)

    !> Imaginary part of dual atomic charges
    real(dp), intent(inout), allocatable :: qiBlock(:,:,:,:)

    !> Onsite Mulliken charges per atom
    real(dp), intent(inout), allocatable :: qNetAtom(:)

    !> Multipole moments
    type(TMultipole), intent(inout), optional :: multipoles

    integer :: iSpin

    qOrb(:,:,:) = 0.0_dp
    do iSpin = 1, size(rhoPrim, dim=2)
      call mulliken(env, qOrb(:,:,iSpin), ints%overlap, rhoPrim(:,iSpin), orb,&
          & neighbourList%iNeighbour, nNeighbourSK, img2CentCell, iSparseStart)
    end do

    if (allocated(qBlock)) then
      qBlock(:,:,:,:) = 0.0_dp
      do iSpin = 1, size(rhoPrim, dim=2)
        call mulliken(env, qBlock(:,:,:,iSpin), ints%overlap, rhoPrim(:,iSpin), orb,&
            & neighbourList%iNeighbour, nNeighbourSK, img2CentCell, iSparseStart)
      end do
    end if

    if (allocated(qiBlock)) then
      qiBlock(:,:,:,:) = 0.0_dp
      do iSpin = 1, size(iRhoPrim, dim=2)
        call skewMulliken(env, qiBlock(:,:,:,iSpin), ints%overlap, iRhoPrim(:,iSpin), orb,&
            & neighbourList%iNeighbour, nNeighbourSK, img2CentCell, iSparseStart)
      end do
    end if

    if (allocated(qNetAtom)) then
      call getOnsitePopulation(rhoPrim(:,1), orb, iSparseStart, qNetAtom)
    end if

    if (present(multipoles)) then

      if (allocated(multipoles%dipoleAtom)) then
        call getAtomicMultipolePopulation(multipoles%dipoleAtom, ints%dipoleBra, ints%dipoleKet, &
            & rhoPrim, orb, neighbourList%iNeighbour, nNeighbourSK, img2CentCell, &
            & iSparseStart)
      end if

      if (allocated(multipoles%quadrupoleAtom)) then
        call getAtomicMultipolePopulation(multipoles%quadrupoleAtom, ints%quadrupoleBra,&
            & ints%quadrupoleKet, rhoPrim, orb, neighbourList%iNeighbour, nNeighbourSK,&
            & img2CentCell, iSparseStart)
      end if

    end if

  end subroutine getMullikenPopulation


  !> Checks for the presence of a stop file on disc.
  function hasStopFile(fileName) result(tStop)

    !> Name of file to check for
    character(*), intent(in) :: fileName

    !> Is the file present
    logical :: tStop

    inquire(file=fileName, exist=tStop)
    if (tStop) then
      write(stdOut, "(3A)") "Stop file '" // fileName // "' found."
    end if

  end function hasStopFile


  !> Returns input charges for next SCC iteration.
  subroutine getNextInputCharges(env, pChrgMixerReal, qOutput, qOutRed, orb, nIneqOrb, iEqOrbitals,&
      & iGeoStep, iSccIter, minSccIter, maxSccIter, sccTol, tStopScc, tMixBlockCharges, tReadChrg,&
      & qInput, qInpRed, sccErrorQ, tConverged, dftbU, qBlockOut, iEqBlockDftbU, qBlockIn,&
      & qiBlockOut, iEqBlockDftbuLS, species0, qiBlockIn, iEqBlockOnSite, iEqBlockOnSiteLS,&
      & nIneqDip, nIneqQuad, multipoleOut, multipoleInp)

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> Charge mixing object
    type(TMixerReal), intent(inout) :: pChrgMixerReal

    !> Output electrons
    real(dp), intent(inout) :: qOutput(:,:,:)

    !> Output electrons reduced by unique orbital types
    real(dp), intent(inout) :: qOutRed(:)

    !> Atomic orbital data
    type(TOrbitals), intent(in) :: orb

    !> Total number of inequivalent atomic orbitals
    integer, intent(in) :: nIneqOrb

    !> Equivalence relations between orbitals
    integer, intent(in) :: iEqOrbitals(:,:,:)

    !> Number of current geometry step
    integer, intent(in) :: iGeoStep

    !> Number of current SCC step
    integer, intent(in) :: iSccIter

    !> Minimum number of SCC iterations to perform
    integer, intent(in) :: minSccIter

    !> Maximum number of SCC iterations before terminating loop
    integer, intent(in) :: maxSccIter

    !> Tolerance on SCC charges between input and output
    real(dp), intent(in) :: sccTol

    !> Should the SCC loop stop
    logical, intent(in) :: tStopScc

    !> Are orbital potentials being used
    logical, intent(in) :: tMixBlockCharges

    !> Were initial charges read from disc?
    logical, intent(in) :: tReadChrg

    !> Resulting input charges for next SCC iteration
    real(dp), intent(inout) :: qInput(:,:,:)

    !> Equivalence reduced input charges
    real(dp), intent(inout) :: qInpRed(:)

    !> Self-consistency error
    real(dp), intent(out) :: sccErrorQ

    !> Has the calculation converged
    logical, intent(out) :: tConverged

    !> Are there orbital potentials present
    type(TDftbU), intent(in), allocatable :: dftbU

    !> Dual output charges
    real(dp), intent(inout), allocatable :: qBlockOut(:,:,:,:)

    !> Equivalence mapping for dual charge blocks
    integer, intent(in), allocatable :: iEqBlockDftbu(:,:,:,:)

    !> Block charge input (if needed for orbital potentials)
    real(dp), intent(inout), allocatable :: qBlockIn(:,:,:,:)

    !> Imaginary part of block charges
    real(dp), intent(in), allocatable :: qiBlockOut(:,:,:,:)

    !> Equivalence mappings in the case of spin orbit and DFTB+U
    integer, intent(in), allocatable :: iEqBlockDftbuLS(:,:,:,:)

    !> Atomic species for atoms
    integer, intent(in), allocatable :: species0(:)

    !> Imaginary part of block atomic input populations
    real(dp), intent(inout), allocatable :: qiBlockIn(:,:,:,:)

    !> Equivalences for onsite block corrections if needed
    integer, intent(in), allocatable :: iEqBlockOnSite(:,:,:,:)

    !> Equivalences for onsite block corrections if needed for imaginary elements
    integer, intent(in), allocatable :: iEqBlockOnSiteLS(:,:,:,:)

    !> Total number of inequivalent cumulative atomic dipole moments
    integer, intent(in) :: nIneqDip

    !> Total number of inequivalent cumulative atomic quadrupole moments
    integer, intent(in) :: nIneqQuad

    !> Multipole moments
    type(TMultipole), intent(inout) :: multipoleInp

    !> Multipole moments
    type(TMultipole), intent(inout) :: multipoleOut

    real(dp), allocatable :: qDiffRed(:)
    integer :: nSpin, nMix

    nSpin = size(qOutput, dim=3)

    call reduceCharges(orb, nIneqOrb, iEqOrbitals, qOutput, qOutRed, qBlockOut, iEqBlockDftbu,&
        & qiBlockOut, iEqBlockDftbuLS, iEqBlockOnSite, iEqBlockOnSiteLS)
    if (nIneqDip > 0) then
      ! FIXME: Assumes we always mix all dipole moments
      nMix = nIneqOrb
      @:ASSERT(allocated(multipoleOut%dipoleAtom))
      qOutRed(nMix+1:nMix+nIneqDip) = reshape(multipoleOut%dipoleAtom, [nIneqDip])
    end if
    if (nIneqQuad > 0) then
      ! FIXME: Assumes we always mix all quadrupole moments
      nMix = nIneqOrb + nIneqDip
      @:ASSERT(allocated(multipoleOut%quadrupoleAtom))
      qOutRed(nMix+1:nMix+nIneqQuad) = reshape(multipoleOut%quadrupoleAtom, [nIneqQuad])
    end if
    qDiffRed = qOutRed - qInpRed
    sccErrorQ = maxval(abs(qDiffRed))
    tConverged = (sccErrorQ < sccTol)&
        & .and. (iSccIter >= minSccIter .or. tReadChrg .or. iGeoStep > 0)
    if ((.not. tConverged) .and. (iSccIter /= maxSccIter .and. .not. tStopScc)) then
      ! Avoid mixing of spin unpolarised density for spin polarised cases, this is only a problem in
      ! iteration 1, as there is only the (spin unpolarised!) atomic input density at that
      ! point. (Unless charges had been initialized externally)
      if ((iSCCIter + iGeoStep) == 1 .and. (nSpin > 1 .or. tMixBlockCharges) .and. .not. tReadChrg)&
          & then
        qInpRed(:) = qOutRed
        qInput(:,:,:) = qOutput
        if (allocated(qBlockIn)) then
          qBlockIn(:,:,:,:) = qBlockOut
          if (allocated(qiBlockIn)) then
            qiBlockIn(:,:,:,:) = qiBlockOut
          end if
        end if
        multipoleInp = multipoleOut
      else
        call TMixerReal_mix(pChrgMixerReal, qInpRed, qDiffRed)
      #:if WITH_MPI
        ! Synchronise charges in order to avoid mixers that store a history drifting apart
        call mpifx_bcast(env%mpi%globalComm, qInpRed)
      #:endif
        call expandCharges(qInpRed, orb, nIneqOrb, iEqOrbitals, qInput, dftbU, qBlockIn,&
            & iEqBlockDftbu, species0, qiBlockIn, iEqBlockDftbuLS, iEqBlockOnSite, iEqBlockOnSiteLS)
        if (nIneqDip > 0) then
          ! FIXME: Assumes we always mix all dipole moments
          nMix = nIneqOrb
          multipoleInp%dipoleAtom(:,:, 1) = reshape(qInpRed(nMix+1:nMix+nIneqDip),&
              & shape(multipoleInp%dipoleAtom(:,:, 1)))
        end if
        if (nIneqQuad > 0) then
          ! FIXME: Assumes we always mix all quadrupole moments
          nMix = nIneqOrb + nIneqDip
          multipoleInp%quadrupoleAtom(:,:, 1) = reshape(qInpRed(nMix+1:nMix+nIneqQuad),&
              & shape(multipoleInp%quadrupoleAtom(:,:, 1)))
        end if
      end if
    end if

  end subroutine getNextInputCharges


  !> Update delta density matrix rather than merely q for hybrid xc-functionals.
  subroutine getNextInputDensityReal(env, parallelKS, SSqrReal, ints, neighbourList, nNeighbourSK,&
      & denseDesc, iSparseStart, img2CentCell, pChrgMixerReal, qOutput, orb, tHelical, species0,&
      & species, coord, iGeoStep, iSccIter, minSccIter, maxSccIter, sccTol, tStopScc, tReadChrg,&
      & q0, hybridXc, qInput, sccErrorQ, tConverged, densityMatrix, qBlockIn, qBlockOut, errStatus)

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Square dense overlap storage
    real(dp), allocatable, intent(inout) :: SSqrReal(:,:)

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Charge mixing object
    type(TMixerReal), intent(inout) :: pChrgMixerReal

    !> Output electrons
    real(dp), intent(inout) :: qOutput(:,:,:)

    !> Atomic orbital data
    type(TOrbitals), intent(in) :: orb

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Species for atoms
    integer, intent(in) :: species0(:)

    !> Species for atoms
    integer, intent(in) :: species(:)

    !> All coordinates
    real(dp), intent(in) :: coord(:,:)

    !> Number of current geometry step
    integer, intent(in) :: iGeoStep

    !> Number of current SCC step
    integer, intent(in) :: iSccIter

    !> Minimum number of SCC iterations to perform
    integer, intent(in) :: minSccIter

    !> Maximum number of SCC iterations before terminating loop
    integer, intent(in) :: maxSccIter

    !> Tolerance on SCC charges between input and output
    real(dp), intent(in) :: sccTol

    !> Should the SCC loop stop
    logical, intent(in) :: tStopScc

    !> Were initial charges read from disc?
    logical, intent(in) :: tReadChrg

    !> Reference charges
    real(dp), intent(in) :: q0(:,:,:)

    !> Data for hybrid xc-functional calculation
    class(THybridXcFunc), intent(in) :: hybridXc

    !> Resulting input charges for next SCC iteration
    real(dp), intent(inout) :: qInput(:,:,:)

    !> Self-consistency error
    real(dp), intent(out) :: sccErrorQ

    !> Has the calculation converged?
    logical, intent(out) :: tConverged

    !> Holds real and complex delta density matrices and pointers
    type(TDensityMatrix), intent(inout) :: densityMatrix

    !> Block charge input (if needed for orbital potentials)
    real(dp), intent(inout), allocatable :: qBlockIn(:,:,:,:)

    !> Dual output charges
    real(dp), intent(inout), allocatable :: qBlockOut(:,:,:,:)

    !> Error status
    type(tStatus), intent(inout) :: errStatus

    !! Difference of delta density matrix in and out
    real(dp), allocatable :: deltaRhoDiffSqr(:,:,:)

    !! Number of spins and spin index
    integer :: nSpin, iSpin

    !! Atom/orbital index
    integer :: iAt, iOrb

  #:if WITH_SCALAPACK
    real(dp), allocatable :: collectedDeltaRhoInSqr(:,:,:)
    real(dp), allocatable :: collectedDeltaRhoOutSqr(:,:,:)
  #:endif

    nSpin = size(qOutput, dim=3)

    deltaRhoDiffSqr = densityMatrix%deltaRhoOut - densityMatrix%deltaRhoIn
    sccErrorQ = maxval(abs(deltaRhoDiffSqr))
  #:if WITH_SCALAPACK
    call mpifx_allreduceip(env%mpi%globalComm, sccErrorQ, MPI_MAX)
  #:endif
    tConverged = (sccErrorQ < sccTol)&
        & .and. (iSCCiter >= minSCCIter .or. tReadChrg .or. iGeoStep > 0)

    if ((.not. tConverged) .and. (iSCCiter /= maxSccIter .and. .not. tStopScc)) then
      if ((iSCCIter + iGeoStep) == 1 .and. (nSpin > 1 .and. .not. tReadChrg)) then
        densityMatrix%deltaRhoIn(:,:,:) = densityMatrix%deltaRhoOut
        qInput(:,:,:) = qOutput
        if (allocated(qBlockIn)) then
          qBlockIn(:,:,:,:) = qBlockOut
        end if
      else

      #:if WITH_SCALAPACK
        if (tHelical) then
          call unpackHSHelicalRealBlacs(env%blacs, ints%overlap, neighbourList%iNeighbour,&
              & nNeighbourSK, iSparseStart, img2CentCell, orb, species, coord, denseDesc,&
              & SSqrReal)
        else
          call unpackHSRealBlacs(env%blacs, ints%overlap, neighbourList%iNeighbour, nNeighbourSK,&
              & iSparseStart, img2CentCell, denseDesc, SSqrReal)
        end if
      #:else
        if (tHelical) then
          call unpackHelicalHS(SSqrReal, ints%overlap, neighbourList%iNeighbour, nNeighbourSK,&
              & denseDesc%iAtomStart, iSparseStart, img2CentCell, orb, species, coord)
        else
          call unpackHS(SSqrReal, ints%overlap, neighbourList%iNeighbour, nNeighbourSK,&
              & denseDesc%iAtomStart, iSparseStart, img2CentCell)
        end if
      #:endif

        #:if WITH_SCALAPACK
        if (hybridXc%hybridXcAlg /= hybridXcAlgo%neighbourBased) then
          ! collect full, square delta density matrix for mixing from MPI ranks
          ! (workaround, due to serial mixers)
          call getFullFromDistributed(env, denseDesc, parallelKS, densityMatrix%deltaRhoIn,&
              & collectedDeltaRhoInSqr)
          call getFullFromDistributed(env, denseDesc, parallelKS, densityMatrix%deltaRhoOut,&
              & collectedDeltaRhoOutSqr)

          if (env%tGlobalLead) then
            ! Re-allocate difference, this time for full density collected from all MPI ranks
            deltaRhoDiffSqr = collectedDeltaRhoOutSqr - collectedDeltaRhoInSqr
            call TMixerReal_mix(pChrgMixerReal, collectedDeltaRhoInSqr, deltaRhoDiffSqr)
          end if
          ! scatter mixed full, square density matrix to MPI ranks
          call scatterFullToDistributed(env, denseDesc, parallelKS, collectedDeltaRhoInSqr,&
              & densityMatrix%deltaRhoIn)

          call denseMullikenRealBlacs(env, parallelKS, denseDesc, densityMatrix%deltaRhoIn,&
              & SSqrReal, qInput)
        end if
      #:else
        call TMixerReal_mix(pChrgMixerReal, densityMatrix%deltaRhoIn, deltaRhoDiffSqr)
        call denseMullikenReal(densityMatrix%deltaRhoIn, SSqrReal, denseDesc%iAtomStart, qInput)
      #:endif

        ! HybridXc: For spin-unrestricted calculation the initial guess should be equally
        ! distributed to alpha and beta density matrices
        if (nSpin == 2) then
          qInput(:,:,1) = qInput(:,:,1) + q0(:,:,1) * 0.5_dp
          qInput(:,:,2) = qInput(:,:,2) + q0(:,:,1) * 0.5_dp
        else
          qInput(:,:,:) = qInput + q0
        end if

        if (allocated(qBlockIn)) then
        #:if WITH_SCALAPACK
          @:RAISE_ERROR(errStatus, -1, "Dense block Mulliken routine not implemented for MPI&
              & parallel build.")
        #:else
          call denseBlockMulliken(densityMatrix%deltaRhoIn, SSqrReal, denseDesc%iAtomStart,&
              & qBlockIn)
        #:endif
          do iSpin = 1, nSpin
            do iAt = 1, size(qInput, dim=2)
              do iOrb = 1, size(qInput, dim=1)
                qBlockIn(iOrb, iOrb, iAt, iSpin) = qInput(iOrb, iAt, iSpin)
              end do
            end do
          end do
        end if

        call ud2qm(qInput)
        if (allocated(qBlockIn)) then
          call ud2qm(qBlockIn)
        end if
      end if
    end if

  end subroutine getNextInputDensityReal


  !> Update delta density matrix rather than merely q for hybrid xc-functionals.
  subroutine getNextInputDensityCplx(env, ints, neighbourList, nNeighbourSK, denseDesc,&
      & iSparseStart, img2CentCell, pChrgMixerReal, pChrgMixerCmplx, qOutput, orb, parallelKS,&
      & kPoint, kWeight, iGeoStep, iSccIter, minSccIter, maxSccIter, sccTol, tStopScc, tReadChrg,&
      & checkStopHybridCalc, q0, iCellVec, cellVec, hybridXc, qInput, sccErrorQ, tConverged,&
      & densityMatrix, qBlockIn, qBlockOut)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Charge mixing object
    type(TMixerReal), intent(inout) :: pChrgMixerReal

    !> Complex charge mixing object
    type(TMixerCmplx), intent(inout), allocatable :: pChrgMixerCmplx

    !> Output electrons
    real(dp), intent(in) :: qOutput(:,:,:)

    !> Atomic orbital data
    type(TOrbitals), intent(in) :: orb

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> The k-points
    real(dp), intent(in) :: kPoint(:,:)

    !> Weights for k-points
    real(dp), intent(in) :: kWeight(:)

    !> Number of current geometry step
    integer, intent(in) :: iGeoStep

    !> Number of current SCC step
    integer, intent(in) :: iSccIter

    !> Minimum number of SCC iterations to perform
    integer, intent(in) :: minSccIter

    !> Maximum number of SCC iterations before terminating loop
    integer, intent(in) :: maxSccIter

    !> Tolerance on SCC charges between input and output
    real(dp), intent(in) :: sccTol

    !> Should the SCC loop stop
    logical, intent(in) :: tStopScc

    !> Were initial charges read from disc?
    logical, intent(in) :: tReadChrg

    !> Should an additional check be performed if more than one SCC step is requested
    !! (indicates that the k-point sampling has changed as part of the restart)
    logical, intent(in) :: checkStopHybridCalc

    !> Reference charges
    real(dp), intent(in) :: q0(:,:,:)

    !> Index of the cell translation vector for each atom.
    integer, intent(in) :: iCellVec(:)

    !> Relative coordinates of the cell translation vectors.
    real(dp), intent(in) :: cellVec(:,:)

    !> Data for hybrid xc-functional calculation
    class(THybridXcFunc), intent(in) :: hybridXc

    !> Resulting input charges for next SCC iteration
    real(dp), intent(inout) :: qInput(:,:,:)

    !> SCC error
    real(dp), intent(out) :: sccErrorQ

    !> Has the calculation converged>
    logical, intent(out) :: tConverged

    !> Holds real and complex delta density matrices and pointers
    type(TDensityMatrix), intent(inout) :: densityMatrix

    !> Block charge input (if needed for orbital potentials)
    real(dp), intent(inout), allocatable :: qBlockIn(:,:,:,:)

    !> Dual output charges
    real(dp), intent(inout), allocatable :: qBlockOut(:,:,:,:)

    !! Number of spins and spin index
    integer :: nSpin

    !! Sparse density matrix storage
    real(dp), allocatable :: rhoPrim(:,:)

    !! Difference of delta density matrix in and out
    real(dp), allocatable :: deltaRhoDiffSqrCplxHS(:,:,:,:,:,:)
    complex(dp), allocatable :: deltaRhoDiffSqrCplx(:,:,:)

    !! K-point-spin composite index and k-point/spin index
    integer :: iKS, iK, iSpin

    nSpin = size(qOutput, dim=3)

    if (hybridXc%hybridXcAlg == hybridXcAlgo%matrixBased) then
      if (env%tGlobalLead) then
        ! if the k-point sampling changed as part of the restart (i.e. this is a bandstructure
        ! calculation), we cannot calculate the difference between the in- and output density matrix
        ! because they do not match w.r.t. the number of k-points
        if (tReadChrg .and. checkStopHybridCalc) then
          allocate(deltaRhoDiffSqrCplx(size(densityMatrix%deltaRhoOutCplx, dim=1),&
              & size(densityMatrix%deltaRhoOutCplx, dim=2),&
              & size(densityMatrix%deltaRhoOutCplx, dim=3)), source=(0.0_dp, 0.0_dp))
        else
          ! fine if the k-mesh did not change during the restart
          deltaRhoDiffSqrCplx = densityMatrix%deltaRhoOutCplx - densityMatrix%deltaRhoInCplx
        end if
        sccErrorQ = maxval(abs(deltaRhoDiffSqrCplx))
      end if
    #:if WITH_MPI
      call mpifx_bcast(env%mpi%globalComm, sccErrorQ)
    #:endif
    else
      deltaRhoDiffSqrCplxHS = densityMatrix%deltaRhoOutCplxHS - densityMatrix%deltaRhoInCplxHS
      sccErrorQ = maxval(abs(deltaRhoDiffSqrCplxHS))
    end if
    tConverged = (sccErrorQ < sccTol)&
        & .and. (iSCCiter >= minSCCIter .or. tReadChrg .or. iGeoStep > 0)

    if ((.not. tConverged) .and. (iSCCiter /= maxSccIter .and. .not. tStopScc)) then
      if ((iSCCIter + iGeoStep) == 1 .and. (nSpin > 1 .and. .not. tReadChrg)) then
        if (hybridXc%hybridXcAlg == hybridXcAlgo%matrixBased) then
          densityMatrix%deltaRhoInCplx(:,:,:) = densityMatrix%deltaRhoOutCplx
        else
          densityMatrix%deltaRhoInCplxHS(:,:,:,:,:,:) = densityMatrix%deltaRhoOutCplxHS
        end if
        qInput(:,:,:) = qOutput
        if (allocated(qBlockIn)) qBlockIn(:,:,:,:) = qBlockOut
      else

        if (hybridXc%hybridXcAlg == hybridXcAlgo%matrixBased) then
          if (env%tGlobalLead) then
            call TMixerCmplx_mix(pChrgMixerCmplx, densityMatrix%deltaRhoInCplx, deltaRhoDiffSqrCplx)
          end if
        #:if WITH_MPI
          call mpifx_bcast(env%mpi%globalComm, densityMatrix%deltaRhoInCplx)
        #:endif

          ! Construct sparse density matrix for later Mulliken analysis
          allocate(rhoPrim(size(ints%overlap), nSpin), source=0.0_dp)

          do iKS = 1, parallelKS%nLocalKS
            iK = parallelKS%localKS(1, iKS)
            iSpin = parallelKS%localKS(2, iKS)
          #:if WITH_SCALAPACK
            call env%globalTimer%startTimer(globalTimers%denseToSparse)
            call packRhoCplxBlacs(env%blacs, denseDesc,&
                & densityMatrix%deltaRhoInCplx(:,:, densityMatrix%iKiSToiGlobalKS(iK, iSpin)),&
                & kPoint(:, iK), kWeight(iK), neighbourList%iNeighbour, nNeighbourSK, orb%mOrb,&
                & iCellVec, cellVec, iSparseStart, img2CentCell, rhoPrim(:, iSpin))
            call env%globalTimer%stopTimer(globalTimers%denseToSparse)
          #:else
            call env%globalTimer%startTimer(globalTimers%denseToSparse)
            call packHS(rhoPrim(:, iSpin),&
                & densityMatrix%deltaRhoInCplx(:,:, densityMatrix%iKiSToiGlobalKS(iK, iSpin)),&
                & kPoint(:, iK), kWeight(iK), neighbourList%iNeighbour, nNeighbourSK, orb%mOrb,&
                & iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart, img2CentCell)
            call env%globalTimer%stopTimer(globalTimers%denseToSparse)
          #:endif
          end do

        #:if WITH_SCALAPACK
          ! Add up and distribute density matrix contribution from each group
          call mpifx_allreduceip(env%mpi%globalComm, rhoPrim, MPI_SUM)
        #:endif

          qInput(:,:,:) = 0.0_dp
          do iSpin = 1, size(rhoPrim, dim=2)
            call mulliken(env, qInput(:,:, iSpin), ints%overlap, rhoPrim(:, iSpin), orb,&
                & neighbourList%iNeighbour, nNeighbourSK, img2CentCell, iSparseStart)
          end do

        else ! hybridXc%hybridXcAlg /= hybridXcAlgo%matrixBased
          call TMixerReal_mix(pChrgMixerReal, densityMatrix%deltaRhoInCplxHS, deltaRhoDiffSqrCplxHS)
          call mulliken(qInput, ints%overlap, densityMatrix%deltaRhoInCplxHS, orb,&
              & neighbourList%iNeighbour, nNeighbourSK, img2CentCell, iSparseStart,&
              & denseDesc%iAtomStart, iCellVec, cellVec, hybridXc)
        end if

        ! HybridXc: for spin-unrestricted calculation the initial guess should be equally
        ! distributed to alpha and beta density matrices.
        ! Transforms net charges --> populations (i.e. number of electrons)
        if (nSpin == 2) then
          qInput(:,:,1) = qInput(:,:,1) + q0(:,:,1) * 0.5_dp
          qInput(:,:,2) = qInput(:,:,2) + q0(:,:,1) * 0.5_dp
        else
          qInput(:,:,:) = qInput + q0
        end if

        call ud2qm(qInput)

      end if
    end if

  end subroutine getNextInputDensityCplx


  !> Reduce charges according to orbital equivalency rules.
  subroutine reduceCharges(orb, nIneqOrb, iEqOrbitals, qOrb, qRed, qBlock, iEqBlockDftbu, qiBlock,&
      & iEqBlockDftbuLS, iEqBlockOnSite, iEqBlockOnSiteLS)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Number of unique types of atomic orbitals
    integer, intent(in) :: nIneqOrb

    !> Equivalence index
    integer, intent(in) :: iEqOrbitals(:,:,:)

    !> Electrons in atomic orbitals
    real(dp), intent(in) :: qOrb(:,:,:)

    !> Reduction of atomic populations
    real(dp), intent(out) :: qRed(:)

    !> Block (dual) populations, if also being reduced
    real(dp), intent(in), allocatable :: qBlock(:,:,:,:)

    !> Equivalences for block charges
    integer, intent(in), allocatable :: iEqBlockDftbu(:,:,:,:)

    !> Imaginary part of block charges if present
    real(dp), intent(in), allocatable :: qiBlock(:,:,:,:)

    !> Equivalences for spin orbit if needed
    integer, intent(in), allocatable :: iEqBlockDftbuLS(:,:,:,:)

    !> Equivalences for onsite block corrections if needed
    integer, intent(in), allocatable :: iEqBlockOnSite(:,:,:,:)

    !> Equivalences for onsite block corrections if needed for imaginary part
    integer, intent(in), allocatable :: iEqBlockOnSiteLS(:,:,:,:)

    real(dp), allocatable :: qOrbUpDown(:,:,:), qBlockUpDown(:,:,:,:)

    qRed(:) = 0.0_dp
    qOrbUpDown = qOrb
    call qm2ud(qOrbUpDown)
    call orbitalEquiv_reduce(qOrbUpDown, iEqOrbitals, orb, qRed(1:nIneqOrb))
    if (allocated(qBlock)) then
      qBlockUpDown = qBlock
      call qm2ud(qBlockUpDown)
      if (allocated(iEqBlockOnSite)) then
        ! all blocks are full of unique elements
        call onsBlock_reduce(qBlockUpDown, iEqBlockOnSite, orb, qRed)
        if (allocated(qiBlock)) then
          call onsBlock_reduce(qiBlock, iEqBlockOnSiteLS, orb, qRed, isSkew=.true.)
        end if
      else
        ! only a subset of blocks are covered in +U type operations
        call appendBlockReduced(qBlockUpDown, iEqBlockDFTBU, orb, qRed)
        if (allocated(qiBlock)) then
          call appendBlockReduced(qiBlock, iEqBlockDFTBULS, orb, qRed, isSkew=.true.)
        end if
      end if
    end if

  end subroutine reduceCharges


  !> Expand reduced charges according orbital equivalency rules.
  subroutine expandCharges(qRed, orb, nIneqOrb, iEqOrbitals, qOrb, dftbU, qBlock, iEqBlockDftbu,&
      & species0, qiBlock, iEqBlockDftbuLS, iEqBlockOnSite, iEqBlockOnSiteLS)

    !> Reduction of atomic populations
    real(dp), intent(in) :: qRed(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Number of unique types of atomic orbitals
    integer, intent(in) :: nIneqOrb

    !> Equivalence index
    integer, intent(in) :: iEqOrbitals(:,:,:)

    !> Electrons in atomic orbitals
    real(dp), intent(out) :: qOrb(:,:,:)

    !> Are there orbital potentials present
    type(TDftbU), intent(in), allocatable :: dftbU

    !> Block (dual) populations, if also stored in reduced form
    real(dp), intent(inout), allocatable :: qBlock(:,:,:,:)

    !> Equivalences for block charges
    integer, intent(in), allocatable :: iEqBlockDftbU(:,:,:,:)

    !> Species of central cell atoms
    integer, intent(in), allocatable :: species0(:)

    !> Imaginary part of block atomic populations
    real(dp), intent(inout), allocatable :: qiBlock(:,:,:,:)

    !> Equivalences for spin orbit if needed
    integer, intent(in), allocatable :: iEqBlockDftbULS(:,:,:,:)

    !> Equivalences for onsite block corrections if needed
    integer, intent(in), allocatable :: iEqBlockOnSite(:,:,:,:)

    !> Equivalences for onsite block corrections if needed for imaginary part
    integer, intent(in), allocatable :: iEqBlockOnSiteLS(:,:,:,:)

    integer :: nSpin

    @:ASSERT(allocated(qBlock) .eqv. (allocated(iEqBlockDftbU) .or. allocated(iEqBlockOnSite)))
    @:ASSERT(.not. allocated(qBlock) .or. allocated(species0))
    @:ASSERT(.not. allocated(qiBlock) .or. allocated(qBlock))
    @:ASSERT(allocated(qiBlock) .eqv. (allocated(iEqBlockDftbuLS) .or. allocated(iEqBlockOnSiteLS)))

    nSpin = size(qOrb, dim=3)
    call OrbitalEquiv_expand(qRed(1:nIneqOrb), iEqOrbitals, orb, qOrb)
    if (allocated(qBlock)) then
      qBlock(:,:,:,:) = 0.0_dp
      if (allocated(iEqBlockOnSite)) then
        ! all blocks are full of unique elements
        call Onsblock_expand(qRed, iEqBlockOnSite, orb, qBlock, orbEquiv=iEqOrbitals)
        if (allocated(qiBlock)) then
          call Onsblock_expand(qRed, iEqBlockOnSiteLS, orb, qiBlock, isSkew=.true.)
        end if
      else
        ! only a subset of blocks are covered in +U type operations
        call dftbU%expandBlock(qRed, iEqBlockDftbu, orb, qBlock, species0, orbEquiv=iEqOrbitals)
        if (allocated(qiBlock)) then
          call dftbU%expandBlock(qRed, iEqBlockDftbuLS, orb, qiBlock, species0, isSkew=.true.)
        end if
      end if
    end if
    if (nSpin == 2) then
      call ud2qm(qOrb)
      if (allocated(qBlock)) then
        call ud2qm(qBlock)
      end if
    end if

  end subroutine expandCharges


  !> Get some info about scc convergence.
  subroutine getSccInfo(iSccIter, Eelec, EelecOld, diffElec)

    !> Iteration number
    integer, intent(in) :: iSccIter

    !> Electronic energy
    real(dp), intent(in) :: Eelec

    !> Old electronic energy, overwritten on exit with current value
    real(dp), intent(inout) :: EelecOld

    !> Difference in electronic energies between iterations
    real(dp), intent(out) :: diffElec

    if (iSccIter > 1) then
      diffElec = Eelec - EelecOld
    else
      diffElec = 0.0_dp
    end if
    EelecOld = Eelec

  end subroutine getSccInfo


  !> Whether restart information needs to be written in the current scc loop.
  function needsSccRestartWriting(restartFreq, iGeoStep, iSccIter, minSccIter, maxSccIter, tMd,&
      & isGeoOpt, tDerivs, tConverged, tReadChrg, tStopScc) result(tRestart)

    !> Frequency of charge  write out
    integer, intent(in) :: restartFreq

    !> Current geometry step
    integer, intent(in) :: iGeoStep

    !> Current SCC step
    integer, intent(in) :: iSccIter

    !> Minimum number of SCC cycles to perform
    integer, intent(in) :: minSccIter

    !> Maximum number of SCC cycles to perform
    integer, intent(in) :: maxSccIter

    !> Is this molecular dynamics
    logical, intent(in) :: tMd

    !> Is there geometry optimisation
    logical, intent(in) :: isGeoOpt

    !> Are finite difference changes happening
    logical, intent(in) :: tDerivs

    !> Is this converged SCC
    logical, intent(in) :: tConverged

    !> Have the charges been read from disc
    logical, intent(in) :: tReadChrg

    !> Has the SCC cycle been stopped?
    logical, intent(in) :: tStopScc

    !> Resulting decision as to whether to write charges to disc
    logical :: tRestart

    logical :: tEnoughIters, tRestartIter

    ! Do we need restart at all?
    tRestart = (restartFreq > 0 .and. .not. (tMD .or. isGeoOpt .or. tDerivs) .and. maxSccIter > 1)
    if (tRestart) then

      ! Do we have enough iterations already?
      tEnoughIters = (iSccIter >= minSccIter .or. tReadChrg .or. iGeoStep > 0)

      ! Is current iteration the right one for writing a restart file?
      tRestartIter = (iSccIter == maxSccIter .or. tStopScc .or. mod(iSccIter, restartFreq) == 0)

      tRestart = (tConverged .or. (tEnoughIters .and. tRestartIter))
    end if

  end function needsSccRestartWriting


  !> Do the linear response excitation calculation.
  subroutine calculateLinRespExcitations(env, linearResponse, parallelKS, sccCalc, qOutput, q0,&
      & ints, eigvecsReal, eigen, filling, coord, species, speciesName, orb, skHamCont,&
      & skOverCont, autotestTag, taggedWriter, runId, neighbourList, nNeighbourSk, denseDesc,&
      & iSparseStart, img2CentCell, tWriteAutotest, tForces, tLinRespZVect, tPrintExcEigvecs,&
      & tPrintExcEigvecsTxt, nonSccDeriv, dftbEnergy, energies, work, rhoSqrReal, deltaRhoOut,&
      & excitedDerivs, naCouplings, occNatural, hybridXc)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Excited state settings
    type(TLinResp), intent(inout), allocatable :: linearResponse

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> SCC module internal variables
    type(TScc), intent(in) :: sccCalc

    !> Electrons in atomic orbitals
    real(dp), intent(in) :: qOutput(:,:,:)

    !> Reference atomic orbital occupations
    real(dp), intent(in) :: q0(:,:,:)

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> Ground state eigenvectors
    real(dp), intent(in) :: eigvecsReal(:,:,:)

    !> Ground state eigenvalues (orbital, kpoint)
    real(dp), intent(in) :: eigen(:,:)

    !> Ground state fillings (orbital, kpoint)
    real(dp), intent(in) :: filling(:,:)

    !> All atomic coordinates
    real(dp), intent(in) :: coord(:,:)

    !> Species of all atoms in the system
    integer, target, intent(in) :: species(:)

    !> Label for each atomic chemical species
    character(*), intent(in) :: speciesName(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Non-SCC hamiltonian information
    type(TSlakoCont), intent(in) :: skHamCont

    !> Overlap information
    type(TSlakoCont), intent(in) :: skOverCont

    !> File name for regression data
    character(*), intent(in) :: autotestTag

    !> Tagged writer
    type(TTaggedWriter), intent(inout) :: taggedWriter

    !> Job ID for future identification
    integer, intent(in) :: runId

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Should regression test data be written
    logical, intent(in) :: tWriteAutotest

    !> Forces to be calculated in the excited state
    logical, intent(in) :: tForces

    !> Require the Z vector for excited state properties
    logical, intent(in) :: tLinRespZVect

    !> Print natural orbitals of the excited state
    logical, intent(in) :: tPrintExcEigvecs

    !> Print natural orbitals also in text form?
    logical, intent(in) :: tPrintExcEigvecsTxt

    !> Method for calculating derivatives of S and H0
    type(TNonSccDiff), intent(in) :: nonSccDeriv

    !> Energy contributions and total
    type(TEnergies), intent(inout) :: dftbEnergy

    !> Energies of all solved states
    real(dp), intent(inout), allocatable :: energies(:)

    !> Working array of the size of the dense matrices.
    real(dp), intent(out) :: work(:,:)

    !> Density matrix in dense form
    real(dp), intent(inout), allocatable :: rhoSqrReal(:,:,:)

    !> Difference density matrix (vs. uncharged atoms) in dense form
    real(dp), intent(inout), allocatable :: deltaRhoOut(:,:,:)

    !> Excited state energy derivatives per state with respect to atomic coordinates
    real(dp), intent(inout), allocatable :: excitedDerivs(:,:,:)

    !> Non-adiabatic coupling vectors
    real(dp), intent(inout), allocatable :: naCouplings(:,:,:)

    !> Natural orbital occupation numbers
    real(dp), intent(inout), allocatable :: occNatural(:)

    !> Data for range-separated calculation
    class(THybridXcFunc), allocatable, intent(inout) :: hybridXc

    real(dp), allocatable :: dQAtom(:,:)
    real(dp), allocatable :: naturalOrbs(:,:,:)
    integer, pointer :: pSpecies0(:)
    integer :: iSpin, nSpin, nAtom
    logical :: tSpin
    type(TFileDescr) :: fdAutotest

    nAtom = size(qOutput, dim=2)
    nSpin = size(eigen, dim=2)
    tSpin = (nSpin == 2)
    pSpecies0 => species(1:nAtom)

    dftbEnergy%Eexcited = 0.0_dp
    allocate(dQAtom(nAtom, nSpin))
    dQAtom(:,:) = sum(qOutput(:,:,:) - q0(:,:,:), dim=1)

  #:if WITH_SCALAPACK   

    call unpackHSRealBlacs(env%blacs, ints%overlap, neighbourList%iNeighbour, nNeighbourSK,&
         & iSparseStart, img2CentCell, denseDesc, work)
  #:else
    
    call unpackHS(work, ints%overlap, neighbourList%iNeighbour, nNeighbourSK, denseDesc%iAtomStart,&
         & iSparseStart, img2CentCell)
    call adjointLowerTriangle(work) 
    
  #:endif

    if (allocated(rhoSqrReal)) then
      do iSpin = 1, nSpin
        call adjointLowerTriangle(rhoSqrReal(:,:,iSpin))
      end do
    end if
    if (tForces .and. allocated(hybridXc)) then
      do iSpin = 1, nSpin
        call adjointLowerTriangle(deltaRhoOut(:,:, iSpin))
      end do
    end if
    if (tWriteAutotest) then
      call openFile(fdAutotest, autotestTag, mode="a")
    end if
    if (tLinRespZVect) then
      if (tPrintExcEigVecs) then
        allocate(naturalOrbs(orb%nOrb, orb%nOrb, 1))
      end if
      call LinResp_addGradients(env, tSpin, linearResponse, denseDesc, eigvecsReal, eigen,&
          & work, filling, coord(:,:nAtom), sccCalc, dQAtom, pSpecies0, neighbourList%iNeighbour,&
          & img2CentCell, orb, skHamCont, skOverCont, fdAutotest, taggedWriter, hybridXc,&
          & dftbEnergy%Eexcited, energies, excitedDerivs, naCouplings, nonSccDeriv, rhoSqrReal,&
          & deltaRhoOut, occNatural, naturalOrbs)
      if (tPrintExcEigvecs) then
        call writeRealEigvecs(env, runId, neighbourList, nNeighbourSK, denseDesc, iSparseStart,&
            & img2CentCell, pSpecies0, speciesName, orb, ints%overlap, parallelKS, &
            & tPrintExcEigvecsTxt, naturalOrbs, work, fileName="excitedOrbs")
      end if
    else
      call linResp_calcExcitations(env, linearResponse, tSpin, denseDesc, eigvecsReal, eigen, work,&
          & filling, coord(:,:nAtom), sccCalc, dQAtom, pSpecies0, neighbourList%iNeighbour,&
          & img2CentCell, orb, fdAutotest, taggedWriter, hybridXc, dftbEnergy%Eexcited, energies)
    end if
    dftbEnergy%Etotal = dftbEnergy%Etotal + dftbEnergy%Eexcited
    dftbEnergy%EMermin = dftbEnergy%EMermin + dftbEnergy%Eexcited
    dftbEnergy%EGibbs = dftbEnergy%EGibbs + dftbEnergy%Eexcited

  end subroutine calculateLinRespExcitations


  !> Get the XLBOMD charges for the current geometry.
  subroutine getXlbomdCharges(xlbomdIntegrator, qOutRed, pChrgMixerReal, orb, nIneqOrb,&
      & iEqOrbitals, qInput, qInpRed, dftbU, iEqBlockDftbu, qBlockIn, species0, iEqBlockDftbuLS,&
      & qiBlockIn, iEqBlockOnSite, iEqBlockOnSiteLS)

    !> Integrator for the extended Lagrangian
    type(TXLBOMD), intent(inout) :: xlbomdIntegrator

    !> Output charges, reduced by equivalences
    real(dp), intent(in) :: qOutRed(:)

    !> SCC mixer
    type(TMixerReal), intent(inout) :: pChrgMixerReal

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Number of inequivalent orbitals
    integer, intent(in) :: nIneqOrb

    !> Equivalence map
    integer, intent(in) :: iEqOrbitals(:,:,:)

    !> Input charges
    real(dp), intent(out) :: qInput(:,:,:)

    !> Input charges reduced by equivalences
    real(dp), intent(out) :: qInpRed(:)

    !> Are there orbital potentials present
    type(TDftbU), intent(in), allocatable :: dftbU

    !> +U equivalences
    integer, intent(in), allocatable :: iEqBlockDftbU(:,:,:,:)

    !> Central cell species
    integer, intent(in), allocatable :: species0(:)

    !> Block input charges
    real(dp), intent(inout), allocatable :: qBlockIn(:,:,:,:)

    !> Equivalences for spin orbit
    integer, intent(in), allocatable :: iEqBlockDftbuLS(:,:,:,:)

    !> Imaginary part of dual charges
    real(dp), intent(inout), allocatable :: qiBlockIn(:,:,:,:)

    !> Equivalences for onsite block corrections if needed
    integer, intent(inout), allocatable :: iEqBlockOnSite(:,:,:,:)

    !> Equivalences for onsite block corrections if needed for imaginary part
    integer, intent(inout), allocatable :: iEqBlockOnSiteLS(:,:,:,:)

    real(dp), allocatable :: invJacobian(:,:)

    if (xlbomdIntegrator%needsInverseJacobian()) then
      write(stdOut, "(A)") ">> Updating XLBOMD Inverse Jacobian"
      allocate(invJacobian(nIneqOrb, nIneqOrb))
      call TMixerReal_getInverseJacobian(pChrgMixerReal, invJacobian)
      call xlbomdIntegrator%setInverseJacobian(invJacobian)
      deallocate(invJacobian)
    end if
    call xlbomdIntegrator%getNextCharges(qOutRed(1:nIneqOrb), qInpRed(1:nIneqOrb))
    call expandCharges(qInpRed, orb, nIneqOrb, iEqOrbitals, qInput, dftbU, qBlockIn, iEqBlockDftbu,&
        & species0, qiBlockIn, iEqBlockDftbuLS, iEqBlockOnSite, iEqBlockOnSiteLS)

  end subroutine getXlbomdCharges


  !> Calculates dipole moment.
  subroutine getDipoleMoment(qOutput, q0, dipAtom, coord, dipoleMoment, iAtInCentralRegion)

    !> Electrons in orbitals
    real(dp), intent(in) :: qOutput(:,:,:)

    !> Reference atomic charges
    real(dp), intent(in) :: q0(:,:,:)

    !> Dipole populations for each atom
    real(dp), intent(in), optional :: dipAtom(:,:,:)

    !> Atomic coordinates
    real(dp), intent(in) :: coord(:,:)

    !> Resulting dipole moment
    real(dp), intent(out) :: dipoleMoment(:)

    !> Atoms in the central cell (or device region if transport)
    integer, intent(in) :: iAtInCentralRegion(:)

    integer :: nAtom, ii, iAtom

    nAtom = size(qOutput, dim=2)
    dipoleMoment(:) = 0.0_dp
    do ii = 1, size(iAtInCentralRegion)
      iAtom = iAtInCentralRegion(ii)
      dipoleMoment(:) = dipoleMoment(:)&
          & + sum(q0(:, iAtom, 1) - qOutput(:, iAtom, 1)) * coord(:,iAtom)
    end do

    if (present(dipAtom)) then
      do ii = 1, size(iAtInCentralRegion)
        iAtom = iAtInCentralRegion(ii)
        dipoleMoment(:) = dipoleMoment(:) - dipAtom(:, iAtom, 1)
      end do
    end if


  end subroutine getDipoleMoment


  !> Prints dipole moment calculated by the derivative of H with respect to the external field.
  subroutine checkDipoleViaHellmannFeynman(env, rhoPrim, q0, coord0, ints, orb, neighbourList,&
      & nNeighbourSK, species, iSparseStart, img2CentCell, eFieldScaling, iHamiltonianType, nDipole)

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> Density matrix in sparse storage
    real(dp), intent(in) :: rhoPrim(:,:)

    !> Reference orbital charges
    real(dp), intent(in) :: q0(:,:,:)

    !> Central cell atomic coordinates
    real(dp), intent(in) :: coord0(:,:)

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Species of all atoms in the system
    integer, intent(in) :: species(:)

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Instance of electric/dipole scaling due to any dielectric media effects
    class(TScaleExtEField), intent(in) :: eFieldScaling

    !> Hamiltonian type
    integer, intent(in) :: iHamiltonianType

    !> Number of atomic dipole moment components
    integer, intent(in) :: nDipole

    real(dp), allocatable :: hprime(:,:), dipole(:,:), potentialDerivative(:,:)
    real(dp), allocatable :: potentialGradDeriv(:,:)
    integer :: nAtom, sparseSize, iAt, iCart

    sparseSize = size(ints%overlap)
    nAtom = size(q0, dim=2)
    allocate(hprime(sparseSize, 1))
    allocate(dipole(size(q0, dim=1), nAtom))
    allocate(potentialDerivative(nAtom, 1))
    write(stdOut,*)
    write(stdOut, "(A)", advance='no') 'Hellmann Feynman dipole:'

  #:block DEBUG_CODE
    if (nDipole > 0) then
      @:ASSERT(iHamiltonianType == hamiltonianTypes%xtb)
      allocate(potentialGradDeriv(nDipole, nAtom))
    end if
  #:endblock DEBUG_CODE

    ! loop over directions
    do iCart = 1, 3
      potentialDerivative(:,:) = 0.0_dp
      ! Potential from dH/dE
      potentialDerivative(:,1) = -eFieldScaling%scaledExtEField(coord0(iCart,:))
      hprime(:,:) = 0.0_dp

      call addShift(env, hprime, ints%overlap, nNeighbourSK, neighbourList%iNeighbour, species,&
          & orb, iSparseStart, nAtom, img2CentCell, potentialDerivative, .true.)

      if (nDipole > 0) then
        potentialGradDeriv(:,:) = 0.0_dp
        potentialGradDeriv(iCart,:) = -eFieldScaling%scaledExtEField(1.0_dp)

        call addAtomicMultipoleShift(hPrime, ints%dipoleBra, ints%dipoleKet, nNeighbourSK, &
            & neighbourList%iNeighbour, species, orb, iSparseStart, nAtom, img2CentCell, &
            & potentialGradDeriv)
      end if

      dipole(:,:) = 0.0_dp
      ! evaluate <psi| dH/dE | psi> = Tr_part rho dH/dE
      call mulliken(env, dipole, hprime(:,1), rhoPrim(:,1), orb, neighbourList%iNeighbour,&
          & nNeighbourSK, img2CentCell, iSparseStart)

      ! add nuclei term for derivative wrt E
      do iAt = 1, nAtom
        dipole(1, iAt) = dipole(1, iAt) + sum(q0(:, iAt, 1)) *&
            & eFieldScaling%scaledExtEField(coord0(iCart, iAt))
      end do
      write(stdOut, "(F16.8)", advance='no') sum(dipole)
    end do
    write(stdOut, *) " au"

  end subroutine checkDipoleViaHellmannFeynman


  !> Calculate the energy weighted density matrix
  !>
  !> NOTE: Dense eigenvector and overlap matrices are overwritten.
  !>
  subroutine getEnergyWeightedDensity(env, negfInt, electronicSolver, denseDesc, forceType,&
      & filling, eigen, kPoint, kWeight, neighbourList, nNeighbourSK, orb, iSparseStart,&
      & img2CentCell, iCellVEc, cellVec, tRealHS, ints, parallelKS, tHelical, species, coord,&
      & iSCC, mu, ERhoPrim, densityMatrix, eigvecsReal, SSqrReal, eigvecsCplx, SSqrCplx, errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> NEGF interface
    type(TNegfInt), intent(inout) :: negfInt

    !> Electronic solver information
    type(TElectronicSolver), intent(inout) :: electronicSolver

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Force type
    integer, intent(in) :: forceType

    !> Occupations of single particle states in the ground state
    real(dp), intent(in) :: filling(:,:,:)

    !> Eigenvalues
    real(dp), intent(in) :: eigen(:,:,:)

    !> The k-points
    real(dp), intent(in) :: kPoint(:,:)

    !> Weights for k-points
    real(dp), intent(in) :: kWeight(:)

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> Is the hamiltonian real (no k-points/molecule/gamma point)?
    logical, intent(in) :: tRealHS

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Species of atoms
    integer, intent(in), optional :: species(:)

    !> All coordinates
    real(dp), intent(in) :: coord(:,:)

    !> Iteration counter
    integer, intent(in) :: iSCC

    !> Electrochemical potentials per contact and spin
    real(dp), allocatable, intent(in) :: mu(:,:)

    !> Energy weighted sparse matrix
    real(dp), intent(out) :: ERhoPrim(:)

    !> Holds density generation settings and real-space delta density matrix
    type(TDensityMatrix), intent(in) :: densityMatrix

    !> Storage eigenvectors (real case)
    real(dp), intent(inout), allocatable :: eigvecsReal(:,:,:)

    !> Storage for dense overlap matrix
    real(dp), intent(inout), allocatable :: SSqrReal(:,:)

    !> Storage eigenvectors (complex case)
    complex(dp), intent(inout), allocatable :: eigvecsCplx(:,:,:)

    !> Storage for dense overlap matrix (complex case)
    complex(dp), intent(inout), allocatable :: SSqrCplx(:,:)

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    integer :: nSpin

    nSpin = size(ints%hamiltonian, dim=2)

    call env%globalTimer%startTimer(globalTimers%energyDensityMatrix)

    select case (electronicSolver%iSolver)

    case (electronicSolverTypes%GF)

      if (forceType /= forceTypes%orig) then
        @:RAISE_ERROR(errStatus, -1, "Alternative force evaluation methods are not supported by&
            & this electronic solver.")
      end if

    #:if WITH_TRANSPORT
      if (electronicSolver%iSolver == electronicSolverTypes%GF) then
        call negfInt%calcEdensity_green(iSCC, env, parallelKS%localKS, ints%hamiltonian,&
            & ints%overlap, neighbourlist%iNeighbour, nNeighbourSK, denseDesc%iAtomStart,&
            & iSparseStart, img2CentCell, iCellVec, cellVec, orb, kPoint, kWeight, mu, ERhoPrim)
      end if
    #:endif

    case (electronicSolverTypes%onlyTransport)

      @:RAISE_ERROR(errStatus, -1, "The OnlyTransport solver cannot calculate the energy weighted&
          & density matrix")

    case (electronicSolverTypes%qr, electronicSolverTypes%divideandconquer,&
        & electronicSolverTypes%relativelyrobust, electronicSolverTypes%elpa, &
        & electronicSolverTypes%magma_gvd)

      call getEDensityMtxFromEigvecs(env, denseDesc, forceType, filling, eigen, kPoint, kWeight,&
          & neighbourList, nNeighbourSK, orb, iSparseStart, img2CentCell, iCellVec, cellVec,&
          & tRealHS, ints, parallelKS, tHelical, species, coord, densityMatrix, ERhoPrim,&
          & eigvecsReal, SSqrReal, eigvecsCplx, SSqrCplx, errStatus)
      @:PROPAGATE_ERROR(errStatus)

    case (electronicSolverTypes%omm, electronicSolverTypes%pexsi, electronicSolverTypes%ntpoly,&
        &electronicSolverTypes%elpadm)

      if (forceType /= forceTypes%orig) then
        @:RAISE_ERROR(errStatus, -1, "Alternative force evaluation methods are not supported by&
            & this electronic solver.")
      end if

      call electronicSolver%elsi%getEDensity(env, denseDesc, nSpin, kPoint, kWeight, neighbourList,&
          & nNeighbourSK, tHelical, orb, species, coord, iSparseStart, img2CentCell, iCellVec,&
          & cellVec, tRealHS, parallelKS, ERhoPrim, SSqrReal, SSqrCplx)

    end select

    call env%globalTimer%stopTimer(globalTimers%energyDensityMatrix)

  end subroutine getEnergyWeightedDensity


  !> Calculates the energy weighted density matrix using eigenvectors
  subroutine getEDensityMtxFromEigvecs(env, denseDesc, forceType, filling, eigen, kPoint, kWeight,&
      & neighbourList, nNeighbourSK, orb, iSparseStart, img2CentCell, iCellVec, cellVec, tRealHS,&
      & ints, parallelKS, tHelical, species, coord, densityMatrix, ERhoPrim, eigvecsReal, SSqrReal,&
      & eigvecsCplx, SSqrCplx, errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Force type
    integer, intent(in) :: forceType

    !> Occupations of single particle states in the ground state
    real(dp), intent(in) :: filling(:,:,:)

    !> Eigenvalues
    real(dp), intent(in) :: eigen(:,:,:)

    !> The k-points
    real(dp), intent(in) :: kPoint(:,:)

    !> Weights for k-points
    real(dp), intent(in) :: kWeight(:)

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> Is the hamiltonian real (no k-points/molecule/gamma point)?
    logical, intent(in) :: tRealHS

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Species of atoms
    integer, intent(in), optional :: species(:)

    !> All coordinates
    real(dp), intent(in) :: coord(:,:)

    !> Holds density generation settings and real-space delta density matrix
    type(TDensityMatrix), intent(in) :: densityMatrix

    !> Energy weighted sparse matrix
    real(dp), intent(out) :: ERhoPrim(:)

    !> Storage for eigenvectors
    real(dp), intent(inout), allocatable :: eigvecsReal(:,:,:)

    !> Storage for dense overlap matrix
    real(dp), intent(inout), allocatable :: SSqrReal(:,:)

    !> Storage for eigenvectors (complex case)
    complex(dp), intent(inout), allocatable :: eigvecsCplx(:,:,:)

    !> Storage for dense overlap matrix (complex case)
    complex(dp), intent(inout), allocatable :: SSqrCplx(:,:)

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    integer :: nSpin

    nSpin = size(ints%hamiltonian, dim=2)

    if (nSpin == 4) then
      call getEDensityMtxFromPauliEigvecs(env, denseDesc, forceType, filling, eigen, kPoint,&
          & kWeight, neighbourList, nNeighbourSK, orb, iSparseStart, img2CentCell, iCellVec,&
          & cellVec, tRealHS, parallelKS, eigvecsCplx, SSqrCplx, densityMatrix, ERhoPrim, errStatus)
    else
      if (tRealHS) then
        call getEDensityMtxFromRealEigvecs(env, denseDesc, forceType, filling, eigen,&
            & neighbourList, nNeighbourSK, orb, iSparseStart, img2CentCell, ints,&
            & parallelKS, tHelical, species, coord, eigvecsReal, SSqrReal, densityMatrix, ERhoPrim,&
            & errStatus)
      else
        call getEDensityMtxFromComplexEigvecs(env, denseDesc, forceType, filling, eigen, kPoint,&
            & kWeight, neighbourList, nNeighbourSK, orb, iSparseStart, img2CentCell, iCellVec,&
            & cellVec, ints, parallelKS, tHelical, species, coord, eigvecsCplx, SSqrCplx,&
            & densityMatrix, ERhoPrim, errStatus)
      end if
    end if
    @:PROPAGATE_ERROR(errStatus)

  end subroutine getEDensityMtxFromEigvecs


  !> Calculates density matrix from real eigenvectors.
  subroutine getEDensityMtxFromRealEigvecs(env, denseDesc, forceType, filling, eigen,&
      & neighbourList, nNeighbourSK, orb, iSparseStart, img2CentCell, ints, parallelKS,&
      & tHelical, species, coord, eigvecsReal, work, densityMatrix, ERhoPrim, errStatus)

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> How to calculate the force
    integer, intent(in) :: forceType

    !> Occupations of single particle states in the ground state
    real(dp), intent(in) :: filling(:,:,:)

    !> Eigenvalues
    real(dp), intent(in) :: eigen(:,:,:)

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Species of atoms
    integer, intent(in), optional :: species(:)

    !> All coordinates
    real(dp), intent(in) :: coord(:,:)

    !> Eigenvectors (NOTE: they will be rewritten with work data on exit!)
    real(dp), intent(inout) :: eigvecsReal(:,:,:)

    !> Work array for storing temporary data
    real(dp), intent(out) :: work(:,:)

    !> Holds real and complex delta density matrices and pointers
    type(TDensityMatrix), intent(in) :: densityMatrix

    !> Energy weighted density matrix
    real(dp), intent(out) :: ERhoPrim(:)

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    real(dp), allocatable :: work2(:,:)
    integer :: nLocalRows, nLocalCols
    integer :: iKS, iS

    nLocalRows = size(eigvecsReal, dim=1)
    nLocalCols = size(eigvecsReal, dim=2)
    if (forceType == forceTypes%dynamicT0 .or. forceType == forceTypes%dynamicTFinite) then
      allocate(work2(nLocalRows, nLocalCols))
    end if

    ERhoPrim(:) = 0.0_dp
    do iKS = 1, parallelKS%nLocalKS
      iS = parallelKS%localKS(2, iKS)

      select case (forceType)

      case(forceTypes%orig)
        ! Original (non-consistent) scheme
      #:if WITH_SCALAPACK
        call makeDensityMtxRealBlacs(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr, filling(:,1,iS),&
            & eigvecsReal(:,:,iKS), work, eigen(:,1,iS))
      #:else
        call densityMatrix%getEDensityMatrix(work, eigvecsReal(:,:,iKS), filling(:,1,iS),&
            & eigen(:,1,iS), errStatus)
        @:PROPAGATE_ERROR(errStatus)
      #:endif

      case(forceTypes%dynamicT0)
        ! Correct force for XLBOMD for T=0K (DHD)
      #:if WITH_SCALAPACK
        if (tHelical) then
          call unpackHSHelicalRealBlacs(env%blacs, ints%hamiltonian(:,iS),&
              & neighbourList%iNeighbour, nNeighbourSK, iSparseStart, img2CentCell, orb, species,&
              & coord, denseDesc, work)
        else
          call unpackHSRealBlacs(env%blacs, ints%hamiltonian(:,iS), neighbourList%iNeighbour,&
              & nNeighbourSK, iSparseStart, img2CentCell, denseDesc, work)
        end if
        call makeDensityMtxRealBlacs(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr, filling(:,1,iS),&
            & eigVecsReal(:,:,iKS), work2)
        call pblasfx_psymm(work2, denseDesc%blacsOrbSqr, work, denseDesc%blacsOrbSqr,&
            & eigvecsReal(:,:,iKS), denseDesc%blacsOrbSqr, side="L")
        call pblasfx_psymm(work2, denseDesc%blacsOrbSqr, eigvecsReal(:,:,iKS),&
            & denseDesc%blacsOrbSqr, work, denseDesc%blacsOrbSqr, side="R", alpha=0.5_dp)
      #:else
        if (tHelical) then
          call unpackHelicalHS(work, ints%hamiltonian(:,iS), neighbourlist%iNeighbour,&
              & nNeighbourSK, denseDesc%iAtomStart, iSparseStart, img2CentCell, orb, species, coord)
        else
          call unpackHS(work, ints%hamiltonian(:,iS), neighbourlist%iNeighbour, nNeighbourSK,&
              & denseDesc%iAtomStart, iSparseStart, img2CentCell)
        end if

        call adjointLowerTriangle(work)
        call densityMatrix%getDensityMatrix(work2, eigvecsReal(:,:,iKS), filling(:,1,iS), errStatus)
        @:PROPAGATE_ERROR(errStatus)

        ! D H
        call symm(eigvecsReal(:,:,iKS), "L", work2, work)
        ! (D H) D
        call symm(work, "R", work2, eigvecsReal(:,:,iKS), alpha=0.5_dp)
      #:endif

      case(forceTypes%dynamicTFinite)
        ! Correct force for XLBOMD for T <> 0K (DHS^-1 + S^-1HD)
      #:if WITH_SCALAPACK
        call makeDensityMtxRealBlacs(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr, filling(:,1,iS),&
            & eigVecsReal(:,:,iKS), work)
        if (tHelical) then
          call unpackHSHelicalRealBlacs(env%blacs, ints%hamiltonian(:,iS),&
              & neighbourlist%iNeighbour, nNeighbourSK, iSparseStart, img2CentCell, orb, species,&
              & coord, denseDesc, work2)
        else
          call unpackHSRealBlacs(env%blacs, ints%hamiltonian(:,iS), neighbourlist%iNeighbour,&
              & nNeighbourSK, iSparseStart, img2CentCell, denseDesc, work2)
        end if
        call pblasfx_psymm(work, denseDesc%blacsOrbSqr, work2, denseDesc%blacsOrbSqr,&
            & eigvecsReal(:,:,iKS), denseDesc%blacsOrbSqr, side="L")
        if (tHelical) then
          call unpackHSHelicalRealBlacs(env%blacs, ints%overlap, neighbourlist%iNeighbour,&
              & nNeighbourSK, iSparseStart, img2CentCell, orb, species, coord, denseDesc, work)
        else
          call unpackHSRealBlacs(env%blacs, ints%overlap, neighbourlist%iNeighbour, nNeighbourSK,&
              & iSparseStart, img2CentCell, denseDesc, work)
        end if
        call psymmatinv(denseDesc%blacsOrbSqr, work, errStatus)
        @:PROPAGATE_ERROR(errStatus)
        call pblasfx_psymm(work, denseDesc%blacsOrbSqr, eigvecsReal(:,:,iKS),&
            & denseDesc%blacsOrbSqr, work2, denseDesc%blacsOrbSqr, side="R", alpha=0.5_dp)
        work(:,:) = work2
        call pblasfx_ptran(work2, denseDesc%blacsOrbSqr, work, denseDesc%blacsOrbSqr, alpha=1.0_dp,&
            & beta=1.0_dp)
      #:else
        call densityMatrix%getDensityMatrix(work, eigvecsReal(:,:,iKS), filling(:,1,iS), errStatus)
        @:PROPAGATE_ERROR(errStatus)
        if (tHelical) then
          call unpackHelicalHS(work2, ints%hamiltonian(:,iS), neighbourlist%iNeighbour,&
              & nNeighbourSK, denseDesc%iAtomStart, iSparseStart, img2CentCell, orb, species, coord)
        else
          call unpackHS(work2, ints%hamiltonian(:,iS), neighbourlist%iNeighbour, nNeighbourSK,&
              & denseDesc%iAtomStart, iSparseStart, img2CentCell)
        end if
        call adjointLowerTriangle(work2)
        call symm(eigvecsReal(:,:,iKS), "L", work, work2)
        if (tHelical) then
          call unpackHelicalHS(work, ints%overlap, neighbourlist%iNeighbour, nNeighbourSK,&
              & denseDesc%iAtomStart, iSparseStart, img2CentCell, orb, species, coord)
        else
          call unpackHS(work, ints%overlap, neighbourlist%iNeighbour, nNeighbourSK,&
              & denseDesc%iAtomStart, iSparseStart, img2CentCell)
        end if
        call symmatinv(work, errStatus)
        @:PROPAGATE_ERROR(errStatus)
        call symm(work2, "R", work, eigvecsReal(:,:,iKS), alpha=0.5_dp)
        work(:,:) = work2 + transpose(work2)
      #:endif
      end select

    #:if WITH_SCALAPACK
      if (tHelical) then
        call packRhoHelicalRealBlacs(env%blacs, denseDesc, work, neighbourList%iNeighbour,&
            & nNeighbourSK, iSparseStart, img2CentCell, orb, species, coord, ERhoPrim)
      else
        call packRhoRealBlacs(env%blacs, denseDesc, work, neighbourList%iNeighbour, nNeighbourSK,&
            & orb%mOrb, iSparseStart, img2CentCell, ERhoPrim)
      end if
    #:else
      if (tHelical) then
        call packHelicalHS(ERhoPrim, work, neighbourList%iNeighbour, nNeighbourSK,&
            & denseDesc%iAtomStart, iSparseStart, img2CentCell, orb, species, coord)
      else
        call packHS(ERhoPrim, work, neighbourList%iNeighbour, nNeighbourSK, orb%mOrb,&
            & denseDesc%iAtomStart, iSparseStart, img2CentCell)
      end if
    #:endif
    end do

  #:if WITH_SCALAPACK
    ! Add up and distribute energy weighted density matrix contribution from each group
    call mpifx_allreduceip(env%mpi%globalComm, ERhoPrim, MPI_SUM)
  #:endif

  end subroutine getEDensityMtxFromRealEigvecs


  !> Calculates density matrix from complex eigenvectors.
  subroutine getEDensityMtxFromComplexEigvecs(env, denseDesc, forceType, filling, eigen, kPoint,&
      & kWeight, neighbourList, nNeighbourSK, orb, iSparseStart, img2CentCell, iCellVec, cellVec,&
      & ints, parallelKS, tHelical, species, coord, eigvecsCplx, work, densityMatrix, ERhoPrim,&
      & errStatus)

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Force evaluation method
    integer, intent(in) :: forceType

    !> Occupations of single particle states in the ground state
    real(dp), intent(in) :: filling(:,:,:)

    !> Eigen-values of the system
    real(dp), intent(in) :: eigen(:,:,:)

    !> The k-points of the system
    real(dp), intent(in) :: kPoint(:,:)

    !> Weights for k-points
    real(dp), intent(in) :: kWeight(:)

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Species of atoms
    integer, intent(in), optional :: species(:)

    !> All coordinates
    real(dp), intent(in) :: coord(:,:)

    !> Eigenvectors of the system
    complex(dp), intent(inout) :: eigvecsCplx(:,:,:)

    !> Work array (sized like overlap matrix)
    complex(dp), intent(inout) :: work(:,:)

    !> Holds real and complex delta density matrices and pointers
    type(TDensityMatrix), intent(in) :: densityMatrix

    !> Energy weighted sparse density matrix (charge only part)
    real(dp), intent(out) :: ERhoPrim(:)

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    complex(dp), allocatable :: work2(:,:)
    integer :: nLocalRows, nLocalCols
    integer :: iKS, iS, iK

    nLocalRows = size(eigvecsCplx, dim=1)
    nLocalCols = size(eigvecsCplx, dim=2)

    if (forceType == forceTypes%dynamicT0 .or. forceType == forceTypes%dynamicTFinite) then
      allocate(work2(nLocalRows, nLocalCols))
    end if

    ERhoPrim(:) = 0.0_dp
    do iKS = 1, parallelKS%nLocalKS
      iK = parallelKS%localKS(1, iKS)
      iS = parallelKS%localKS(2, iKS)

      select case (forceType)

      case(forceTypes%orig)
        ! Original (non-consistent) scheme
      #:if WITH_SCALAPACK
        call makeDensityMtxCplxBlacs(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr,&
            & filling(:,iK,iS), eigvecsCplx(:,:,iKS), work, eigen(:,iK,iS))
      #:else
        call densityMatrix%getEDensityMatrix(work, eigvecsCplx(:,:,iKS), filling(:,iK,iS),&
            & eigen(:,iK, iS), errStatus)
        @:PROPAGATE_ERROR(errStatus)
      #:endif

      case(forceTypes%dynamicT0)
        ! Correct force for XLBOMD for T=0K (DHD)
      #:if WITH_SCALAPACK
        if (tHelical) then
          call unpackHSHelicalCplxBlacs(env%blacs, ints%hamiltonian(:,iS), kPoint(:,iK),&
              & neighbourList%iNeighbour, nNeighbourSK, iCellVec, cellVec, iSparseStart,&
              & img2CentCell, orb, species, coord, denseDesc, work)
        else
          call unpackHSCplxBlacs(env%blacs, ints%hamiltonian(:,iS), kPoint(:,iK),&
              & neighbourList%iNeighbour, nNeighbourSK, iCellVec, cellVec, iSparseStart,&
              & img2CentCell, denseDesc, work)
        end if
        call makeDensityMtxCplxBlacs(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr, filling(:,1,iS),&
            & eigvecsCplx(:,:,iKS), work2)
        call pblasfx_phemm(work2, denseDesc%blacsOrbSqr, work, denseDesc%blacsOrbSqr,&
            & eigvecsCplx(:,:,iKS), denseDesc%blacsOrbSqr, side="L")
        call pblasfx_phemm(work2, denseDesc%blacsOrbSqr, eigvecsCplx(:,:,iKS),&
            & denseDesc%blacsOrbSqr, work, denseDesc%blacsOrbSqr, side="R", alpha=(0.5_dp, 0.0_dp))
      #:else
        call densityMatrix%getDensityMatrix(work2, eigvecsCplx(:,:,iKS), filling(:,iK,iS),&
            & errStatus)
        @:PROPAGATE_ERROR(errStatus)
        if (tHelical) then
          call unpackHelicalHS(work, ints%hamiltonian(:,iS), kPoint(:,iK),&
              & neighbourlist%iNeighbour, nNeighbourSK, iCellVec, cellVec, denseDesc%iAtomStart,&
              & iSparseStart, img2CentCell, orb, species, coord)
        else
          call unpackHS(work, ints%hamiltonian(:,iS), kPoint(:,iK), neighbourlist%iNeighbour,&
              & nNeighbourSK, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart, img2CentCell)
        end if
        call adjointLowerTriangle(work)
        call hemm(eigvecsCplx(:,:,iKS), "L", work2, work)
        call hemm(work, "R", work2, eigvecsCplx(:,:,iKS), alpha=(0.5_dp, 0.0_dp))
      #:endif

      case(forceTypes%dynamicTFinite)
        ! Correct force for XLBOMD for T <> 0K (DHS^-1 + S^-1HD)
      #:if WITH_SCALAPACK
        call makeDensityMtxCplxBlacs(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr,&
            & filling(:,iK,iS), eigVecsCplx(:,:,iKS), work)
        if (tHelical) then
          call unpackHSHelicalCplxBlacs(env%blacs, ints%hamiltonian(:,iS), kPoint(:,iK),&
              & neighbourlist%iNeighbour, nNeighbourSK, iCellVec, cellVec, iSparseStart,&
              & img2CentCell, orb, species, coord, denseDesc, work2)
        else
          call unpackHSCplxBlacs(env%blacs, ints%hamiltonian(:,iS), kPoint(:,iK),&
              & neighbourlist%iNeighbour, nNeighbourSK, iCellVec, cellVec, iSparseStart,&
              & img2CentCell, denseDesc, work2)
        end if
        call pblasfx_phemm(work, denseDesc%blacsOrbSqr, work2, denseDesc%blacsOrbSqr,&
            & eigvecsCplx(:,:,iKS), denseDesc%blacsOrbSqr, side="L")
        if (tHelical) then
          call unpackHSHelicalCplxBlacs(env%blacs, ints%overlap, kPoint(:,iK),&
              & neighbourlist%iNeighbour, nNeighbourSK, iCellVec, cellVec, iSparseStart,&
              & img2CentCell, orb, species, coord, denseDesc, work)
        else
          call unpackHSCplxBlacs(env%blacs, ints%overlap, kPoint(:,iK), neighbourlist%iNeighbour,&
              & nNeighbourSK, iCellVec, cellVec, iSparseStart, img2CentCell, denseDesc, work)
        end if
        call phermatinv(denseDesc%blacsOrbSqr, work, errStatus)
        @:PROPAGATE_ERROR(errStatus)
        call pblasfx_phemm(work, denseDesc%blacsOrbSqr, eigvecsCplx(:,:,iKS),&
            & denseDesc%blacsOrbSqr, work2, denseDesc%blacsOrbSqr, side="R", alpha=(0.5_dp, 0.0_dp))
        work(:,:) = work2
        call pblasfx_ptranc(work2, denseDesc%blacsOrbSqr, work, denseDesc%blacsOrbSqr,&
            & alpha=(1.0_dp, 0.0_dp), beta=(1.0_dp, 0.0_dp))
      #:else
        call densityMatrix%getDensityMatrix(work, eigvecsCplx(:,:,iKS), filling(:,iK,iS), errStatus)
        @:PROPAGATE_ERROR(errStatus)
        if (tHelical) then
          call unpackHelicalHS(work2, ints%hamiltonian(:,iS), kPoint(:,iK),&
              & neighbourlist%iNeighbour, nNeighbourSK, iCellVec, cellVec, denseDesc%iAtomStart,&
              & iSparseStart, img2CentCell, orb, species, coord)
        else
          call unpackHS(work2, ints%hamiltonian(:,iS), kPoint(:,iK), neighbourlist%iNeighbour,&
              & nNeighbourSK, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart, img2CentCell)
        end if
        call adjointLowerTriangle(work2)
        call hemm(eigvecsCplx(:,:,iKS), "L", work, work2)
        if  (tHelical) then
          call unpackHelicalHS(work, ints%overlap, kPoint(:,iK), neighbourlist%iNeighbour,&
              & nNeighbourSK, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart, img2CentCell,&
              & orb, species, coord)
        else
          call unpackHS(work, ints%overlap, kPoint(:,iK), neighbourlist%iNeighbour, nNeighbourSK,&
              & iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart, img2CentCell)
        end if
        call hermatinv(work, errStatus)
        @:PROPAGATE_ERROR(errStatus)
        call hemm(work2, "R", work, eigvecsCplx(:,:,iKS), alpha=(0.5_dp, 0.0_dp))
        work(:,:) = work2 + transpose(conjg(work2))
      #:endif
      end select

    #:if WITH_SCALAPACK
      if (tHelical) then
        call packRhoHelicalCplxBlacs(env%blacs, denseDesc, work, kPoint(:,iK), kWeight(iK),&
            & neighbourList%iNeighbour, nNeighbourSK, iCellVec, cellVec, iSparseStart,&
            & img2CentCell, orb, species, coord, ERhoPrim)
      else
        call packRhoCplxBlacs(env%blacs, denseDesc, work, kPoint(:,iK), kWeight(iK),&
            &neighbourList%iNeighbour, nNeighbourSK, orb%mOrb, iCellVec, cellVec, iSparseStart,&
            & img2CentCell, ERhoPrim)
      end if
    #:else
      if (tHelical) then
        call packHelicalHS(ERhoPrim, work, kPoint(:,iK), kWeight(iK), neighbourList%iNeighbour,&
            & nNeighbourSK, orb%mOrb, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart,&
            & img2CentCell, orb, species, coord)
      else
        call packHS(ERhoPrim, work, kPoint(:,iK), kWeight(iK), neighbourList%iNeighbour,&
            & nNeighbourSK, orb%mOrb, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart,&
            & img2CentCell)
      end if
    #:endif
    end do

  #:if WITH_SCALAPACK
    ! Add up and distribute energy weighted density matrix contribution from each group
    call mpifx_allreduceip(env%mpi%globalComm, ERhoPrim, MPI_SUM)
  #:endif

  end subroutine getEDensityMtxFromComplexEigvecs


  !> Calculates density matrix from Pauli-type two component eigenvectors.
  subroutine getEDensityMtxFromPauliEigvecs(env, denseDesc, forceType, filling, eigen, kPoint,&
      & kWeight, neighbourList, nNeighbourSK, orb, iSparseStart, img2CentCell, iCellVec, cellVec,&
      & tRealHS, parallelKS, eigvecsCplx, work, densityMatrix, ERhoPrim, errStatus)

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Force evaluation method
    integer, intent(in) :: forceType

    !> Occupations of single particle states in the ground state
    real(dp), intent(in) :: filling(:,:,:)

    !> Eigenvalues
    real(dp), intent(in) :: eigen(:,:,:)

    !> The k-points
    real(dp), intent(in) :: kPoint(:,:)

    !> Weights for k-points
    real(dp), intent(in) :: kWeight(:)

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> Is the hamiltonian real (no k-points/molecule/gamma point)?
    logical, intent(in) :: tRealHS

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Eigenvectors
    complex(dp), intent(inout) :: eigvecsCplx(:,:,:)

    !> Work array
    complex(dp), intent(out) :: work(:,:)

    !> Holds real and complex delta density matrices and pointers
    type(TDensityMatrix), intent(in) :: densityMatrix

    !> Sparse energy weighted density matrix
    real(dp), intent(out) :: ERhoPrim(:)

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    !! k-point and composite index (iK, iS)
    integer :: iK, iKS

    if (forceType /= forceTypes%orig) then
      @:RAISE_ERROR(errStatus, -1, "Alternative force evaluation methods are not supported for&
          & Pauli hamiltonians at the moment.")
    end if

    ERhoPrim(:) = 0.0_dp
    do iKS = 1, parallelKS%nLocalKS
      iK = parallelKS%localKS(1, iKS)
    #:if WITH_SCALAPACK
      call makeDensityMtxCplxBlacs(env%blacs%orbitalGrid, denseDesc%blacsOrbSqr, filling(:,iK,1),&
          & eigvecsCplx(:,:,iKS), work, eigen(:,iK,1))
      call packERhoPauliBlacs(env%blacs, denseDesc, work, kPoint(:,iK), kWeight(iK),&
          & neighbourList%iNeighbour, nNeighbourSK, orb%mOrb, iCellVec, cellVec, iSparseStart,&
          & img2CentCell, ERhoPrim)
    #:else
      call densityMatrix%getEDensityMatrix(work, eigvecsCplx(:,:,iKS), filling(:,iK,1),&
          & eigen(:,iK,1), errStatus)
      @:PROPAGATE_ERROR(errStatus)
      if (tRealHS) then
        call packERho(ERhoPrim, work, neighbourList%iNeighbour, nNeighbourSK, orb%mOrb,&
            & denseDesc%iAtomStart, iSparseStart, img2CentCell)
      else
        call packERho(ERhoPrim, work, kPoint(:,iK), kWeight(iK), neighbourList%iNeighbour,&
            & nNeighbourSK, orb%mOrb, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart,&
            & img2CentCell)
      end if
    #:endif
    end do

  #:if WITH_SCALAPACK
    ! Add up and distribute energy weighted density matrix contribution from each group
    call mpifx_allreduceip(env%mpi%globalComm, ERhoPrim, MPI_SUM)
  #:endif

  end subroutine getEDensityMtxFromPauliEigvecs


  !> Calculates the gradients
  subroutine getGradients(env, parallelKS, boundaryConds, sccCalc, tblite, isExtField, isXlbomd,&
      & nonSccDeriv, rhoPrim, ERhoPrim, qOutput, q0, skHamCont, skOverCont, repulsive,&
      & neighbourList, symNeighbourList, nNeighbourSK, nNeighbourCamSym, iCellVec, cellVecs,&
      & rCellVecs, recVecs2p, species, img2CentCell, iSparseStart, orb, potential, coord, derivs,&
      & groundDerivs, tripletderivs, mixedderivs, iRhoPrim, thirdOrd, solvation, qDepExtPot,&
      & chrgForces, dispersion, hybridXc, SSqrReal, ints, denseDesc, halogenXCorrection, tHelical,&
      & coord0, deltaDftb, tPeriodic, tRealHS, kPoint, kWeight, densityMatrix, errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Boundary conditions on the geometry
    type(TBoundaryConditions), intent(in) :: boundaryConds

    !> SCC module internal variables
    type(TScc), allocatable, intent(inout) :: sccCalc

    !> Library communication interface
    type(TTBLite), allocatable, intent(inout) :: tblite

    !> External electric field
    logical, intent(in) :: isExtField

    !> Extended Lagrangian active?
    logical, intent(in) :: isXlbomd

    !> Method for calculating derivatives of S and H0
    type(TNonSccDiff), intent(in) :: nonSccDeriv

    !> Sparse density matrix
    real(dp), intent(in) :: rhoPrim(:,:)

    !> Energy  weighted density matrix
    real(dp), intent(in) :: ERhoPrim(:)

    !> Electron populations (may be unallocated for non-scc case)
    real(dp), allocatable, intent(in) :: qOutput(:,:,:)

    !> Reference atomic charges (may be unallocated for non-scc case)
    real(dp), allocatable, intent(in) :: q0(:,:,:)

    !> Non-SCC hamiltonian information
    type(TSlakoCont), intent(in) :: skHamCont

    !> Overlap information
    type(TSlakoCont), intent(in) :: skOverCont

    !> Repulsive information
    class(TRepulsive), allocatable, intent(in) :: repulsive

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> List of neighbouring atoms (symmetric version)
    type(TSymNeighbourList), intent(in), allocatable :: symNeighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Symmetric neighbour list version of nNeighbourCam
    integer, intent(in), allocatable :: nNeighbourCamSym(:)

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors to unit cells in relative units
    real(dp), intent(in) :: cellVecs(:,:)

    !> Vectors to unit cells in absolute units
    real(dp), intent(in) :: rCellVecs(:,:)

    !> Reciprocal lattice vectors in units of 2 pi
    real(dp), intent(in) :: recVecs2p(:,:)

    !> Species of all atoms in the system
    integer, intent(in) :: species(:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Potential acting on the system
    type(TPotentials), intent(in) :: potential

    !> Atomic coordinates
    real(dp), intent(in) :: coord(:,:)

    !> Derivatives of energy wrt to atomic positions
    real(dp), intent(out) :: derivs(:,:)

    !> Derivatives of ground state energy wrt to atomic positions
    real(dp), intent(inout), allocatable :: groundDerivs(:,:)

    !> Derivatives of triplet energy wrt to atomic positions (TI-DFTB excited states)
    real(dp), intent(inout), allocatable :: tripletDerivs(:,:)

    !> Derivatives of mixed energy wrt to atomic positions (TI-DFTB excited states)
    real(dp), intent(inout), allocatable :: mixedDerivs(:,:)

    !> Imaginary part of density matrix
    real(dp), intent(in), allocatable :: iRhoPrim(:,:)

    !> Is 3rd order SCC being used
    type(TThirdOrder), intent(inout), allocatable :: thirdOrd

    !> Solvation model
    class(TSolvation), allocatable, intent(inout) :: solvation

    !> Population dependant external potential
    type(TQDepExtPotProxy), intent(inout), allocatable :: qDepExtPot

    !> Forces on external charges
    real(dp), intent(inout), allocatable :: chrgForces(:,:)

    !> Dispersion interactions
    class(TDispersionIface), intent(inout), allocatable :: dispersion

    !> Data from hybrid xc-functional calculations
    class(THybridXcFunc), intent(inout), allocatable :: hybridXc

    !> Dense overlap matrix, required for hybridXc
    real(dp), intent(inout), allocatable :: SSqrReal(:,:)

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> Dense matrix descriptor, required for hybridXc
    type(TDenseDescr), intent(in) :: denseDesc

    !> Correction for halogen bonds
    type(THalogenX), intent(inout), allocatable :: halogenXCorrection

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Central cell atomic coordinates
    real(dp), intent(in) :: coord0(:,:)

    !> Determinant derived type
    type(TDftbDeterminants), intent(in) :: deltaDftb

    !> Is the geometry periodic
    logical, intent(in) :: tPeriodic

    !> Is the hamiltonian real (no k-points/molecule/gamma point)?
    logical, intent(in) :: tRealHS

    !> The k-points
    real(dp), intent(in) :: kPoint(:,:)

    !> Weights for k-points
    real(dp), intent(in) :: kWeight(:)

    !> Holds real and complex delta density matrices
    type(TDensityMatrix), intent(in) :: densityMatrix

    !> Error status
    type(TStatus), intent(inout) :: errStatus

    real(dp), allocatable :: tmpDerivs(:,:)
    real(dp), allocatable :: dQ(:,:,:)
    real(dp), allocatable :: dipoleAtom(:,:)
    logical :: tImHam, tExtChrg, tSccCalc
    integer :: nAtom, iAt

    tSccCalc = allocated(sccCalc)
    tImHam = allocated(iRhoPrim)
    tExtChrg = allocated(chrgForces)
    nAtom = size(derivs, dim=2)

    if (allocated(tblite)) then
      dipoleAtom = potential%dipoleAtom
      if (allocated(potential%extDipoleAtom)) then
        dipoleAtom(:,:) = dipoleAtom + potential%extDipoleAtom
      end if
    end if

    allocate(tmpDerivs(3, nAtom))
    derivs(:,:) = 0.0_dp

    if (.not. (tSccCalc .or. isExtField)) then
      ! No external or internal potentials
      if (allocated(tblite)) then
        call tblite%buildDerivativeShift(env, rhoPrim, ERhoPrim, coord, species, &
          & nNeighbourSK, neighbourList%iNeighbour, img2CentCell, iSparseStart, orb, &
          & potential%intBlock, dipoleAtom, potential%quadrupoleAtom)
        call tblite%addGradients(env, neighbourList, species, coord, img2centCell, derivs)
      else
        if (tImHam) then
          call derivative_shift(env, derivs, nonSccDeriv, rhoPrim, iRhoPrim, ERhoPrim, skHamCont,&
              & skOverCont, coord, species, neighbourList%iNeighbour, nNeighbourSK, img2CentCell,&
              & iSparseStart, orb, potential%intBlock, potential%iorbitalBlock)
        else
          call derivative_shift(env, derivs, nonSccDeriv, rhoPrim(:,1), ERhoPrim, skHamCont,&
              & skOverCont, coord, species, neighbourList%iNeighbour, nNeighbourSK, img2CentCell,&
              & iSparseStart, orb, tHelical)
        end if
      end if
    else
      if (allocated(tblite)) then
        call tblite%buildDerivativeShift(env, rhoPrim, ERhoPrim, coord, species, &
          & nNeighbourSK, neighbourList%iNeighbour, img2CentCell, iSparseStart, orb, &
          & potential%intBlock, dipoleAtom, potential%quadrupoleAtom)
        call tblite%addGradients(env, neighbourList, species, coord, img2centCell, derivs)
      else
        if (tImHam) then
          call derivative_shift(env, derivs, nonSccDeriv, rhoPrim, iRhoPrim, ERhoPrim, skHamCont,&
              & skOverCont, coord, species, neighbourList%iNeighbour, nNeighbourSK, img2CentCell,&
              & iSparseStart, orb, potential%intBlock, potential%iorbitalBlock)
        else
          call derivative_shift(env, derivs, nonSccDeriv, rhoPrim, ERhoPrim, skHamCont, skOverCont,&
              & coord, species, neighbourList%iNeighbour, nNeighbourSK, img2CentCell, iSparseStart,&
              & orb, potential%intBlock)
        end if
      end if

      if (tExtChrg) then
        chrgForces(:,:) = 0.0_dp
        if (isXlbomd) then
          @:RAISE_ERROR(errStatus, -1, "XLBOMD does not work with external charges yet!")
        else
          call sccCalc%addForceDc(env, derivs, species, neighbourList%iNeighbour, img2CentCell,&
              & chrgForces)
        end if
      else if (tSccCalc) then
        if (isXlbomd) then
          call sccCalc%addForceDcXlbomd(env, species, orb, neighbourList%iNeighbour,&
              & img2CentCell, qOutput, q0, derivs)
        else
          call sccCalc%addForceDc(env, derivs, species, neighbourList%iNeighbour, img2CentCell)
        end if
      end if

      if (allocated(thirdOrd)) then
        if (isXlbomd) then
          call thirdOrd%addGradientDcXlbomd(neighbourList, species, coord, img2CentCell, qOutput,&
              & q0, orb, derivs)
        else
          call thirdOrd%addGradientDc(neighbourList, species, coord, img2CentCell, derivs)
        end if
      end if

      if (allocated(qDepExtPot)) then
        allocate(dQ(orb%mShell, nAtom, size(qOutput, dim=3)))
        call getChargePerShell(qOutput, orb, species, dQ, qRef=q0)
        call qDepExtPot%addGradientDc(sum(dQ(:,:,1), dim=1), dQ(:,:,1), derivs)
      end if

      if (isExtField) then
        do iAt = 1, nAtom
          derivs(:, iAt) = derivs(:, iAt)&
              & + sum(qOutput(:, iAt, 1) - q0(:, iAt, 1)) * potential%extGrad(:, iAt)
        end do
      end if

    end if

    if (allocated(solvation)) then
      if (isXlbomd) then
        @:RAISE_ERROR(errStatus, -1, "XLBOMD does not work with solvation yet!")
      else
        call solvation%addGradients(env, neighbourList, species, coord, img2CentCell, derivs)
      end if
    end if

    if (allocated(dispersion)) then
      call dispersion%addGradients(env, neighbourList, img2CentCell, coord, species, derivs)
    end if

    if (allocated(halogenXCorrection)) then
      call halogenXCorrection%addGradients(derivs, coord, species, neighbourList, img2CentCell)
    end if

    if (allocated(hybridXc)) then
      if (tRealHS) then
        @:ASSERT(allocated(densityMatrix%deltaRhoOut))
        if (size(densityMatrix%deltaRhoOut, dim=3) > 2) then
          @:RAISE_ERROR(errStatus, -1, "Range-separated forces do not support non-colinear spin.")
        end if
      #:if WITH_SCALAPACK
        if (tHelical) then
          call unpackHSHelicalRealBlacs(env%blacs, ints%overlap, neighbourList%iNeighbour,&
              & nNeighbourSK, iSparseStart, img2CentCell, orb, species, coord, denseDesc, SSqrReal)
        else
          call unpackHSRealBlacs(env%blacs, ints%overlap, neighbourList%iNeighbour, nNeighbourSK,&
              & iSparseStart, img2CentCell, denseDesc, SSqrReal)
        end if
        call hybridXc%addCamGradients_real(env, parallelKS, densityMatrix%deltaRhoOut, SSqrReal,&
            & skOverCont, symNeighbourList, nNeighbourCamSym, orb, nonSccDeriv, denseDesc,&
            & size(rhoPrim, dim=2), tPeriodic, derivs, errStatus)
      #:else
        if (tHelical) then
          call unpackHelicalHS(SSqrReal, ints%overlap, neighbourList%iNeighbour, nNeighbourSK,&
              & denseDesc%iAtomStart, iSparseStart, img2CentCell, orb, species, coord)
        else
          call unpackHS(SSqrReal, ints%overlap, neighbourList%iNeighbour, nNeighbourSK,&
              & denseDesc%iAtomStart, iSparseStart, img2CentCell)
        end if
        call hybridXc%addCamGradients_real(densityMatrix%deltaRhoOut, SSqrReal, skOverCont, orb,&
            & denseDesc%iAtomStart, neighbourList%iNeighbour, nNeighbourSK, nonSccDeriv,&
            & tPeriodic, derivs, symNeighbourList=symNeighbourList,&
            & nNeighbourCamSym=nNeighbourCamSym)
      #:endif
        @:PROPAGATE_ERROR(errStatus)
      else
        call hybridXc%addCamGradients_kpts(env, denseDesc, ints, orb, skOverCont, nonSccDeriv,&
            & densityMatrix, neighbourList, nNeighbourSK, symNeighbourList, nNeighbourCamSym,&
            & cellVecs, iCellVec, iSparseStart, img2CentCell, kPoint, kWeight, derivs, errStatus)
      end if
    end if

    if (allocated(repulsive)) then
      call repulsive%getGradients(coord, species, img2CentCell, neighbourList, tmpDerivs)
    else
      tmpDerivs(:,:) = 0.0_dp
    end if

    derivs(:,:) = derivs + tmpDerivs

    call boundaryConds%alignVectorCentralCell(derivs, coord, coord0, nAtom)

    if (deltaDftb%isNonAufbau) then
      select case (deltaDftb%whichDeterminant(deltaDftb%iDeterminant))
      case (determinants%ground)
        groundDerivs(:,:) = derivs
      case (determinants%triplet)
        tripletDerivs(:,:) = derivs
      case (determinants%mixed)
        mixedDerivs(:,:) = derivs
      end select
    end if

  end subroutine getGradients


  !> Use plumed to update derivatives
  subroutine updateDerivsByPlumed(env, plumedCalc, iGeoStep, derivs, energy, coord0, mass,&
      & tPeriodic, latVecs)

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> PLUMED calculator
    type(TPlumedCalc), allocatable, intent(inout) :: plumedCalc

    !> Steps taken during simulation
    integer, intent(in) :: iGeoStep

    !> The derivatives array
    real(dp), intent(inout), target, contiguous :: derivs(:,:)

    !> Current energy
    real(dp), intent(in) :: energy

    !> Current atomic positions
    real(dp), intent(in), target, contiguous :: coord0(:,:)

    !> Atomic masses array
    real(dp), intent(in), target, contiguous :: mass(:)

    !> Periodic?
    logical, intent(in) :: tPeriodic

    !> Lattice vectors
    real(dp), intent(in), target, contiguous :: latVecs(:,:)

    if (.not. allocated(plumedCalc)) then
      return
    end if
    derivs(:,:) = -derivs
    call plumedCalc%sendCmdVal("setStep", iGeoStep)
    call plumedCalc%sendCmdPtr("setForces", derivs)
    call plumedCalc%sendCmdVal("setEnergy", energy)
    call plumedCalc%sendCmdPtr("setPositions", coord0)
    call plumedCalc%sendCmdPtr("setMasses", mass)
    if (tPeriodic) then
      call plumedCalc%sendCmdPtr("setBox", latVecs)
    end if
    call plumedCalc%sendCmdVal("calc", 0)
    derivs(:,:) = -derivs

  end subroutine updateDerivsByPlumed


  !> Calculates stress tensor and lattice derivatives.
  subroutine getStress(env, sccCalc, tblite, thirdOrd, isExtField, nonSccDeriv, rhoPrim,&
      & ERhoPrim, qOutput, q0, skHamCont, skOverCont, repulsive, neighbourList, nNeighbourSk,&
      & species, img2CentCell, iSparseStart, orb, potential, coord, latVec, invLatVec,&
      & cellVol, coord0, totalStress, totalLatDeriv, intPressure, iRhoPrim, solvation,&
      & dispersion, halogenXCorrection, deltaDftb, tripletStress, mixedStress)

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> SCC module internal variables
    type(TScc), allocatable, intent(in) :: sccCalc

    !> Library interface handler
    type(TTBLite), allocatable, intent(inout) :: tblite

    !> Is 3rd order SCC being used
    type(TThirdOrder), intent(inout), allocatable :: thirdOrd

    !> External field
    logical, intent(in) :: isExtField

    !> Method for calculating derivatives of S and H0
    type(TNonSccDiff), intent(in) :: nonSccDeriv

    !> Density matrix
    real(dp), intent(in) :: rhoPrim(:,:)

    !> Energy weighted density matrix
    real(dp), intent(in) :: ERhoPrim(:)

    !> Electrons in orbitals
    real(dp), intent(in) :: qOutput(:,:,:)

    !> Reference charges
    real(dp), intent(in) :: q0(:,:,:)

    !> Non-SCC hamiltonian information
    type(TSlakoCont), intent(in) :: skHamCont

    !> Overlap information
    type(TSlakoCont), intent(in) :: skOverCont

    !> Repulsive information
    class(TRepulsive), allocatable, intent(in) :: repulsive

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Species of all atoms in the system
    integer, intent(in) :: species(:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Potentials acting
    type(TPotentials), intent(in) :: potential

    !> Coordinates of all atoms
    real(dp), intent(in) :: coord(:,:)

    !> Lattice vectors
    real(dp), intent(in) :: latVec(:,:)

    !> Inverse of the lattice vectors
    real(dp), intent(in) :: invLatVec(:,:)

    !> Unit cell volume
    real(dp), intent(in) :: cellVol

    !> Central cell coordinates of atoms
    real(dp), intent(inout) :: coord0(:,:)

    !> Stress tensor
    real(dp), intent(out) :: totalStress(:,:)

    !> Energy derivatives with respect to lattice vectors
    real(dp), intent(out) :: totalLatDeriv(:,:)

    !> Internal pressure in cell
    real(dp), intent(out) :: intPressure

    !> Imaginary part of the density matrix (if present)
    real(dp), intent(in), allocatable :: iRhoPrim(:,:)

    !> Solvation model
    class(TSolvation), allocatable, intent(inout) :: solvation

    !> Dispersion interactions
    class(TDispersionIface), allocatable, intent(inout) :: dispersion

    !> Correction for halogen bonds
    type(THalogenX), allocatable, intent(inout) :: halogenXCorrection

    !> Determinant derived type
    type(TDftbDeterminants), intent(in) :: deltaDftb

    !> Stress tensor in triplet state (TI-DFTB excited states)
    real(dp), intent(inout), optional :: tripletStress(:,:)

    !> Stress tensor in mixed state (TI-DFTB excited states)
    real(dp), intent(inout), optional :: mixedStress(:,:)

    real(dp) :: tmpStress(3, 3)
    logical :: tImHam

    tImHam = allocated(iRhoPrim)
    totalStress(:, :) = 0.0_dp

    if (allocated(sccCalc)) then
      if (tImHam) then
        call getBlockiStress(env, totalStress, nonSccDeriv, rhoPrim, iRhoPrim, ERhoPrim, skHamCont,&
            & skOverCont, coord, species, neighbourList%iNeighbour, nNeighbourSK, img2CentCell,&
            & iSparseStart, orb, potential%intBlock, potential%iorbitalBlock, cellVol)
      else
        call getBlockStress(env, totalStress, nonSccDeriv, rhoPrim, ERhoPrim, skHamCont,&
            & skOverCont, coord, species, neighbourList%iNeighbour, nNeighbourSK, img2CentCell,&
            & iSparseStart, orb, potential%intBlock, cellVol)
      end if
      call sccCalc%addStressDc(totalStress, env, species, neighbourList%iNeighbour, img2CentCell)
      if (allocated(thirdOrd)) then
        call thirdOrd%addStressDc(neighbourList, species, coord, img2CentCell, cellVol, totalStress)
      end if
    else
      if (allocated(tblite)) then
        call tblite%getStress(tmpStress)
        totalStress(:, :) = totalStress + tmpStress
      else
        if (tImHam) then
          call getBlockiStress(env, totalStress, nonSccDeriv, rhoPrim, iRhoPrim, ERhoPrim,&
              & skHamCont, skOverCont, coord, species, neighbourList%iNeighbour, nNeighbourSK,&
              & img2CentCell, iSparseStart, orb, potential%intBlock, potential%iorbitalBlock,&
              & cellVol)
        else
          call getNonSCCStress(env, totalStress, nonSccDeriv, rhoPrim(:,1), ERhoPrim, skHamCont,&
              & skOverCont, coord, species, neighbourList%iNeighbour, nNeighbourSK, img2CentCell,&
              & iSparseStart, orb, cellVol)
        end if
      end if
    end if

    if (allocated(solvation)) then
      call solvation%getStress(tmpStress)
      totalStress(:,:) = totalStress + tmpStress
    end if

    if (allocated(dispersion)) then
      call dispersion%getStress(tmpStress)
      totalStress(:,:) = totalStress + tmpStress
    end if

    if (allocated(halogenXCorrection)) then
      call halogenXCorrection%getStress(tmpStress, coord, neighbourList, species, img2CentCell,&
          & cellVol)
      totalStress(:,:) = totalStress + tmpStress
    end if

    if (isExtField) then
      call getExtFieldStress(latVec, cellVol, q0, qOutput, potential%extGrad, coord0, tmpStress)
      totalStress(:,:) = totalStress + tmpStress
    end if

    if (allocated(repulsive)) then
      call repulsive%getStress(coord, species, img2CentCell, neighbourList, cellVol, tmpStress)
    else
      tmpStress(:,:) = 0.0_dp
    end if
    totalStress(:,:) = totalStress + tmpStress

    if(deltaDftb%isNonAufbau) then
      select case (deltaDftb%whichDeterminant(deltaDftb%iDeterminant))
      case (determinants%triplet)
        tripletStress(:,:) = totalStress
      case (determinants%mixed)
        mixedStress(:,:) = totalStress
      end select
    end if

    intPressure = (totalStress(1,1) + totalStress(2,2) + totalStress(3,3)) / 3.0_dp
    totalLatDeriv(:,:) = -cellVol * matmul(totalStress, invLatVec)

  end subroutine getStress


  !> Calculates stress from external electric field.
  subroutine getExtFieldStress(latVec, cellVol, q0, qOutput, extPotGrad, coord0, stress)

    !> Lattice vectors
    real(dp), intent(in) :: latVec(:,:)

    !> Unit cell volume
    real(dp), intent(in) :: cellVol

    !> Reference atomic charges
    real(dp), intent(in) :: q0(:,:,:)

    !> Number of electrons in each orbital
    real(dp), intent(in) :: qOutput(:,:,:)

    !> Gradient of the external field
    real(dp), intent(in) :: extPotGrad(:,:)

    !> Central cell coordinates of atoms
    real(dp), intent(inout) :: coord0(:,:)

    !> Stress tensor
    real(dp), intent(out) :: stress(:,:)

    real(dp) :: latDerivs(3,3)
    integer :: nAtom
    integer :: iAtom, ii, jj

    nAtom = size(coord0, dim=2)

    latDerivs(:,:) = 0.0_dp
    call cart2frac(coord0, latVec)
    do iAtom = 1, nAtom
      do ii = 1, 3
        do jj = 1, 3
          latDerivs(jj,ii) =  latDerivs(jj,ii)&
              & - sum(q0(:,iAtom,1) - qOutput(:,iAtom,1), dim=1) * extPotGrad(ii, iAtom)&
              & * coord0(jj, iAtom)
        end do
      end do
    end do
    call frac2cart(coord0, latVec)
    stress(:,:) = -matmul(latDerivs, transpose(latVec)) / cellVol

  end subroutine getExtFieldStress


  !> Removes forces components along constraint directions
  subroutine constrainForces(conAtom, conVec, derivs)

    !> Atoms being constrained
    integer, intent(in) :: conAtom(:)

    !> Vector to project out forces
    real(dp), intent(in) :: conVec(:,:)

    !> On input energy derivatives, on exit resulting projected derivatives
    real(dp), intent(inout) :: derivs(:,:)

    integer :: ii, iAtom

    ! Set force components along constraint vectors zero
    do ii = 1, size(conAtom)
      iAtom = conAtom(ii)
      derivs(:,iAtom) = derivs(:,iAtom)&
          & - conVec(:,ii) * dot_product(conVec(:,ii), derivs(:,iAtom))
    end do

  end subroutine constrainForces


  !> Flattens lattice components and applies lattice optimisation constraints.
  subroutine constrainLatticeDerivs(totalLatDerivs, normLatVecs, tLatOptFixAng,&
      & tLatOptFixLen, tLatOptIsotropic, constrLatDerivs)

    !> Energy derivative with respect to lattice vectors
    real(dp), intent(in) :: totalLatDerivs(:,:)

    !> Unit normals parallel to lattice vectors
    real(dp), intent(in) :: normLatVecs(:,:)

    !> Are the angles of the lattice being fixed during optimisation?
    logical, intent(in) :: tLatOptFixAng

    !> Are the magnitude of the lattice vectors fixed
    logical, intent(in) :: tLatOptFixLen(:)

    !> Is the optimisation isotropic
    logical, intent(in) :: tLatOptIsotropic

    !> Lattice vectors returned by the optimizer
    real(dp), intent(out) :: constrLatDerivs(:)

    real(dp) :: tmpLatDerivs(3, 3)
    integer :: ii

    tmpLatDerivs(:,:) = totalLatDerivs
    constrLatDerivs = reshape(tmpLatDerivs, [9])
    if (tLatOptFixAng) then
      ! project forces to be along original lattice
      tmpLatDerivs(:,:) = tmpLatDerivs * normLatVecs
      constrLatDerivs(:) = 0.0_dp
      if (any(tLatOptFixLen)) then
        do ii = 1, 3
          if (.not. tLatOptFixLen(ii)) then
            constrLatDerivs(ii) = sum(tmpLatDerivs(:,ii))
          end if
        end do
      else
        constrLatDerivs(1:3) = sum(tmpLatDerivs, dim=1)
      end if
    elseif (tLatOptIsotropic) then
      tmpLatDerivs(:,:) = tmpLatDerivs * normLatVecs
      constrLatDerivs(:) = 0.0_dp
      constrLatDerivs(1) = sum(tmpLatDerivs)
    end if

  end subroutine constrainLatticeDerivs


  !> Unfold constrained lattice vectors to full one.
  subroutine unconstrainLatticeVectors(constrLatVecs, origLatVecs, tLatOptFixAng, tLatOptFixLen,&
      & tLatOptIsotropic, newLatVecs)

    !> Packaged up lattice vectors (depending on optimisation mode)
    real(dp), intent(in) :: constrLatVecs(:)

    !> Original vectors at start
    real(dp), intent(in) :: origLatVecs(:,:)

    !> Are the angles of the lattice vectors fixed
    logical, intent(in) :: tLatOptFixAng

    !> Are the magnitudes of the lattice vectors fixed
    logical, intent(in) :: tLatOptFixLen(:)

    !> Is the optimisation isotropic
    logical, intent(in) :: tLatOptIsotropic

    !> Resulting lattice vectors
    real(dp), intent(out) :: newLatVecs(:,:)

    real(dp) :: tmpLatVecs(9)
    integer :: ii

    tmpLatVecs(:) = constrLatVecs
    if (tLatOptFixAng) then
      ! Optimization uses scaling factor of lattice vectors
      if (any(tLatOptFixLen)) then
        do ii = 3, 1, -1
          if (.not. tLatOptFixLen(ii)) then
            tmpLatVecs(3 * ii - 2 : 3 * ii) =  tmpLatVecs(ii) * origLatVecs(:,ii)
          else
            tmpLatVecs(3 * ii - 2 : 3 * ii) =  origLatVecs(:,ii)
          end if
        end do
      else
        tmpLatVecs(7:9) =  tmpLatVecs(3) * origLatVecs(:,3)
        tmpLatVecs(4:6) =  tmpLatVecs(2) * origLatVecs(:,2)
        tmpLatVecs(1:3) =  tmpLatVecs(1) * origLatVecs(:,1)
      end if
    else if (tLatOptIsotropic) then
      ! Optimization uses scaling factor unit cell
      do ii = 3, 1, -1
        tmpLatVecs(3 * ii - 2 : 3 * ii) =  tmpLatVecs(1) * origLatVecs(:,ii)
      end do
    end if
    newLatVecs(:,:) = reshape(tmpLatVecs, [3, 3])

  end subroutine unconstrainLatticeVectors


  !> Returns the coordinates for the next Hessian calculation step.
  subroutine getNextDerivStep(derivDriver, derivs, indMovedAtoms, indDerivAtoms, coord, tGeomEnd)

    !> Driver for the finite difference second derivatives
    type(TNumDerivs), intent(inout) :: derivDriver

    !> First derivatives of energy at the current coordinates
    real(dp), intent(in) :: derivs(:,:)

    !> Indices of moving atoms
    integer, intent(in) :: indMovedAtoms(:)

    !> Indices of atoms for which 2nd derivatives should be calculated
    integer, intent(in) :: indDerivAtoms(:)

    !> Atomic coordinates
    real(dp), intent(inout) :: coord(:,:)

    !> Has the process terminated
    logical, intent(out) :: tGeomEnd

    real(dp) :: newCoords(3, size(indMovedAtoms))

    call next(derivDriver, newCoords, derivs(:, indDerivAtoms), tGeomEnd)
    coord(:, indMovedAtoms) = newCoords

  end subroutine getNextDerivStep


  !> Returns the coordinates for the next coordinate optimisation step.
  subroutine getNextCoordinateOptStep(pGeoCoordOpt, energy, derivss, indMovedAtom, coord0,&
      & diffGeo, tCoordEnd, tRemoveExcitation)

    !> Optimiser for atomic coordinates
    type(TGeoOpt), intent(inout) :: pGeoCoordOpt

    !> Energies
    type(TEnergies), intent(in) :: energy

    !> Derivative of energy with respect to atomic coordinates
    real(dp), intent(in) :: derivss(:,:)

    !> Numbers of the moving atoms
    integer, intent(in) :: indMovedAtom(:)

    !> Central cell atomic coordinates
    real(dp), intent(inout) :: coord0(:,:)

    !> Largest change in atomic coordinates
    real(dp), intent(out) :: diffGeo

    !> Has the geometry optimisation finished
    logical, intent(out) :: tCoordEnd

    !> Remove excited state energy from the step, to be consistent with the forces
    logical, intent(in) :: tRemoveExcitation

    real(dp) :: derivssMoved(3 * size(indMovedAtom))
    real(dp), target :: newCoordsMoved(3 * size(indMovedAtom))
    real(dp), pointer :: pNewCoordsMoved(:,:)

    derivssMoved(:) = reshape(derivss(:, indMovedAtom), [3 * size(indMovedAtom)])
    if (tRemoveExcitation) then
      call next(pGeoCoordOpt, energy%EForceRelated, derivssMoved, newCoordsMoved, tCoordEnd)
    else
      call next(pGeoCoordOpt, energy%EForceRelated + energy%Eexcited, derivssMoved, newCoordsMoved,&
          & tCoordEnd)
    end if
    pNewCoordsMoved(1:3, 1:size(indMovedAtom)) => newCoordsMoved(1 : 3 * size(indMovedAtom))
    diffGeo = maxval(abs(pNewCoordsMoved - coord0(:, indMovedAtom)))
    coord0(:, indMovedAtom) = pNewCoordsMoved

  end subroutine getNextCoordinateOptStep


  !> Returns the coordinates and lattice vectors for the next lattice optimisation step.
  subroutine getNextLatticeOptStep(pGeoLatOpt, energy, constrLatDerivs, origLatVec, tLatOptFixAng,&
      & tLatOptFixLen, tLatOptIsotropic, indMovedAtom, latVec, coord0, diffGeo, tGeomEnd)

    !> Lattice vector optimising object
    type(TGeoOpt), intent(inout) :: pGeoLatOpt

    !> Energy contributions and total
    type(TEnergies), intent(inout) :: energy

    !> Lattice vectors returned by the optimizer
    real(dp), intent(in) :: constrLatDerivs(:)

    !> Starting lattice vectors
    real(dp), intent(in) :: origLatVec(:,:)

    !> Fix angles between lattice vectors
    logical, intent(in) :: tLatOptFixAng

    !> Fix the magnitudes of lattice vectors
    logical, intent(in) :: tLatOptFixLen(:)

    !> Optimise isotropically
    logical, intent(in) :: tLatOptIsotropic

    !> Numbers of the moving atoms
    integer, intent(in) :: indMovedAtom(:)

    !> Lattice vectors
    real(dp), intent(inout) :: latVec(:,:)

    !> Central cell coordinates of atoms
    real(dp), intent(inout) :: coord0(:,:)

    !> Maximum change in geometry at this step
    real(dp), intent(out) :: diffGeo

    !> Has the geometry optimisation finished
    logical, intent(out) :: tGeomEnd

    real(dp) :: newLatVecsFlat(9), newLatVecs(3, 3), oldMovedCoords(3, size(indMovedAtom))

    call next(pGeoLatOpt, energy%EForceRelated, constrLatDerivs, newLatVecsFlat,tGeomEnd)
    call unconstrainLatticeVectors(newLatVecsFlat, origLatVec, tLatOptFixAng, tLatOptFixLen,&
        & tLatOptIsotropic, newLatVecs)
    oldMovedCoords(:,:) = coord0(:, indMovedAtom)
    call cart2frac(coord0, latVec)
    latVec(:,:) = newLatVecs
    call frac2cart(coord0, latVec)
    diffGeo = max(maxval(abs(newLatVecs - latVec)),&
        & maxval(abs(oldMovedCoords - coord0(:, indMovedAtom))))

  end subroutine getNextLatticeOptStep


  !> Delivers data for next MD step (and updates data depending on velocities of current step)
  subroutine getNextMdStep(pMdIntegrator, pMdFrame, temperatureProfile, derivs, movedMass,&
      & mass, cellVol, invLatVec, species0, indMovedAtom, tStress, tBarostat, energy, coord0,&
      & latVec, intPressure, totalStress, totalLatDeriv, velocities, tempIon)

    !> Molecular dynamics integrator
    type(TMdIntegrator), intent(inout) :: pMdIntegrator

    !> Molecular dynamics reference frame information
    type(TMdCommon), intent(in) :: pMdFrame

    !> Temperature profile in MD
    type(TTempProfile), allocatable, intent(inout) :: temperatureProfile

    !> Energy derivative wrt to atom positions
    real(dp), intent(in) :: derivs(:,:)

    !> Masses of moving atoms
    real(dp), intent(in) :: movedMass(:,:)

    !> Masses of each chemical species
    real(dp), intent(in) :: mass(:)

    !> Unit cell volume
    real(dp), intent(in) :: cellVol

    !> Inverse of the lattice vectors
    real(dp), intent(in) :: invLatVec(:,:)

    !> Species of atoms in the central cell
    integer, intent(in) :: species0(:)

    !> Numbers of the moving atoms
    integer, intent(in) :: indMovedAtom(:)

    !> Is stress being evaluated?
    logical, intent(in) :: tStress

    !> Is there a barostat
    logical, intent(in) :: tBarostat

    !> Energy contributions and total
    type(TEnergies), intent(inout) :: energy

    !> Central cell coordinates of atoms
    real(dp), intent(inout) :: coord0(:,:)

    !> Lattice vectors
    real(dp), intent(inout) :: latVec(:,:)

    !> Internal pressure in the unit cell
    real(dp), intent(inout) :: intPressure

    !> Stress tensor
    real(dp), intent(inout) :: totalStress(:,:)

    !> Derivative of energy with respect to lattice vectors
    real(dp), intent(inout) :: totalLatDeriv(:,:)

    !> Atomic velocities
    real(dp), intent(out) :: velocities(:,:)

    !> Atomic kinetic energy
    real(dp), intent(out) :: tempIon

    real(dp) :: movedAccel(3, size(indMovedAtom)), movedVelo(3, size(indMovedAtom))
    real(dp) :: movedCoords(3, size(indMovedAtom))
    real(dp) :: kineticStress(3, 3)

    movedAccel(:,:) = -derivs(:, indMovedAtom) / movedMass
    call next(pMdIntegrator, movedAccel, movedCoords, movedVelo)
    coord0(:, indMovedAtom) = movedCoords
    velocities(:,:) = 0.0_dp
    velocities(:, indMovedAtom) = movedVelo(:,:)

    if (allocated(temperatureProfile)) then
      call temperatureProfile%next()
    end if
    call evalKE(energy%Ekin, movedVelo, movedMass(1,:))
    call evalkT(pMdFrame, tempIon, movedVelo, movedMass(1,:))
    energy%EMerminKin = energy%EMermin + energy%Ekin
    energy%EGibbsKin = energy%EGibbs + energy%Ekin
    energy%EForceRelated = energy%EForceRelated + energy%Ekin

    if (tStress) then
      ! contribution from kinetic energy in MD, now that velocities for this geometry step are
      ! available
      call getKineticStress(kineticStress, mass, species0, velocities, cellVol)
      totalStress = totalStress + kineticStress
      intPressure = (totalStress(1,1) + totalStress(2,2) + totalStress(3,3)) / 3.0_dp
      totalLatDeriv = -cellVol * matmul(totalStress, invLatVec)
    end if

    if (tBarostat) then
      call rescale(pMDIntegrator, coord0, latVec, totalStress)
    end if

  end subroutine getNextMdStep


  !> Calculates and prints Pipek-Mezey localisation
  subroutine calcPipekMezeyLocalisation(env, pipekMezey, tPrintEigvecsTxt, nEl, filling, ints,&
      & kPoint, neighbourList, nNeighbourSK, denseDesc,  iSparseStart, img2CentCell, iCellVec,&
      & cellVec, runId, orb, species, speciesName, parallelKS, localisation, eigvecsReal, SSqrReal,&
      & eigvecsCplx, SSqrCplx, tHelical, coord)

    !> Environment settings
    type(TEnvironment), intent(in) :: env

    !> Localisation methods for single electron states (if used)
    type(TPipekMezey), intent(in) :: pipekMezey

    !> Store eigenvectors as a text file
    logical, intent(in) :: tPrintEigVecsTxt

    !> Number of electrons
    real(dp), intent(in) :: nEl(:)

    !> Occupations of single particle states in the ground state
    real(dp), intent(in) :: filling(:,:,:)

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> The k-points in the system (0,0,0) if molecular
    real(dp), intent(in) :: kPoint(:,:)

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Index for which unit cell atoms are associated with
    integer, intent(in) :: iCellVec(:)

    !> Vectors (in units of the lattice constants) to cells of the lattice
    real(dp), intent(in) :: cellVec(:,:)

    !> Job ID for future identification
    integer, intent(in) :: runId

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Species of all atoms in the system
    integer, intent(in) :: species(:)

    !> Label for each atomic chemical species
    character(*), intent(in) :: speciesName(:)

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Localisation measure of single particle states
    real(dp), intent(out) :: localisation

    !> Storage for dense hamiltonian matrix
    real(dp), intent(inout), allocatable :: eigvecsReal(:,:,:)

    !> Storage for dense overlap matrix
    real(dp), intent(inout), allocatable :: SSqrReal(:,:)

    !> Storage for dense hamiltonian matrix (complex case)
    complex(dp), intent(inout), allocatable :: eigvecsCplx(:,:,:)

    !> Storage for dense overlap matrix (complex case)
    complex(dp), intent(inout), allocatable :: SSqrCplx(:,:)

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Atomic coordinates
    real(dp), intent(in) :: coord(:,:)

    integer :: nFilledLev, nAtom, nSpin
    integer :: iSpin, iKS, iK

    nAtom = size(orb%nOrbAtom)
    nSpin = size(nEl)

    if (any(abs(mod(filling, real(3 - nSpin, dp))) > elecTolMax)) then
      call warning("Fractional occupations allocated for electron localisation")
    end if

    if (allocated(eigvecsReal)) then
      if (tHelical) then
        call unpackHelicalHS(SSqrReal, ints%overlap, neighbourList%iNeighbour, nNeighbourSK,&
            & denseDesc%iAtomStart, iSparseStart, img2CentCell, orb, species, coord)
      else
        call unpackHS(SSqrReal, ints%overlap, neighbourList%iNeighbour, nNeighbourSK,&
            & denseDesc%iAtomStart, iSparseStart, img2CentCell)
      end if
      do iKS = 1, parallelKS%nLocalKS
        iSpin = parallelKS%localKS(2, iKS)
        nFilledLev = nint(nEl(iSpin) / real(3 - nSpin, dp))
        localisation = pipekMezey%getLocalisation(eigvecsReal(:, 1:nFilledLev, iKS), SSqrReal,&
            & denseDesc%iAtomStart)
        write(stdOut, "(A, E15.8)") 'Original localisation', localisation
        call pipekMezey%calcCoeffs(eigvecsReal(:, 1:nFilledLev, iKS), SSqrReal,&
            & denseDesc%iAtomStart)
        localisation = pipekMezey%getLocalisation(eigvecsReal(:,1:nFilledLev,iKS), SSqrReal,&
            & denseDesc%iAtomStart)
        write(stdOut, "(A, E20.12)") 'Final localisation ', localisation
      end do

      call writeRealEigvecs(env, runId, neighbourList, nNeighbourSK, denseDesc, iSparseStart,&
          & img2CentCell, species(:nAtom), speciesName, orb, ints%overlap, parallelKS,&
          & tPrintEigvecsTxt, eigvecsReal, SSqrReal, fileName="localOrbs")
    else

      localisation = 0.0_dp
      do iKS = 1, parallelKS%nLocalKS
        iK = parallelKS%localKS(1, iKS)
        iSpin = parallelKS%localKS(2, iKS)
        nFilledLev = nint(nEl(iSpin) / real( 3 - nSpin, dp))
        localisation = localisation + pipekMezey%getLocalisation(&
            & eigvecsCplx(:,:nFilledLev,iKS), SSqrCplx, ints%overlap, kpoint(:,iK), neighbourList,&
            & nNeighbourSK, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart, img2CentCell)
      end do
      write(stdOut, "(A, E20.12)") 'Original localisation', localisation

      ! actual localisation calls
      do iKS = 1, parallelKS%nLocalKS
        iK = parallelKS%localKS(1, iKS)
        iSpin = parallelKS%localKS(2, iKS)
        nFilledLev = nint(nEl(iSpin) / real( 3 - nSpin, dp))
        call pipekMezey%calcCoeffs(eigvecsCplx(:,:nFilledLev,iKS), SSqrCplx, ints%overlap,&
            & kpoint(:,iK), neighbourList, nNeighbourSK, iCellVec, cellVec, denseDesc%iAtomStart,&
            & iSparseStart, img2CentCell)
      end do

      localisation = 0.0_dp
      do iKS = 1, parallelKS%nLocalKS
        iK = parallelKS%localKS(1, iKS)
        iSpin = parallelKS%localKS(2, iKS)
        nFilledLev = nint(nEl(iSpin) / real( 3 - nSpin, dp))
        localisation = localisation + pipekMezey%getLocalisation(&
            & eigvecsCplx(:,:nFilledLev,iKS), SSqrCplx, ints%overlap, kpoint(:,iK), neighbourList,&
            & nNeighbourSK, iCellVec, cellVec, denseDesc%iAtomStart, iSparseStart, img2CentCell)
      end do
      write(stdOut, "(A, E20.12)") 'Final localisation', localisation

      call writeCplxEigvecs(env, runId, neighbourList, nNeighbourSK, cellVec, iCellVec, denseDesc,&
          & iSparseStart, img2CentCell, species, speciesName, orb, kPoint, ints%overlap,&
          & parallelKS, tPrintEigvecsTxt, eigvecsCplx, SSqrCplx, fileName="localOrbs")

    end if

  end subroutine calcPipekMezeyLocalisation


  !> Prints information about maximal forces in the system.
  subroutine printMaxForces(derivs, constrLatDerivs, tCoordOpt, tLatOpt, indMovedAtoms)

    !> Gradients on atoms ]3, nAtom]
    real(dp), intent(in), allocatable :: derivs(:,:)

    !> Lattice derivatives. Shape: [9]
    real(dp), intent(in) :: constrLatDerivs(:)

    !> Whether coordinate optimization is on.
    logical, intent(in) :: tCoordOpt

    !> Whether lattice optimization is on.
    logical, intent(in) :: tLatOpt

    !> Indices of moved atoms. Shape [nMovedAtoms].
    integer, intent(in) :: indMovedAtoms(:)

    real(dp) :: normedDeriv

    if (tCoordOpt) then
      call printMaxForce(maxval(abs(derivs(:, indMovedAtoms))))
      normedDeriv = norm2(derivs(:, indMovedAtoms)) / sqrt(real(size(indMovedAtoms), dp))
      call printForceNorm(normedDeriv)
    end if
    if (tLatOpt) then
      call printMaxLatticeForce(maxval(abs(constrLatDerivs)))
      normedDeriv = norm2(constrLatDerivs) / sqrt(3.0_dp)
      call printLatticeForceNorm(normedDeriv)
    end if

  end subroutine printMaxForces


#:if WITH_SOCKETS

  subroutine sendEnergyAndForces(env, socket, energy, derivs, totalStress, cellVol)

    !> Environment
    type(TEnvironment), intent(in) :: env

    !> Socket may be unallocated (as on follower processes)
    type(ipiSocketComm), allocatable, intent(inout) :: socket

    !> Energy structure
    type(TEnergies), intent(in) :: energy

    !> Energy derivatives
    real(dp), intent(in) :: derivs(:,:)

    !> Stress tensor
    real(dp), intent(in) :: totalStress(:,:)

    !> Cell volume
    real(dp), intent(in) :: cellVol

    if (env%tGlobalLead) then
      ! stress was computed above in the force evaluation block or is 0 if aperiodic
      call socket%send(energy%ETotal - sum(energy%TS), -derivs, totalStress * cellVol)
    end if
  end subroutine sendEnergyAndForces

#:endif


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!! REKS subroutines
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  !> Diagonalize H0 to obtain initial guess of eigenvectors
  !> or read eigenvectors in REKS
  !> Save dense overlap matrix elements
  !> Check Gamma point condition and set filling information
  subroutine getReksInitialSettings(env, denseDesc, h0, ints, neighbourList, nNeighbourSK,&
      & iSparseStart, img2CentCell, electronicSolver, iGeoStep, HSqrReal, SSqrReal, eigvecsReal,&
      & eigen, reks, errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Hamiltonian in sparse storage
    real(dp), intent(in) :: h0(:)

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Electronic solver information
    type(TElectronicSolver), intent(inout) :: electronicSolver

    !> Number of current geometry step
    integer, intent(in) :: iGeoStep

    !> Dense hamiltonian matrix
    real(dp), intent(out) :: HSqrReal(:,:)

    !> Dense overlap matrix
    real(dp), intent(out) :: SSqrReal(:,:)

    !> Eigenvectors on eixt
    real(dp), intent(inout) :: eigvecsReal(:,:,:)

    !> Eigenvalues
    real(dp), intent(out) :: eigen(:,:,:)

    !> Data type for REKS
    type(TReksCalc), intent(inout) :: reks

    !> Status of operation
    type(TStatus), intent(out) :: errStatus

    call env%globalTimer%startTimer(globalTimers%sparseToDense)
    call unpackHS(SSqrReal, ints%overlap, neighbourList%iNeighbour, nNeighbourSK, &
        & denseDesc%iAtomStart, iSparseStart, img2CentCell)
    call env%globalTimer%stopTimer(globalTimers%sparseToDense)

    reks%overSqr(:,:) = SSqrReal
    call adjointLowerTriangle(reks%overSqr)

    if (iGeoStep == 0) then

      if (.not. reks%tReadMO) then

        call env%globalTimer%startTimer(globalTimers%sparseToDense)
        call unpackHS(HSqrReal, h0, neighbourList%iNeighbour, nNeighbourSK, &
            & denseDesc%iAtomStart, iSparseStart, img2CentCell)
        call env%globalTimer%stopTimer(globalTimers%sparseToDense)

        eigen(:,:,:) = 0.0_dp
        call env%globalTimer%startTimer(globalTimers%diagonalization)
        call diagDenseMtx(env, electronicSolver, 'V', HSqrReal, SSqrReal, eigen(:,1,1), errStatus)
        @:PROPAGATE_ERROR(errStatus)
        call env%globalTimer%stopTimer(globalTimers%diagonalization)
        eigvecsReal(:,:,1) = HSqrReal

      else

        call readEigenvecs(eigvecsReal(:,:,1))
        call renormalizeEigenvecs(env, eigvecsReal, reks)

      end if

      call constructMicrostates(reks)

    else

      call renormalizeEigenvecs(env, eigvecsReal, reks)

    end if

    call checkGammaPoint(denseDesc, neighbourList%iNeighbour, &
        & nNeighbourSK, iSparseStart, img2CentCell, ints%overlap, reks)

  end subroutine getReksInitialSettings


  !> Normalize eigenvectors with unitary transformation
  subroutine renormalizeEigenvecs(env, eigvecsReal, reks)
    use dftbp_math_blasroutines, only : gemm
    use dftbp_math_eigensolver, only : heev

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Eigenvectors on eixt
    real(dp), intent(inout) :: eigvecsReal(:,:,:)

    !> Data type for REKS
    type(TReksCalc), intent(inout) :: reks

    real(dp), allocatable :: tmpMat(:,:)
    real(dp), allocatable :: tmpS(:,:)
    real(dp), allocatable :: tmpC(:,:)
    real(dp), allocatable :: tmpEigen(:)
    real(dp), allocatable :: unitaryMat(:,:)

    integer :: nOrb, ii

    nOrb = size(reks%overSqr,dim=1)

    allocate(tmpMat(nOrb,nOrb))
    allocate(tmpS(nOrb,nOrb))
    allocate(tmpC(nOrb,nOrb))
    allocate(tmpEigen(nOrb))
    allocate(unitaryMat(nOrb,nOrb))

    ! Calculate CSC = C^T_old * S_new * C_old
    tmpMat(:,:) = 0.0_dp
    call gemm(tmpMat, eigvecsReal(:,:,1), reks%overSqr, transA='T')
    tmpC(:,:) = 0.0_dp
    call gemm(tmpC, tmpMat, eigvecsReal(:,:,1))

    ! Diagonalize CSC to obtain a unitary matrix, U = CSC^(-1/2)

    tmpEigen(:) = 0.0_dp
    call env%globalTimer%startTimer(globalTimers%diagonalization)
    ! tmpC becomes eigenvectors (X) of CSC
    call heev(tmpC, tmpEigen, 'U', 'V')
    call env%globalTimer%stopTimer(globalTimers%diagonalization)

    ! Make inverse square root matrix consisting of eigenvalues (s) of CSC
    tmpS(:,:) = 0.0_dp
    do ii = 1, nOrb
      tmpS(ii,ii) = 1.0_dp / max(sqrt(tmpEigen(ii)), epsilon(0.0_dp))
    end do

    ! Calculate a unitary matrix U = CSC^(-1/2) = X * s^(-1/2) * X^T
    tmpMat(:,:) = 0.0_dp
    call gemm(tmpMat, tmpS, tmpC, transB='T')
    unitaryMat(:,:) = 0.0_dp
    call gemm(unitaryMat, tmpC, tmpMat)

    ! C_new = C_old * U
    tmpC(:,:) = 0.0_dp
    call gemm(tmpC, eigvecsReal(:,:,1), unitaryMat)

    eigvecsReal(:,:,1) = tmpC

  end subroutine renormalizeEigenvecs


  !> Creates (delta) density matrix for each microstate from real eigenvectors.
  subroutine getDensityMatrixL(env, denseDesc, neighbourList, nNeighbourSK, iSparseStart,&
      & img2CentCell, orb, species, coord, tPeriodic, tHelical, eigvecs, parallelKS, rhoPrim, work,&
      & rhoSqrReal, q0, densityMatrix, hybridXc, reks, apiCallBack, errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> List of neighbours for each atom
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each of the atoms
    integer, intent(in) :: nNeighbourSK(:)

    !> Index array for the start of atomic blocks in sparse arrays
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atoms to the original unique atom
    integer, intent(in) :: img2CentCell(:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Species of all atoms
    integer, target, intent(in) :: species(:)

    !> Coordinates of all atoms including images
    real(dp), allocatable, intent(inout) :: coord(:,:)

    !> Is the system periodic (gamma/general k-points)?
    logical, intent(in) :: tPeriodic

    !> Is the geometry helical
    logical, intent(in) :: tHelical

    !> Eigenvectors
    real(dp), intent(inout) :: eigvecs(:,:,:)

    !> The k-points and spins to process
    type(TParallelKS), intent(in) :: parallelKS

    !> Sparse density matrix
    real(dp), intent(inout) :: rhoPrim(:,:)

    !> Work space array
    real(dp), intent(inout) :: work(:,:)

    !> Dense density matrix if needed
    real(dp), intent(inout), allocatable :: rhoSqrReal(:,:,:)

    !> Reference atomic occupations
    real(dp), intent(in) :: q0(:,:,:)

    !> Holds real and complex delta density matrices and pointers
    type(TDensityMatrix), intent(inout) :: densityMatrix

    !> Data for hybrid xc-functional calculation
    class(THybridXcFunc), intent(in), allocatable :: hybridXc

    !> Data type for REKS
    type(TReksCalc), intent(inout) :: reks

    !> Object for invocation of the density, overlap, and hamiltonian matrices exported by callbacks
    type(TAPICallback), intent(inout), allocatable :: apiCallBack

    !> Error status
    type(TStatus), intent(out) :: errStatus

    integer :: iL

    call env%globalTimer%startTimer(globalTimers%densityMatrix)

    if (reks%tForces) then
      reks%rhoSqrL(:,:,:,:) = 0.0_dp
    else
      reks%rhoSpL(:,:,:) = 0.0_dp
    end if

    do iL = 1, reks%Lmax

      call getDensityFromRealEigvecs(env, denseDesc, reks%fillingL(:,:,iL), neighbourList,&
          & nNeighbourSK, iSparseStart, img2CentCell, orb, species, coord, tPeriodic, tHelical,&
          & eigvecs, parallelKS, densityMatrix, rhoPrim, work, rhoSqrReal, hybridXc, apiCallBack,&
          & errStatus)
      @:PROPAGATE_ERROR(errStatus)

      if (reks%tForces) then
        ! reks%rhoSqrL has (my_ud) component
        if (reks%isHybridXc) then
          reks%rhoSqrL(:,:,1,iL) = densityMatrix%deltaRhoOut(:,:,1)
        else
          reks%rhoSqrL(:,:,1,iL) = work
        end if
      else
        ! reks%rhoSpL has (my_ud) component
        reks%rhoSpL(:,1,iL) = rhoPrim(:,1)
      end if

      if (reks%isHybridXc) then
        ! reks%deltaRhoSqrL has (my_ud) component
        reks%deltaRhoSqrL(:,:,1,iL) = densityMatrix%deltaRhoOut(:,:,1)
      end if

      if (reks%tForces) then
        call adjointLowerTriangle(reks%rhoSqrL(:,:,1,iL))
      end if
      if (reks%isHybridXc) then
        call adjointLowerTriangle(reks%deltaRhoSqrL(:,:,1,iL))
        call denseSubtractDensityOfAtomsSpinRealNonperiodicReks(q0, denseDesc%iAtomStart,&
            & reks%deltaRhoSqrL(:,:,:,iL), 1)
      end if

    end do

    if (reks%tForces) then
      ! reks%rhoSqrL has (my_qm) component
      call ud2qmL(reks%rhoSqrL, reks%Lpaired)
    else
      ! reks%rhoSpL has (my_qm) component
      call ud2qmL(reks%rhoSpL, reks%Lpaired)
    end if

    call env%globalTimer%stopTimer(globalTimers%densityMatrix)

  end subroutine getDensityMatrixL


  !> Calculate Mulliken population for each microstate from sparse density matrix.
  subroutine getMullikenPopulationL(env, denseDesc, neighbourList, nNeighbourSK, &
      & img2CentCell, iSparseStart, orb, rhoPrim, ints, iRhoPrim, qBlock, &
      & qiBlock, qNetAtom, reks)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> Atomic neighbours
    type(TNeighbourList), intent(in) :: neighbourList

    !> Number of neighbours for each atom within overlap distance
    integer, intent(in) :: nNeighbourSK(:)

    !> Image to actual atom indexing
    integer, intent(in) :: img2CentCell(:)

    !> Sparse matrix indexing array
    integer, intent(in) :: iSparseStart(:,:)

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Sparse density matrix
    real(dp), intent(inout) :: rhoPrim(:,:)

    !> Integral container
    type(TIntegral), intent(in) :: ints

    !> Imaginary part of density matrix
    real(dp), intent(in), allocatable :: iRhoPrim(:,:)

    !> Dual atomic charges
    real(dp), intent(inout), allocatable :: qBlock(:,:,:,:)

    !> Imaginary part of dual atomic charges
    real(dp), intent(inout), allocatable :: qiBlock(:,:,:,:)

    !> Onsite Mulliken charges per atom
    real(dp), intent(inout), allocatable :: qNetAtom(:)

    !> Data type for REKS
    type(TReksCalc), intent(inout) :: reks

    integer :: iL

    do iL = 1, reks%Lmax

      if (reks%tForces) then
        rhoPrim(:,1) = 0.0_dp
        call env%globalTimer%startTimer(globalTimers%denseToSparse)
        call packHS(rhoPrim(:,1), reks%rhoSqrL(:,:,1,iL), neighbourlist%iNeighbour, &
            & nNeighbourSK, orb%mOrb, denseDesc%iAtomStart, iSparseStart, img2CentCell)
        call env%globalTimer%stopTimer(globalTimers%denseToSparse)
      else
        rhoPrim(:,1) = reks%rhoSpL(:,1,iL)
      end if

      ! reks%qOutputL & reks%qNetAtomL has (my_qm) component
      reks%qOutputL(:,:,:,iL) = 0.0_dp
      call getMullikenPopulation(env, rhoPrim, ints, orb, neighbourList, nNeighbourSK, &
          & img2CentCell, iSparseStart, reks%qOutputL(:,:,:,iL), iRhoPrim=iRhoPrim, &
          & qBlock=qBlock, qiBlock=qiBlock, qNetAtom=qNetAtom)

      ! Get correct net charge per atom
      ! Note that qNetAtomL does not have spin dependency so it does not
      ! correspond to (my_qm) or (my_ud) representation
      if (reks%isQNetAllocated) then
        if (iL > reks%Lpaired) then
          if (mod(iL,2) == 0) then
            reks%qNetAtomL(:,iL) = reks%qNetAtomL(:,iL-1)
          else
            reks%qNetAtomL(:,iL) = qNetAtom
          end if
        else
          reks%qNetAtomL(:,iL) = qNetAtom
        end if
      end if

    end do

    ! reks%qOutputL has (qm) component
    call qmExpandL(reks%qOutputL, reks%Lpaired)

  end subroutine getMullikenPopulationL


  !> Build L, spin dependent Hamiltonian with various contributions
  !> and compute the energy of microstates
  subroutine getHamiltonianLandEnergyL(env, denseDesc, sccCalc, tblite, orb, species,&
      & neighbourList, symNeighbourList, nNeighbourSK, iSparseStart, img2CentCell, H0, ints, spinW,&
      & cellVol, extPressure, energy, q0, iAtInCentralRegion, solvation, thirdOrd, potential,&
      & hybridXc, nNeighbourCam, nNeighbourCamSym, tDualSpinOrbit, xi, isExtField, isXlbomd, dftbU,&
      & TS, qDepExtPot, qBlock, qiBlock, tFixEf, Ef, rhoPrim, onSiteElements, dispersion,&
      & tConverged, species0, referenceN0, qNetAtom, multipole, reks, errStatus)

    !> Environment settings
    type(TEnvironment), intent(inout) :: env

    !> Dense matrix descriptor
    type(TDenseDescr), intent(in) :: denseDesc

    !> SCC module internal variables
    type(TScc), allocatable, intent(inout) :: sccCalc

    !> Library interface handler
    type(TTBLite), allocatable, intent(inout) :: tblite

    !> Atomic orbital information
    type(TOrbitals), intent(in) :: orb

    !> Species of all atoms
    integer, target, intent(in) :: species(:)

    !> Neighbours to atoms
    type(TNeighbourList), intent(in) :: neighbourList

    !> List of neighbouring atoms (symmetric version)
    type(TSymNeighbourList), intent(in), allocatable :: symNeighbourList

    !> Number of atomic neighbours
    integer, intent(in) :: nNeighbourSK(:)

    !> Index for atomic blocks in sparse data
    integer, intent(in) :: iSparseStart(:,:)

    !> Map from image atom to real atoms
    integer, intent(in) :: img2CentCell(:)

    !> Non-SCC hamiltonian (sparse)
    real(dp), intent(in) :: H0(:)

    !> Integral container
    type(TIntegral), intent(inout) :: ints

    !> Spin constants
    real(dp), allocatable, intent(in) :: spinW(:,:,:)

    !> Unit cell volume
    real(dp), intent(in) :: cellVol

    !> External pressure
    real(dp), intent(in) :: extPressure

    !> Energy contributions
    type(TEnergies), intent(inout) :: energy

    !> Reference atomic occupations
    real(dp), intent(in) :: q0(:,:,:)

    !> Atoms over which to sum the total energies
    integer, intent(in) :: iAtInCentralRegion(:)

    !> Solvation mode
    class(TSolvation), allocatable, intent(inout) :: solvation

    !> Third order SCC interactions
    type(TThirdOrder), allocatable, intent(inout) :: thirdOrd

    !> Potentials acting
    type(TPotentials), intent(inout) :: potential

    !> Data for hybrid xc-functional calculation
    class(THybridXcFunc), allocatable, intent(inout) :: hybridXc

    !> Nr. of neighbours for each atom in the CAM functional
    integer, intent(in), allocatable :: nNeighbourCam(:)

    !> Symmetric neighbour list version of nNeighbourCam
    integer, intent(in), allocatable :: nNeighbourCamSym(:)

    !> Is dual spin orbit being used (block potentials)
    logical, intent(in) :: tDualSpinOrbit

    !> Spin orbit constants if required
    real(dp), allocatable, intent(in) :: xi(:,:)

    !> Is an external electric field present
    logical, intent(in) :: isExtField

    !> Is the extended Lagrangian being used for MD
    logical, intent(in) :: isXlbomd

    !> Are there orbital potentials present
    type(TDftbU), intent(in), allocatable :: dftbU

    !> Electron entropy contribution
    real(dp), intent(in) :: TS(:)

    !> Proxy for querying Q-dependant external potentials
    type(TQDepExtPotProxy), intent(inout), allocatable :: qDepExtPot

    !> Block (dual) atomic populations
    real(dp), intent(in), allocatable :: qBlock(:,:,:,:)

    !> Imaginary part of block atomic populations
    real(dp), intent(in), allocatable :: qiBlock(:,:,:,:)

    !> Whether fixed Fermi level(s) should be used. (No charge conservation!)
    logical, intent(in) :: tFixEf

    !> If tFixEf is .true. contains reservoir chemical potential, otherwise the Fermi levels found
    !> from the given number of electrons
    real(dp), intent(inout) :: Ef(:)

    !> Sparse density matrix
    real(dp), intent(inout) :: rhoPrim(:,:)

    !> Corrections terms for on-site elements
    real(dp), intent(in), allocatable :: onSiteElements(:,:,:,:)

    !> Dispersion interactions
    class(TDispersionIface), allocatable, intent(inout) :: dispersion

    !> Has the calculation converged>
    logical, intent(in) :: tConverged

    !> Species of atoms in the central cell
    integer, intent(in) :: species0(:)

    !> Reference n_0 charges for each atom
    real(dp), intent(in) :: referenceN0(:,:)

    !> Onsite Mulliken charges per atom
    real(dp), intent(inout), allocatable :: qNetAtom(:)

    !> Multipole container
    type(TMultipole), intent(inout) :: multipole

    !> Data type for REKS
    type(TReksCalc), allocatable, intent(inout) :: reks

    !> Error status
    type(TStatus), intent(inout) :: errStatus

    real(dp), allocatable :: tmpHamSp(:,:)
    real(dp), allocatable :: tmpEn(:)

    integer, pointer :: pSpecies0(:)
    integer :: sparseSize, nAtom, nSpin, iL, tmpL, rsL

    sparseSize = size(ints%overlap,dim=1)
    nAtom = size(reks%qOutputL,dim=2)
    nSpin = size(reks%qOutputL,dim=3)
    pSpecies0 => species(1:nAtom)

    allocate(tmpHamSp(sparseSize,1))
    if (reks%isHybridXc) then
      allocate(tmpEn(reks%Lmax))
    end if

    ! Calculate contribution to Hamiltonian except hybrid xc-functional part
    reks%intShellL(:,:,:,:) = 0.0_dp
    reks%intBlockL(:,:,:,:,:) = 0.0_dp
    do iL = 1, reks%Lmax

      ! reks%chargePerShellL has (qm) component
      call getChargePerShell(reks%qOutputL(:,:,:,iL), orb, species,&
          & reks%chargePerShellL(:,:,:,iL))
      call resetInternalPotentials(tDualSpinOrbit, xi, orb, species, potential)
      call addChargePotentials(env, sccCalc, tblite, .true., reks%qOutputL(:,:,:,iL), q0,&
          & reks%chargePerShellL(:,:,:,iL), orb, multipole, species, neighbourList,&
          & img2CentCell, spinW, solvation, thirdOrd, dispersion, potential)

      ! reks%intShellL, reks%intBlockL has (qm) component
      reks%intShellL(:,:,:,iL) = potential%intShell
      reks%intBlockL(:,:,:,:,iL) = potential%intBlock

      ! qm representation is converted to my_qm representation
      if (iL <= reks%Lpaired) then
        ! If iL = 1, then qm = 1u + 1d, 1u - 1d and my_qm = 1u + 1d
        ! calculate charge part
        potential%intBlock(:,:,:,1) = reks%intBlockL(:,:,:,1,iL)
        tmpHamSp(:,1) = h0
      else
        if (mod(iL,2) == 1) then
          ! If iL = 3, then qm = 3u + 3d, 3u - 3d and my_qm = 3u + 3d
          ! calculate charge part
          potential%intBlock(:,:,:,1) = reks%intBlockL(:,:,:,1,iL)
          tmpHamSp(:,1) = h0
        else
          ! If iL = 4, then qm = 4u + 4d, 4u - 4d and my_qm = 3u - 3d (= -(4u - 4d))
          ! calculate magnetization part
          potential%intBlock(:,:,:,1) = -reks%intBlockL(:,:,:,2,iL)
          tmpHamSp(:,1) = 0.0_dp
        end if
      end if

      ! tmpHamSp has (my_qm) component
      call getSccHamiltonian(env, H0, ints, nNeighbourSK, neighbourList, species, orb,&
          & iSparseStart, img2CentCell, potential, allocated(reks), tmpHamSp, ints%iHamiltonian)
      tmpHamSp(:,1) = 2.0_dp * tmpHamSp(:,1)

      if (reks%isHybridXc) then
        ! reks%hamSqrL has (my_qm) component
        reks%hamSqrL(:,:,1,iL) = 0.0_dp
        call env%globalTimer%startTimer(globalTimers%sparseToDense)
        call unpackHS(reks%hamSqrL(:,:,1,iL), tmpHamSp(:,1), neighbourList%iNeighbour, &
            & nNeighbourSK, denseDesc%iAtomStart, iSparseStart, img2CentCell)
        call env%globalTimer%stopTimer(globalTimers%sparseToDense)
        call adjointLowerTriangle(reks%hamSqrL(:,:,1,iL))
      else
        ! reks%hamSpL has (my_qm) component
        reks%hamSpL(:,1,iL) = tmpHamSp(:,1)
      end if

    end do

    ! Calculate contribution to Hamiltonian including hybrid xc-functional part
    if (.not. reks%isHybridXc) then
      ! reks%hamSpL has (my_ud) component
      call qm2udL(reks%hamSpL, reks%Lpaired)
    else
      ! reks%hamSqrL has (my_ud) component
      call qm2udL(reks%hamSqrL, reks%Lpaired)
      do iL = 1, reks%Lmax
        ! Add hybrid xc-functional contribution to Hamiltonian
      #:if WITH_SCALAPACK
        call hybridXc%addCamHamiltonian_real(env, denseDesc, reks%overSqr,&
            & reks%deltaRhoSqrL(:,:, 1, iL), reks%hamSqrL(:,:,1,iL), errStatus)
      #:else
        call hybridXc%addCamHamiltonian_real(env, reks%deltaRhoSqrL(:,:,1,iL), reks%overSqr,&
            & ints%overlap, neighbourList%iNeighbour, nNeighbourCam, denseDesc%iAtomStart,&
            & iSparseStart, orb, img2CentCell, reks%tPeriodic, reks%hamSqrL(:,:, 1, iL), errStatus)
      #:endif
        @:PROPAGATE_ERROR(errStatus)
        ! Calculate the Fock-type exchange energy
        call hybridXc%getHybridEnergy_real(env, tmpEn(iL))
      end do
    end if


    ! Calculate energy contribution corresponding to upper Hamiltonian
    do iL = 1, reks%Lmax

      ! Get microstate index for non-SCC and hybrid xc-functional energy contribution
      if (iL <= reks%Lpaired) then
        tmpL = iL
        rsL = iL
      else
        if (mod(iL,2) == 1) then
          tmpL = iL
          rsL = iL + 1
        else
          tmpL = iL - 1
          rsL = iL - 1
        end if
      end if
      ! Set the long-range corrected energy contribution
      if (reks%isHybridXc) then
        energy%Efock = tmpEn(iL) + tmpEn(rsL)
      end if

      if (reks%tForces) then
        rhoPrim(:,1) = 0.0_dp
        call env%globalTimer%startTimer(globalTimers%denseToSparse)
        ! reks%rhoSqrL has (my_qm) component
        call packHS(rhoPrim(:,1), reks%rhoSqrL(:,:,1,tmpL), &
            & neighbourList%iNeighbour, nNeighbourSK, orb%mOrb, &
            & denseDesc%iAtomStart, iSparseStart, img2CentCell)
        call env%globalTimer%stopTimer(globalTimers%denseToSparse)
      else
        ! reks%rhoSpL has (my_qm) component
        rhoPrim(:,1) = reks%rhoSpL(:,1,tmpL)
      end if

      ! Calculate correct charge contribution for each microstate
      call sccCalc%updateCharges(env, reks%qOutputL(:,:,:,iL), orb, species, q0)
      call sccCalc%updateShifts(env, orb, species, neighbourList%iNeighbour, img2CentCell)
      potential%intShell(:,:,:) = reks%intShellL(:,:,:,iL)
      if (allocated(thirdOrd)) then
        call thirdOrd%updateCharges(pSpecies0, neighbourList, reks%qOutputL(:,:,:,iL), q0,&
            & img2CentCell, orb)
      end if

      call calcEnergies(env, sccCalc, tblite, reks%qOutputL(:,:,:,iL), q0,&
          & reks%chargePerShellL(:,:,:,iL), multipole, species, isExtField, isXlbomd, dftbU,&
          & tDualSpinOrbit, rhoPrim, H0, orb, neighbourList, nNeighbourSk, img2CentCell,&
          & iSparseStart, cellVol, extPressure, TS, potential, energy, thirdOrd, solvation,&
          & hybridXc, reks, qDepExtPot, qBlock, qiBlock, xi, iAtInCentralRegion, tFixEf, Ef,&
          & .true., onSiteElements, errStatus)
      @:PROPAGATE_ERROR(errStatus)

      if (allocated(dispersion)) then
        ! For dftd4 dispersion, update charges
        call dispersion%updateCharges(env, pSpecies0, neighbourList, reks%qOutputL(:,:,:,iL),&
            & q0, img2CentCell, orb)
        ! For MBD/TS dispersion, update onsite charges
        ! TODO : Currently, reks%qNetAtomL does not affect Hamiltonian
        if (reks%isQNetAllocated) then
          qNetAtom(:) = reks%qNetAtomL(:,iL)
        end if
        call dispersion%updateOnsiteCharges(qNetAtom, orb, referenceN0,&
            & species0, tConverged)
        call calcDispersionEnergy(dispersion, energy%atomDisp, energy%Edisp,&
            & iAtInCentralRegion)
      end if
      call sumEnergies(energy)

      ! Assign energy contribution of each microstate
      reks%enLnonSCC(iL) = energy%EnonSCC
      reks%enLSCC(iL) = energy%Escc
      reks%enLspin(iL) = energy%Espin
      if (allocated(thirdOrd)) then
        reks%enL3rd(iL) = energy%e3rd
      end if
      if (reks%isHybridXc) then
        reks%enLfock(iL) = energy%Efock
      end if
      if (reks%isDispersion) then
        reks%enLdisp(iL) = energy%Edisp
      end if
      reks%enLtot(iL) = energy%Etotal

      ! REKS is not affected by filling, so TS becomes 0
      energy%EMermin = energy%Etotal
      ! extrapolated to 0 K
      energy%Ezero = energy%Etotal
      energy%EGibbs = energy%EMermin + cellVol * extPressure
      energy%EForceRelated = energy%EGibbs

    end do

    if (reks%Plevel >= 2) then
      call printReksMicrostates(reks, energy%Erep)
    end if

  end subroutine getHamiltonianLandEnergyL


  !> Optimize the fractional occupation numbers (FONs) and weights
  !> Swap the active orbitals when fa < fb
  !> Compute the several energy contributions
  subroutine optimizeFONsAndWeights(eigvecs, filling, energy, reks)

    !> Eigenvectors
    real(dp), intent(inout) :: eigvecs(:,:,:)

    !> Occupations (level, kpoint, spin)
    real(dp), intent(out) :: filling(:,:,:)

    !> Energy contributions
    type(TEnergies), intent(inout) :: energy

    !> Data type for REKS
    type(TReksCalc), intent(inout) :: reks

    call optimizeFons(reks)
    call calcWeights(reks)

    call activeOrbSwap(reks, eigvecs(:,:,1))
    call getFilling(reks, filling(:,1,1))

    call calcSaReksEnergy(reks, energy)

    if (reks%Plevel >= 2) then
      call printSaReksEnergy(reks)
    end if

  end subroutine optimizeFONsAndWeights


  !> Returns input charges for next SCC iteration.
  subroutine getReksNextInputCharges(qInput, qOutput, qDiff, sccErrorQ, sccTol, tConverged,&
      & iSccIter, minSccIter, maxSccIter, iGeoStep, tStopScc, eigvecs, reks)

    !> Input charges (for potentials)
    real(dp), intent(inout) :: qInput(:, :, :)

    !> Output electrons
    real(dp), intent(inout) :: qOutput(:,:,:)

    !> Charge differences between input and output charges
    real(dp), intent(inout) :: qDiff(:,:,:)

    !> Self-consistency error
    real(dp), intent(out) :: sccErrorQ

    !> Tolerance on SCC charges between input and output
    real(dp), intent(in) :: sccTol

    !> Has the calculation converged>
    logical, intent(out) :: tConverged

    !> Number of current SCC step
    integer, intent(in) :: iSccIter

    !> Minimum number of SCC iterations to perform
    integer, intent(in) :: minSccIter

    !> Maximum number of SCC iterations before terminating loop
    integer, intent(in) :: maxSccIter

    !> Number of current geometry step
    integer, intent(in) :: iGeoStep

    !> Should the SCC loop stop
    logical, intent(in) :: tStopScc

    !> Eigenvectors on eixt
    real(dp), intent(inout) :: eigvecs(:,:,:)

    !> Data type for REKS
    type(TReksCalc), intent(inout) :: reks

    qDiff(:,:,:) = qOutput - qInput
    sccErrorQ = maxval(abs(qDiff))

    tConverged = (sccErrorQ < sccTol) &
        & .and. (iSccIter >= minSccIter .or. reks%tReadMO .or. iGeoStep > 0)
    if ((.not. tConverged) .and. (iSccIter /= maxSccIter .and. .not. tStopScc)) then
      qInput(:,:,:) = qOutput
      call guessNewEigvecs(eigvecs(:,:,1), reks%eigvecsFock)
    end if

  end subroutine getReksNextInputCharges


  !> Update delta density matrix rather than merely q for hybrid xc-functionals.
  subroutine getReksNextInputDensity(sccErrorQ, sccTol, tConverged, iSccIter, minSccIter,&
      & maxSccIter, iGeoStep, tStopScc, eigvecs, deltaRhoOut, deltaRhoIn, reks)

    !> Self-consistency error
    real(dp), intent(out) :: sccErrorQ

    !> Tolerance on SCC charges between input and output
    real(dp), intent(in) :: sccTol

    !> Has the calculation converged>
    logical, intent(out) :: tConverged

    !> Number of current SCC step
    integer, intent(in) :: iSccIter

    !> Minimum number of SCC iterations to perform
    integer, intent(in) :: minSccIter

    !> Maximum number of SCC iterations before terminating loop
    integer, intent(in) :: maxSccIter

    !> Number of current geometry step
    integer, intent(in) :: iGeoStep

    !> Should the SCC loop stop
    logical, intent(in) :: tStopScc

    !> Eigenvectors on eixt
    real(dp), intent(inout) :: eigvecs(:,:,:)

    !> Delta density matrix for hybrid xc-functional calculations
    real(dp), intent(inout) :: deltaRhoOut(:,:,:)

    !> Delta density matrix as inpurt for next SCC cycle
    real(dp), target, intent(inout) :: deltaRhoIn(:,:,:)

    !> Data type for REKS
    type(TReksCalc), intent(inout) :: reks

    !! Difference of delta density matrix in and out
    real(dp), allocatable :: deltaRhoDiffSqr(:,:,:)

    deltaRhoDiffSqr = deltaRhoOut - deltaRhoIn
    sccErrorQ = maxval(abs(deltaRhoDiffSqr))

    tConverged = (sccErrorQ < sccTol) &
        & .and. (iSccIter >= minSccIter .or. reks%tReadMO .or. iGeoStep > 0)
    if ((.not. tConverged) .and. (iSccIter /= maxSccIter .and. .not. tStopScc)) then
      deltaRhoIn(:,:,:) = deltaRhoOut
      call guessNewEigvecs(eigvecs(:,:, 1), reks%eigvecsFock)
    end if

  end subroutine getReksNextInputDensity


  !> Set correct dipole moment according to type of REKS calculation
  subroutine assignDipoleMoment(dipoleTmp, dipoleMoment, iDet, tDipole, reks, isSingleState)

    !> Resulting temporary dipole moment
    real(dp), allocatable, intent(in) :: dipoleTmp(:)

    !> Resulting dipole moment
    real(dp), allocatable, intent(inout) :: dipoleMoment(:,:)

    !> Which state is being calculated in the determinant loop?
    integer, intent(in) :: iDet

    !> Calculate an electric dipole?
    logical, intent(in) :: tDipole

    !> Data type for REKS
    type(TReksCalc), intent(inout) :: reks

    !> Calculate a single-state REKS?
    logical, intent(in) :: isSingleState

    ! Set correct dipole moment to this%dipoleMoment
    if (tDipole) then
      if (isSingleState) then
        ! For single-state REKS case, see getStateInteraction routine.
        if (reks%Efunction == 1) then
          dipoleMoment(:,iDet) = dipoleTmp
        end if
      else
        ! (SI)-SA-REKS case, see getReksGradProperties routine.
        if (reks%Efunction > 1) then
          dipoleMoment(:,iDet) = dipoleTmp
        end if
      end if
    end if

  end subroutine assignDipoleMoment

end module dftbp_dftbplus_main
